---
title: React Hook Form vs Formik - Comparing the most popular React form libraries
description: This article will compare React Hook Form and Formik by highlighting their strengths and weaknesses.
slug: react-hook-form-vs-formik
authors: joseph_mawa
tags: [react-hook-form, formik,forms]
image: https://refine.ams3.cdn.digitaloceanspaces.com/blog/2023-01-30-compare-form-libraries/social.png
hide_table_of_contents: false
---


# A Week Of Refine-2
# Setting Up the Client App

In this episode, we initialize our **Pixels** app using **refine** and get familiar with the boilerplate code to be created with the `superplate-cli` tool.

This is Day 2 of the [**AWeekOfRefine**](https://refine.dev/week-of-refine/) series. **AWeekOfRefine** is a seven-part tutorial that aims to help developers learn the ins-and-outs of **refine**'s powerful capabilities and get going with **refine** within a week.


## Overview

In the previous post, we got a preview of **refine**'s underlying architecture, especially on how **refine**'s core modules abstract and divide an app's logic inside individual providers and allow their methods to be easily accessed and executed with hooks from inside consumer components. This abstraction at the providers layer is where **refine** shines and require extensive configuration to begin with.

In this part, we will get into the details of two important providers: namely, the `dataProvider` and `authProvider` props of our `<Refine />` component. We will be building on this knowledge in the coming episodes.

The providers will be generated by the `superplate-cli` based on our choice, so we'll start off with setting up the **Pixels** app right away.
<br />


## Project Setup

For this project, we are using a PostgreSQL database hosted in the **Supabase** cloud. **refine** comes with an optional package for **Supabase** that gives us `dataProvider` and `authProvider`s out-of-the-box for handling requests for CRUD actions, authentication and authorization against models hosted in a **Supabase** server.

We are going to include **refine**'s Ant Design package for the UI side.

Let's go ahead and use the `superplate-cli` tool to interactively initialize the project. Navigate to a folder of your choice and run:

```bash
npx superplate-cli pixels
````

```bash
npm create refine-app@latest pixels
```

`superplate-cli` presents us with a set of questions for choosing the libraries and frameworks we want to work with. We'll initialize a **refine** project with `craco` to manage our configurations. Other important things are to be able to customize our **Ant Design** theme and layout. So, I chose the following options:



```bash
✔ Choose a project template · refine(CRA)
✔ What would you like to name your project?: · pixels
✔ Choose your backend service to connect: · Supabase
✔ Do you want to use a UI Framework?: · Ant Design
✔ Do you want to add example pages?: · no
✔ Do you want to add dark mode support?: · no
✔ Do you want to customize the Ant Design layout?: · yes
✔ Do you need i18n (Internationalization) support?: · no
✔ Do you want to add kbar command interface support?: · no
✔ Would you mind sending us your choices so that we can improve superplate? · yes
```

This should create a rudimentary **refine** app that supports **Ant Design** in the UI and **Supabase** in the backend. If we open the app in our code editor, we can see that **refine**'s optional packages for **Ant Design** and **Supabase** are added to `package.json`:

```json
// package.json

"dependencies": {
  "@pankod/refine-antd": "^4.7.0",
  "@pankod/refine-core": "^3.18.0",
  "@pankod/refine-react-router-v6": "^3.18.0",
  "@pankod/refine-supabase": "^3.18.0",
}
```

We are going to use **Ant Design** components for our UI thanks to the `@pankod/refine-antd` module. `@pankod/refine-supabase` module allows us to use **refine**'s **Supabase** auth and data providers.

We'll cover these **Supabase** related providers as we add features to our app in the upcoming episodes. However, let's try building the app for now, and check what we have in the browser after running the development server. In the terminal, run the following command:

```bash
yarn dev
```

After that, navigate to `http://localhost:3000`, and lo and behold! we have a **refine** app:

![1-setting-up-the-client-app](https://imgbox.com/m4wGOaQP)

![](https://i.imgur.com/eatdBst.png)

<br />


## Exploring the App

Let's now see what **refine** scaffolded for us during initialization.

Our main point of focus is the `src` folder. And for now, especially the `<App />` component.

If we look inside the `App.tsx` file, we can see a `<Refine />` component crowded with passed in **props**:

```TypeScript
// App.tsx

iimport React from "react";

import { Refine } from "@pankod/refine-core";
import {
  AuthPage,
  notificationProvider,
  ReadyPage,
  ErrorComponent,
} from "@pankod/refine-antd";
import "@pankod/refine-antd/dist/reset.css";

import { dataProvider, liveProvider } from "@pankod/refine-supabase";
import routerProvider from "@pankod/refine-react-router-v6";
import { supabaseClient } from "utility";
import {
  Title,
  Header,
  Sider,
  Footer,
  Layout,
  OffLayoutArea,
} from "components/layout";
import authProvider from "./authProvider";

function App() {
  return (
    <Refine
      dataProvider={dataProvider(supabaseClient)}
      liveProvider={liveProvider(supabaseClient)}
      authProvider={authProvider}
      routerProvider={{
        ...routerProvider,
        routes: [
          {
            path: "/register",
            element: <AuthPage type="register" />,
          },
          {
            path: "/forgot-password",
            element: <AuthPage type="forgotPassword" />,
          },
          {
            path: "/update-password",
            element: <AuthPage type="updatePassword" />,
          },
        ],
      }}
      LoginPage={() => (
        <AuthPage
          type="login"
          providers={[
            {
              name: "google",
              label: "Sign in with Google",
            },
          ]}
          formProps={{
            initialValues: {
              email: "info@refine.dev",
              password: "refine-supabase",
            },
          }}
        />
      )}
      notificationProvider={notificationProvider}
      ReadyPage={ReadyPage}
      catchAll={<ErrorComponent />}
      Title={Title}
      Header={Header}
      Sider={Sider}
      Footer={Footer}
      Layout={Layout}
      OffLayoutArea={OffLayoutArea}
    />
  );
}

export default App;
```

Today, we'll examine a few of these props so that we are ready to move to the next episode.
<br />


### The `<Refine />` Component

The `<Refine />` component is the entry point of a **refine** app. In order to leverage the power of **refine**'s abstraction layers, we need to have the `<Refine />` component.

Then we have to configure the `<Refine />` component with the provider objects we want to use in our app. We can see that `superplate-cli` already added the props for us inside `<Refine />` out-of-the-box. We will be using them in our **Pixels** app. Some provider objects like the `routerProvider` or the `dataProvider` are defined for us by **refine**'s core or support modules and some like the `accessControlProvider` have to be defined by ourselves.
<br />


### `<Refine />`'s `dataProvider` Prop

**refine**'s **data provider** is the context which allows the app to communicate with a backend API via a `http` client. It subsequently makes response data returned from HTTP requests available to consumer components via a set of **refine** data hooks.

If we look closely, our `dataProvider` prop derives a value from a call to `dataProvider(supabaseClient)`:

```TypeScript
// Inside App.tsx

dataProvider={dataProvider(supabaseClient)}
```

The returned object, also called the **`dataProvider`** object, has the following signature:

```TypeScript
// Data provider object signature

const dataProvider = {
	create: ({ resource, variables, metaData }) => Promise,
	createMany: ({ resource, variables, metaData }) => Promise,
	deleteOne: ({ resource, id, variables, metaData }) => Promise,
	deleteMany: ({ resource, ids, variables, metaData }) => Promise,
	getList: ({
		resource,
		pagination,
		hasPagination,
		sort,
		filters,
		metaData,
	}) => Promise,
	getMany: ({ resource, ids, metaData }) => Promise,
	getOne: ({ resource, id, metaData }) => Promise,
	update: ({ resource, id, variables, metaData }) => Promise,
	updateMany: ({ resource, ids, variables, metaData }) => Promise,
	custom: ({
		url,
		method,
		sort,
		filters,
		payload,
		query,
		headers,
		metaData,
	}) => Promise,
	getApiUrl: () => "",
};
```

Each item in this object is a method that has to be defined by us or **refine**'s packages.

**refine** supports [15+ backend](https://refine.dev/integrations/) `dataProvider` integrations as optional packages that come with distinct definitions of these methods that handle CRUD operations according to their underlying architectures. The full list can be found [here](https://refine.dev/docs/packages/list-of-packages/#data-provider-packages).

Normally, for our own backend API, we have to define each method we need for sending `http` requests inside a `dataProvider` object as above. But since we are using the `@pankod/refine-supabase` package, `dataProvider={dataProvider(supabaseClient)}` makes the following object available to us:

```TypeScript
// Inside node_modules/@pankod/refine-supabase/src/index.ts#dataProvider
// version 3.35.0

const dataProvider = (
	supabaseClient: SupabaseClient,
): Required<DataProvider> => {
	return {
		getList: async ({
				resource,
				hasPagination = true,
				pagination = { current: 1, pageSize: 10 },
				filters,
				sort,
				metaData,
		}) => {
			const { current = 1, pageSize = 10 } = pagination ?? {};

			const query = supabaseClient
				.from(resource)
				.select(metaData?.select ?? "*", {
					count: "exact",
				});

			if (hasPagination) {
				query.range((current - 1) * pageSize, current * pageSize - 1);
			}

			sort?.map((item) => {
				const [foreignTable, field] = item.field.split(/\.(.*)/);

				if (foreignTable && field) {
					query
						.select(
							metaData?.select ?? `*, ${foreignTable}(${field})`,
						)
						.order(field, {
							ascending: item.order === "asc",
							foreignTable: foreignTable,
						});
				} else {
					query.order(item.field, {
						ascending: item.order === "asc",
					});
				}
			});

			filters?.map((item) => {
				generateFilter(item, query);
			});

			const { data, count, error } = await query;

			if (error) {
				return handleError(error);
			}

			return {
				data: data || [],
				total: count || 0,
			};
		},

		getMany: async ({ resource, ids, metaData }) => {
			const { data, error } = await supabaseClient
				.from(resource)
				.select(metaData?.select ?? "*")
				.in(metaData?.id ?? "id", ids);

			if (error) {
				return handleError(error);
			}

			return {
				data: data || [],
			};
		},

		create: async ({ resource, variables }) => {
			const { data, error } = await supabaseClient
				.from(resource)
				.insert(variables);

			if (error) {
					return handleError(error);
			}

			return {
				data: (data || [])[0] as any,
			};
		},

		createMany: async ({ resource, variables }) => {
			const { data, error } = await supabaseClient
				.from(resource)
				.insert(variables);

			if (error) {
				return handleError(error);
			}

			return {
				data: data as any,
			};
		},

		update: async ({ resource, id, variables, metaData }) => {
			const query = supabaseClient.from(resource).update(variables);

			if (metaData?.id) {
				query.eq(metaData?.id, id);
			} else {
				query.match({ id });
			}

			const { data, error } = await query;
			if (error) {
				return handleError(error);
			}

			return {
				data: (data || [])[0] as any,
			};
		},

		updateMany: async ({ resource, ids, variables, metaData }) => {
			const response = await Promise.all(
				ids.map(async (id) => {
					const query = supabaseClient
						.from(resource)
						.update(variables);

					if (metaData?.id) {
						query.eq(metaData?.id, id);
					} else {
						query.match({ id });
					}

					const { data, error } = await query;
					if (error) {
						return handleError(error);
					}

					return (data || [])[0];
				}),
			);

			return {
				data: response,
			};
		},

		getOne: async ({ resource, id, metaData }) => {
			const query = supabaseClient
				.from(resource)
				.select(metaData?.select ?? "*");

			if (metaData?.id) {
				query.eq(metaData?.id, id);
			} else {
				query.match({ id });
			}

			const { data, error } = await query;
			if (error) {
				return handleError(error);
			}

			return {
				data: (data || [])[0] as any,
			};
		},

		deleteOne: async ({ resource, id, metaData }) => {
			const query = supabaseClient.from(resource).delete();

			if (metaData?.id) {
				query.eq(metaData?.id, id);
			} else {
				query.match({ id });
			}

			const { data, error } = await query;
			if (error) {
				return handleError(error);
			}

			return {
				data: (data || [])[0] as any,
			};
		},

		deleteMany: async ({ resource, ids, metaData }) => {
			const response = await Promise.all(
				ids.map(async (id) => {
					const query = supabaseClient.from(resource).delete();

					if (metaData?.id) {
						query.eq(metaData?.id, id);
					} else {
						query.match({ id });
					}

					const { data, error } = await query;
					if (error) {
						return handleError(error);
					}

					return (data || [])[0];
				}),
			);

			return {
				data: response,
			};
		},

		getApiUrl: () => {
			throw Error("Not implemented on refine-supabase data provider.");
		},

		custom: () => {
			throw Error("Not implemented on refine-supabase data provider.");
		},
	};
};
```

We don't have to get into the mind of the people at **refine** yet, but if we skim over closely, the `dataProvider` object above has pretty much every method we need to perform all CRUD operations against a **Supabase** database. Notable methods we are going to use in our app are: `create()`, `getOne()`, `getList()` and `update()`.

For the details of how these methods work, please take your time to scan through the [`dataProvider` API reference](https://refine.dev/docs/api-reference/core/providers/data-provider/).


In order to get the **Supabase** `dataProvider` object to deliver, first a `supabaseClient` has to be set up.
<br />


### **refine**'s `supabaseClient`

If we look inside `src/utility/`, we have a `supabaseClient.ts` file containing the credentials of a client that provides us access to a **Supabase** backend:

```TypeScript
// src/utility/supabaseClient.ts

import { createClient } from "@pankod/refine-supabase";

const SUPABASE_URL = "https://iwdfzvfqbtokqetmbmbp.supabase.co";
const SUPABASE_KEY =
    "eyJhbGciOiJIUzI1NiIsInR5cCI6IkpXVCJ9.eyJyb2xlIjoiYW5vbiIsImlhdCI6MTYzMDU2NzAxMCwiZXhwIjoxOTQ2MTQzMDEwfQ._gr6kXGkQBi9BM9dx5vKaNKYj_DJN1xlkarprGpM_fU";

export const supabaseClient = createClient(SUPABASE_URL, SUPABASE_KEY);
```

This file was also generated for us by `superplate-cli` using **refine**'s **Supabase** package.

Inside `<Refine />` component, we are getting the value of the `dataProvider` prop by passing in `supabaseClient` to the `dataProvider()` function imported from this package:

```TypeScript
dataProvider={dataProvider(supabaseClient)}
```

We need to tweak the `supabaseClient.ts` file with our own credentials, which we will do when we add `resources` to our app.

If we inspect further, setting up **Supabase** with **refine** helps us enable not only the `dataProvider` prop, but also the `authProvider` and `liveProvider` props inside `<Refine />`. This is because they all depend on `supabaseClient` to send `http` requests. We'll explore the `liveProvider` prop on Day 4, but let's also look at the `authProvider` here to enhance our understanding.
<br />


### `<Refine />`'s `authProvider` Prop

We can clearly see in our `<Refine />` component that `superplate-cli` already enabled the `authProvider` prop by passing in the corresponding object for us:

```TypeScript
authProvider={authProvider}
```

Earlier on, the `authProvider` object was already created by `superplate-cli` inside the `authProvider.ts` file:

```TypeScript
// src/authProvider.ts

import { AuthProvider } from "@pankod/refine-core";

import { supabaseClient } from "utility";

const authProvider: AuthProvider = {
	login: async ({ email, password, providerName }) => {
		const { user, error } = await supabaseClient.auth.signIn({
			email,
			password,
			provider: providerName,
		});

		if (error) {
			return Promise.reject(error);
		}

		if (user) {
			return Promise.resolve();
		}

		// for third-party login
		return Promise.resolve(false);
	},
	register: async ({ email, password }) => {
		const { user, error } = await supabaseClient.auth.signUp({
			email,
			password,
		});

		if (error) {
			return Promise.reject(error);
		}

		if (user) {
			return Promise.resolve();
		}
	},
	forgotPassword: async ({ email }) => {
		const {
			data,
			error,
		} = await supabaseClient.auth.api.resetPasswordForEmail(email, {
			redirectTo: `${window.location.origin}/update-password`,
		});

		if (error) {
			return Promise.reject(error);
		}

		if (data) {
			return Promise.resolve();
		}
	},
	updatePassword: async ({ password }) => {
		const { data, error } = await supabaseClient.auth.update({ password });

		if (error) {
			return Promise.reject(error);
		}

		if (data) {
			return Promise.resolve("/");
		}
	},
	logout: async () => {
		const { error } = await supabaseClient.auth.signOut();

		if (error) {
			return Promise.reject(error);
		}

		return Promise.resolve("/");
	},
	checkError: () => Promise.resolve(),
	checkAuth: async () => {
		const session = supabaseClient.auth.session();
		const sessionFromURL = await supabaseClient.auth.getSessionFromUrl();

		if (session || sessionFromURL?.data?.user) {
			return Promise.resolve();
		}

		return Promise.reject();
	},
	getPermissions: async () => {
		const user = supabaseClient.auth.user();

		if (user) {
			return Promise.resolve(user.role);
		}
	},
	getUserIdentity: async () => {
		const user = supabaseClient.auth.user();

		if (user) {
			return Promise.resolve({
				...user,
				name: user.email,
			});
		}
	},
};

export default authProvider;
```

This object has all the methods we need to implement an email / password based authentication and authorization system in our app.

Notice, as mentioned before, that `authProvider` relies on `supabaseClient` to connect to our **Supabase** database. So, in this case, our `authoProvider` was generated as part of the **Supabase** package.

As we can infer by now, although we have stated that **refine** performs and manages a lot of heavylifting and simplifies the app logic by dividing concerns into separate contexts, providers and hooks, _configuring_ all these providers is a heavy task itself.

It, fortunately, makes configuration easier by composing individual providers inside a single object.

These are pretty much the essentials we should get familiar with in order to accept the invitation to add `resources` to the `<Refine />` component.
<br />


## Summary

In this post, we went through the process of initializing our **Pixels** app with a **Supabase** hosted PostgreSQL database and **Ant Design** UI framework.

We then explored the boilerplate code created by `superplate-cli` using **refine**'s **Supabase** support package, especially the files related to `dataProvider` and `authProvider` props of the `<Refine />` component. We touched on setting `supabaseClient` which is used by these providers to send HTTP requests to the **Supabase** backend.

In the next article, we will use these providers to implement RESTful CRUD actions for creating a canvas, showing a canvas, drawing pixels on it and showing a public gallery that lists canvases. We will also add authentication to our app.
