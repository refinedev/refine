"use strict";(self.webpackChunkdocumentation=self.webpackChunkdocumentation||[]).push([[98997],{58860:(e,t,n)=>{n.d(t,{xA:()=>m,yg:()=>y});var a=n(37953);function i(e,t,n){return t in e?Object.defineProperty(e,t,{value:n,enumerable:!0,configurable:!0,writable:!0}):e[t]=n,e}function r(e,t){var n=Object.keys(e);if(Object.getOwnPropertySymbols){var a=Object.getOwnPropertySymbols(e);t&&(a=a.filter((function(t){return Object.getOwnPropertyDescriptor(e,t).enumerable}))),n.push.apply(n,a)}return n}function s(e){for(var t=1;t<arguments.length;t++){var n=null!=arguments[t]?arguments[t]:{};t%2?r(Object(n),!0).forEach((function(t){i(e,t,n[t])})):Object.getOwnPropertyDescriptors?Object.defineProperties(e,Object.getOwnPropertyDescriptors(n)):r(Object(n)).forEach((function(t){Object.defineProperty(e,t,Object.getOwnPropertyDescriptor(n,t))}))}return e}function o(e,t){if(null==e)return{};var n,a,i=function(e,t){if(null==e)return{};var n,a,i={},r=Object.keys(e);for(a=0;a<r.length;a++)n=r[a],t.indexOf(n)>=0||(i[n]=e[n]);return i}(e,t);if(Object.getOwnPropertySymbols){var r=Object.getOwnPropertySymbols(e);for(a=0;a<r.length;a++)n=r[a],t.indexOf(n)>=0||Object.prototype.propertyIsEnumerable.call(e,n)&&(i[n]=e[n])}return i}var p=a.createContext({}),l=function(e){var t=a.useContext(p),n=t;return e&&(n="function"==typeof e?e(t):s(s({},t),e)),n},m=function(e){var t=l(e.components);return a.createElement(p.Provider,{value:t},e.children)},c="mdxType",d={inlineCode:"code",wrapper:function(e){var t=e.children;return a.createElement(a.Fragment,{},t)}},g=a.forwardRef((function(e,t){var n=e.components,i=e.mdxType,r=e.originalType,p=e.parentName,m=o(e,["components","mdxType","originalType","parentName"]),c=l(n),g=i,y=c["".concat(p,".").concat(g)]||c[g]||d[g]||r;return n?a.createElement(y,s(s({ref:t},m),{},{components:n})):a.createElement(y,s({ref:t},m))}));function y(e,t){var n=arguments,i=t&&t.mdxType;if("string"==typeof e||i){var r=n.length,s=new Array(r);s[0]=g;var o={};for(var p in t)hasOwnProperty.call(t,p)&&(o[p]=t[p]);o.originalType=e,o[c]="string"==typeof e?e:i,s[1]=o;for(var l=2;l<r;l++)s[l]=n[l];return a.createElement.apply(null,s)}return a.createElement.apply(null,n)}g.displayName="MDXCreateElement"},4803:(e,t,n)=>{n.r(t),n.d(t,{assets:()=>m,contentTitle:()=>p,default:()=>y,frontMatter:()=>o,metadata:()=>l,toc:()=>c});n(37953);var a=n(58860);function i(e,t,n){return t in e?Object.defineProperty(e,t,{value:n,enumerable:!0,configurable:!0,writable:!0}):e[t]=n,e}function r(e,t){return t=null!=t?t:{},Object.getOwnPropertyDescriptors?Object.defineProperties(e,Object.getOwnPropertyDescriptors(t)):function(e,t){var n=Object.keys(e);if(Object.getOwnPropertySymbols){var a=Object.getOwnPropertySymbols(e);t&&(a=a.filter((function(t){return Object.getOwnPropertyDescriptor(e,t).enumerable}))),n.push.apply(n,a)}return n}(Object(t)).forEach((function(n){Object.defineProperty(e,n,Object.getOwnPropertyDescriptor(t,n))})),e}function s(e,t){if(null==e)return{};var n,a,i=function(e,t){if(null==e)return{};var n,a,i={},r=Object.keys(e);for(a=0;a<r.length;a++)n=r[a],t.indexOf(n)>=0||(i[n]=e[n]);return i}(e,t);if(Object.getOwnPropertySymbols){var r=Object.getOwnPropertySymbols(e);for(a=0;a<r.length;a++)n=r[a],t.indexOf(n)>=0||Object.prototype.propertyIsEnumerable.call(e,n)&&(i[n]=e[n])}return i}const o={title:"Essentials of TypeScript Classes",description:"TypeScript classes are a superset of JavaScript classes. This post covers the fundamentals of type annotations in TypeScript Classes and their associated quirks.",slug:"typescript-classes",authors:"abdullah_numan",tags:["typescript"],image:"https://refine.ams3.cdn.digitaloceanspaces.com/blog/2023-11-07-ts-classes/social-2.png",hide_table_of_contents:!1},p=void 0,l={permalink:"/blog/typescript-classes",source:"@site/blog/2025-01-13-ts-classes.md",title:"Essentials of TypeScript Classes",description:"TypeScript classes are a superset of JavaScript classes. This post covers the fundamentals of type annotations in TypeScript Classes and their associated quirks.",date:"2025-01-13T00:00:00.000Z",formattedDate:"January 13, 2025",tags:[{label:"typescript",permalink:"/blog/tags/typescript"}],readingTime:22.96,hasTruncateMarker:!1,authors:[{name:"Abdullah Numan",title:"Fullstack Developer",url:"https://github.com/anewman15/",imageURL:"https://github.com/anewman15.png",key:"abdullah_numan"}],frontMatter:{title:"Essentials of TypeScript Classes",description:"TypeScript classes are a superset of JavaScript classes. This post covers the fundamentals of type annotations in TypeScript Classes and their associated quirks.",slug:"typescript-classes",authors:"abdullah_numan",tags:["typescript"],image:"https://refine.ams3.cdn.digitaloceanspaces.com/blog/2023-11-07-ts-classes/social-2.png",hide_table_of_contents:!1},prevItem:{title:"How to Use the TypeScript satisfies Operator",permalink:"/blog/typescript-satisfies-operator"},nextItem:{title:"An Introduction to Using FastAPI",permalink:"/blog/introduction-to-fast-api"},relatedPosts:[{title:"How to use TypeScript Partial Type?",description:"We'll explain the TypeScript Partial utility type with examples",permalink:"/blog/typescript-partial-utility-type",formattedDate:"December 18, 2024",authors:[{name:"Abdullah Numan",title:"Fullstack Developer",url:"https://github.com/anewman15/",imageURL:"https://github.com/anewman15.png",key:"abdullah_numan"}],readingTime:5.25,date:"2024-12-18T00:00:00.000Z"},{title:"TypeScript Record Type with Examples",description:"We'll explore TypeScript Record type with examples.",permalink:"/blog/typescript-record-type",formattedDate:"January 6, 2025",authors:[{name:"Abdullah Numan",title:"Fullstack Developer",url:"https://github.com/anewman15/",imageURL:"https://github.com/anewman15.png",key:"abdullah_numan"}],readingTime:8.085,date:"2025-01-06T00:00:00.000Z"},{title:"A Guide on TypeScript Omit Type",description:"We'll dive into the TypeScript Omit utility type with examples",permalink:"/blog/typescript-omit-utility-type",formattedDate:"December 17, 2024",authors:[{name:"Abdullah Numan",title:"Fullstack Developer",url:"https://github.com/anewman15/",imageURL:"https://github.com/anewman15.png",key:"abdullah_numan"}],readingTime:5.75,date:"2024-12-17T00:00:00.000Z"}],authorPosts:[{title:"A Definitive guide on JavaScript every Method",description:"We expound with examples what the JavaScript every method is, how it works and when to use it.",permalink:"/blog/javascript-every-method",formattedDate:"January 17, 2025",authors:[{name:"Abdullah Numan",title:"Fullstack Developer",url:"https://github.com/anewman15/",imageURL:"https://github.com/anewman15.png",key:"abdullah_numan"}],readingTime:14.22,date:"2025-01-17T00:00:00.000Z"},{title:"A Detailed Guide on TypeScript Pick Type",description:"We'll deep dive into the TypeScript Pick utility type with examples and use cases.",permalink:"/blog/typescript-pick-utility-type",formattedDate:"December 17, 2024",authors:[{name:"Abdullah Numan",title:"Fullstack Developer",url:"https://github.com/anewman15/",imageURL:"https://github.com/anewman15.png",key:"abdullah_numan"}],readingTime:7.51,date:"2024-12-17T00:00:00.000Z"},{title:"How to Use JavaScript Array some",description:"JavaScript some method implementation on Array with examples",permalink:"/blog/javascript-some-method",formattedDate:"November 4, 2024",authors:[{name:"Abdullah Numan",title:"Fullstack Developer",url:"https://github.com/anewman15/",imageURL:"https://github.com/anewman15.png",key:"abdullah_numan"}],readingTime:14.44,date:"2024-11-04T00:00:00.000Z"}]},m={authorsImageUrls:[void 0]},c=[{value:"Introduction",id:"introduction",level:2}],d={toc:c},g="wrapper";function y(e){var{components:t}=e,n=s(e,["components"]);return(0,a.yg)(g,r(function(e){for(var t=1;t<arguments.length;t++){var n=null!=arguments[t]?arguments[t]:{},a=Object.keys(n);"function"==typeof Object.getOwnPropertySymbols&&(a=a.concat(Object.getOwnPropertySymbols(n).filter((function(e){return Object.getOwnPropertyDescriptor(n,e).enumerable})))),a.forEach((function(t){i(e,t,n[t])}))}return e}({},d,n),{components:t,mdxType:"MDXLayout"}),(0,a.yg)("p",null,(0,a.yg)("strong",{parentName:"p"},"This article was last updated on January 13, 2025, to include best practices for using TypeScript classes, a detailed table comparing TypeScript classes with JavaScript ES6 classes, and tips for avoiding common mistakes when implementing class features like readonly fields, access modifiers, and this bindings.")),(0,a.yg)("h2",{id:"introduction"},"Introduction"),(0,a.yg)("admonition",{title:"What is TypeScript Classes?",type:"tip"},(0,a.yg)("p",{parentName:"admonition"},"TypeScript classes are an extension of the ES6 classes of JavaScript, adding type annotations, access modifiers (",(0,a.yg)("inlineCode",{parentName:"p"},"public"),", ",(0,a.yg)("inlineCode",{parentName:"p"},"private"),", ",(0,a.yg)("inlineCode",{parentName:"p"},"protected"),"), and other features such as ",(0,a.yg)("inlineCode",{parentName:"p"},"readonly")," fields, ",(0,a.yg)("inlineCode",{parentName:"p"},"static")," members, and parameter properties."),(0,a.yg)("p",{parentName:"admonition"},"Key points to remember:"),(0,a.yg)("ul",{parentName:"admonition"},(0,a.yg)("li",{parentName:"ul"},"TypeScript Classes are typed versions of JavaScript ES6 classes."),(0,a.yg)("li",{parentName:"ul"},"Class members - fields, methods, and accessors can have type annotations and visibility modifiers."),(0,a.yg)("li",{parentName:"ul"},"The fields marked as ",(0,a.yg)("inlineCode",{parentName:"li"},"readonly")," can only be assigned during declaration or in the constructor."),(0,a.yg)("li",{parentName:"ul"},"Declare and initialize fields directly in the constructor using parameter properties."),(0,a.yg)("li",{parentName:"ul"},"TypeScript mitigates the issues with ",(0,a.yg)("inlineCode",{parentName:"li"},"this")," binding by using arrow functions or the ",(0,a.yg)("inlineCode",{parentName:"li"},"this")," parameter. - Classes support generics and multiple interfaces using the ",(0,a.yg)("inlineCode",{parentName:"li"},"implements")," keyword.\n:::")),(0,a.yg)("p",{parentName:"admonition"},"TypeScript supports all the features of JavaScript Class syntax introduced in ES2015. Basically, type annotations are applied to all members, namely: fields, constructors, methods and accessors -- and where applicable, parameters as well. TypeScript also bakes in a special syntax to class constructors called ",(0,a.yg)("strong",{parentName:"p"},"parameter properties")," which allows us to declare a class ",(0,a.yg)("strong",{parentName:"p"},"field")," from the constructor function's parameters."),(0,a.yg)("p",{parentName:"admonition"},"A TypeScript class definition creates a type from itself and it is used to validate conformity of an instance. TypeScript allows generic classes with type parameters passed to the outer class definition. Usually, generic class type parameters are accepted as constructor parameters, but they can also be passed to fields, methods and accessors as well. A single TS class can implement multiple other ",(0,a.yg)("strong",{parentName:"p"},"interfaces"),", something that is done with the ",(0,a.yg)("inlineCode",{parentName:"p"},"implements")," keyword."),(0,a.yg)("p",{parentName:"admonition"},"Besides type annotations, TypeScript adds member visibility across the prototype chain with three access modifiers: ",(0,a.yg)("inlineCode",{parentName:"p"},"public"),", ",(0,a.yg)("inlineCode",{parentName:"p"},"protected")," and ",(0,a.yg)("inlineCode",{parentName:"p"},"private")," -- a feature distinct from how ES2022 implements member privacy with ",(0,a.yg)("inlineCode",{parentName:"p"},"#"),"."),(0,a.yg)("p",{parentName:"admonition"},"JavaScript ",(0,a.yg)("inlineCode",{parentName:"p"},"this")," keyword leads to some unpredictability in different ",(0,a.yg)("strong",{parentName:"p"},"call site")," contexts. TypeScript is geared to mitigate during development some of the call site uncertainties by allocating a possible ",(0,a.yg)("inlineCode",{parentName:"p"},"this")," parameter to a method's first argument."),(0,a.yg)("p",{parentName:"admonition"},"Steps we'll cover in this post:"),(0,a.yg)("ul",{parentName:"admonition"},(0,a.yg)("li",{parentName:"ul"},(0,a.yg)("a",{parentName:"li",href:"#typing-class-members-in-typescript"},"Typing Class Members in TypeScript"),(0,a.yg)("ul",{parentName:"li"},(0,a.yg)("li",{parentName:"ul"},(0,a.yg)("a",{parentName:"li",href:"#typing-fields-in-typescript"},"Typing Fields in TypeScript")),(0,a.yg)("li",{parentName:"ul"},(0,a.yg)("a",{parentName:"li",href:"#typescript-classes---constructor-functions"},"TypeScript Classes - Constructor Functions")),(0,a.yg)("li",{parentName:"ul"},(0,a.yg)("a",{parentName:"li",href:"#typescript-classes---typing-methods"},"TypeScript Classes - Typing Methods")),(0,a.yg)("li",{parentName:"ul"},(0,a.yg)("a",{parentName:"li",href:"#typescript-classes---typing-accessors"},"TypeScript Classes - Typing Accessors")))),(0,a.yg)("li",{parentName:"ul"},(0,a.yg)("a",{parentName:"li",href:"#this-object-in-typescript-classes"},(0,a.yg)("inlineCode",{parentName:"a"},"this")," Object in TypeScript Classes"),(0,a.yg)("ul",{parentName:"li"},(0,a.yg)("li",{parentName:"ul"},(0,a.yg)("a",{parentName:"li",href:"#typescript-classes---arrow-functions-for-permanently-attaching-this-object"},"TypeScript Classes - Arrow Functions for Permanently Attaching ",(0,a.yg)("inlineCode",{parentName:"a"},"this")," Object")),(0,a.yg)("li",{parentName:"ul"},(0,a.yg)("a",{parentName:"li",href:"#typescript-classes---context-binding-with-this-parameter"},"TypeScript Classes - Context Binding with ",(0,a.yg)("inlineCode",{parentName:"a"},"this")," Parameter")))),(0,a.yg)("li",{parentName:"ul"},(0,a.yg)("a",{parentName:"li",href:"#faq"},"FAQ")),(0,a.yg)("li",{parentName:"ul"},(0,a.yg)("a",{parentName:"li",href:"#typescript-generic-classes"},"TypeScript Generic Classes")),(0,a.yg)("li",{parentName:"ul"},(0,a.yg)("a",{parentName:"li",href:"#typescript-classes---multiple-interfaces-with-implements"},"TypeScript Classes - Multiple Interfaces with ",(0,a.yg)("inlineCode",{parentName:"a"},"implements"))),(0,a.yg)("li",{parentName:"ul"},(0,a.yg)("a",{parentName:"li",href:"#typescript-classes---relationship-between-class-types"},"TypeScript Classes - Relationship Between Class Types")),(0,a.yg)("li",{parentName:"ul"},(0,a.yg)("a",{parentName:"li",href:"#typescript-vs-javascript-classes-feature-comparison"},"TypeScript vs JavaScript Classes: Feature Comparison"))),(0,a.yg)("h2",{parentName:"admonition",id:"overview"},"Overview"),(0,a.yg)("p",{parentName:"admonition"},"In this post, we focus on the essentials of class based programming in TypeScript using a simple ",(0,a.yg)("inlineCode",{parentName:"p"},"User")," class. We begin with how type annotations are applied to different class members and their parameters."),(0,a.yg)("p",{parentName:"admonition"},"We first consider typing class fields and delve into details of their initialization options, particularly investigating ",(0,a.yg)("em",{parentName:"p"},"definite initialization")," with the bang ",(0,a.yg)("inlineCode",{parentName:"p"},"!")," operator and strict initialization with the ",(0,a.yg)("inlineCode",{parentName:"p"},"--strictPropertyInitialization")," flag."),(0,a.yg)("p",{parentName:"admonition"},"We then familiarize with how member visibility is implemented in TypeScript. Member visibility in TypeScript classes is largely related to effective usage of prototypal heritage in JavaScript. However, in this post, we don't cover inheritance in TypeScript classes: for brevity, we only consider privacy of fields for a simple uninherited class and its instances. We also touch base on static fields which acts the same as that in JavaScript."),(0,a.yg)("p",{parentName:"admonition"},"We elaborate on what ",(0,a.yg)("inlineCode",{parentName:"p"},"readonly")," fields are and how they are limited to be initialized at the top or re/assigned from a constructor function. We extensively cover typing a constructor function with examples from our uninherited ",(0,a.yg)("inlineCode",{parentName:"p"},"User")," class and relate that constructor parameters are typed similar to any TS function. We end up learning how parameter properties work inside a constructor. Moving forward, we also work our way through easy-to-pick examples of typing methods and accessors, along with their parameters."),(0,a.yg)("p",{parentName:"admonition"},"In the later half of this post, we zoom in on the way TypeScript mitigates errors related to the ",(0,a.yg)("inlineCode",{parentName:"p"},"this")," object. We expound on how arrow functions and the special TS ",(0,a.yg)("strong",{parentName:"p"},(0,a.yg)("inlineCode",{parentName:"strong"},"this")," parameter")," in non-arrow functions can be used for correctly setting a class method's ",(0,a.yg)("inlineCode",{parentName:"p"},"this")," object and also learn about some of their caveats."),(0,a.yg)("p",{parentName:"admonition"},"We also explore generic classes with passed in type parameters and see examples of how TypeScript facilitates class conformity to multiple interfaces with the ",(0,a.yg)("inlineCode",{parentName:"p"},"implements")," keyword."),(0,a.yg)("p",{parentName:"admonition"},"Towards the end, we briefly discuss the structural type system that TypeScript bases itself on. We observe with an example how instances of different but identically typed and subtype classes conform to a given class (or rather the type from it) and how a supertype cannot not conform to a subtype because of missing properties."),(0,a.yg)("p",{parentName:"admonition"},"Before we begin with type annotation examples, in the next section, let's first go through how to set up the environment for using TypeScript."),(0,a.yg)("h2",{parentName:"admonition",id:"typing-class-members-in-typescript"},"Typing Class Members in TypeScript"),(0,a.yg)("p",{parentName:"admonition"},"A TypeScript class commonly has type annotations for its members and where applicable, their parameters. In the following sections, one by one, we cover the details of typing TypeScript class fields, constructor functions, methods, accessors and their parameters."),(0,a.yg)("p",{parentName:"admonition"},"Let's start with typing fields."),(0,a.yg)("h3",{parentName:"admonition",id:"typing-fields-in-typescript"},"Typing Fields in TypeScript"),(0,a.yg)("p",{parentName:"admonition"},"Below is an unsophisticated example with a few fields for a ",(0,a.yg)("inlineCode",{parentName:"p"},"User")," class:"),(0,a.yg)("pre",{parentName:"admonition"},(0,a.yg)("code",{parentName:"pre",className:"language-ts"},'class User {\n  username = "randomString";\n  firstName: string;\n  lastName: string;\n  age!: number;\n}\n')),(0,a.yg)("p",{parentName:"admonition"},"As you can notice, typing a class field in TypeScript is done like typing a variable. For example, as the usual story goes, the type of ",(0,a.yg)("inlineCode",{parentName:"p"},"username")," is being inferred from its initializer type. With the rest of the properties, we are being explicit about the types for ",(0,a.yg)("inlineCode",{parentName:"p"},"firstName"),", ",(0,a.yg)("inlineCode",{parentName:"p"},"lastName")," and ",(0,a.yg)("inlineCode",{parentName:"p"},"age!"),"."),(0,a.yg)("br",null),(0,a.yg)("p",{parentName:"admonition"},(0,a.yg)("strong",{parentName:"p"},"TypeScript Classes - Field Initialization")),(0,a.yg)("p",{parentName:"admonition"},"TypeScript class syntax adds some particular options to field initializations. A field may be initialized at declaration, or remain uninitialized, or uninitialized but aimed to be initialized ",(0,a.yg)("strong",{parentName:"p"},"definitely")," at some point during runtime."),(0,a.yg)("p",{parentName:"admonition"},"For example, in the ",(0,a.yg)("inlineCode",{parentName:"p"},"User")," class, ",(0,a.yg)("inlineCode",{parentName:"p"},"username")," field is assigned a random string and the name fields are uninitialized. Notice the ",(0,a.yg)("inlineCode",{parentName:"p"},"age!")," field with a bang!"),(0,a.yg)("br",null),(0,a.yg)("p",{parentName:"admonition"},(0,a.yg)("strong",{parentName:"p"},"TypeScript Classes - Definite Field Assignments")),(0,a.yg)("p",{parentName:"admonition"},(0,a.yg)("inlineCode",{parentName:"p"},"age")," above is uninitialized but it is accompanied by a bang (",(0,a.yg)("inlineCode",{parentName:"p"},"!"),") operator which is called the ",(0,a.yg)("em",{parentName:"p"},"definite assignment assertion operator"),". It is used to indicate that leaving the field uninitialized is good enough to avoid TypeScript ",(0,a.yg)("strong",{parentName:"p"},"strict property initialization")," (see next section) error but it is expected to be definitely assigned a value with the specified type at some point."),(0,a.yg)("p",{parentName:"admonition"},"It is common to use definite assignments when fields are assigned to an instance by APIs from some external libraries:"),(0,a.yg)("pre",{parentName:"admonition"},(0,a.yg)("code",{parentName:"pre",className:"language-ts"},'const joe = new User();\n\n// Set joe\'s age externally\njoe.age = getUserInfoFromStatsBureau("someId")?.data?.age;\n')),(0,a.yg)("br",null),(0,a.yg)("p",{parentName:"admonition"},(0,a.yg)("strong",{parentName:"p"},"TypeScript Classes - Strict Field Initialization")),(0,a.yg)("p",{parentName:"admonition"},"The ",(0,a.yg)("inlineCode",{parentName:"p"},"--strictPropertyInitialization")," flag in TypeScript controls how strict field/property initialization should be. We can set the strictness of property initialization from the ",(0,a.yg)("inlineCode",{parentName:"p"},"tsconfig.json")," file using the following entry to ",(0,a.yg)("inlineCode",{parentName:"p"},"compilerOptions"),":"),(0,a.yg)("pre",{parentName:"admonition"},(0,a.yg)("code",{parentName:"pre",className:"language-json"},'// Inside tsconfig.json\n\n{\n  "compilerOptions": {\n    "strictPropertyInitialization": true\n  }\n}\n')),(0,a.yg)("p",{parentName:"admonition"},"In TypeScript Playground, you can activate strict property initialization first by visiting the ",(0,a.yg)("inlineCode",{parentName:"p"},"TS Config")," dropdown and then selecting ",(0,a.yg)("inlineCode",{parentName:"p"},"strictPropertyInitialization")," from the ",(0,a.yg)("inlineCode",{parentName:"p"},"Type Checking")," section."),(0,a.yg)("p",{parentName:"admonition"},"Setting ",(0,a.yg)("inlineCode",{parentName:"p"},'"strictPropertyInitialization": true')," necessitates all fields to either have an initializer, or they should be set in the constructor function, or they should be definitely assigned at a later point. Otherwise, TypeScript throws a ",(0,a.yg)("inlineCode",{parentName:"p"},"2564")," error:"),(0,a.yg)("pre",{parentName:"admonition"},(0,a.yg)("code",{parentName:"pre",className:"language-ts"},"// With --strictPropertyInitialization\n\nclass User {\n  // Initialized, so no error\n  username = \"randomString\";\n\n  // Assigned in constructor, so no error\n  private firstName: string;\n\n  // Not assigned in constructor\n  private lastName: string; // Property 'lastName' has no initializer and is not definitely assigned in the constructor.(2564)\n\n  // Removing bang (!) also throws 2564 error\n  protected age: number; // Property 'age' has no initializer and is not definitely assigned in the constructor.(2564)\n\n  constructor(firstName: string) {\n    this.firstName = firstName;\n  }\n}\n")),(0,a.yg)("p",{parentName:"admonition"},(0,a.yg)("strong",{parentName:"p"},"TypeScript Class Member / Field Visibility")),(0,a.yg)("p",{parentName:"admonition"},"TypeScript offers ",(0,a.yg)("inlineCode",{parentName:"p"},"public"),", ",(0,a.yg)("inlineCode",{parentName:"p"},"protected")," and ",(0,a.yg)("inlineCode",{parentName:"p"},"private")," visibility options for its members. These privacy options are different from how JavaScript implements member privacy in ES2022."),(0,a.yg)("p",{parentName:"admonition"},"Visibility in TypeScript classes is a general feature applicable to ",(0,a.yg)("strong",{parentName:"p"},"all members"),". We are covering it for fields, but the same principles apply to methods as well."),(0,a.yg)("p",{parentName:"admonition"},"Fields that are not designated any privacy are by default ",(0,a.yg)("inlineCode",{parentName:"p"},"public"),". We can access or set ",(0,a.yg)("inlineCode",{parentName:"p"},"public")," properties from an instance:"),(0,a.yg)("pre",{parentName:"admonition"},(0,a.yg)("code",{parentName:"pre",className:"language-ts"},'class User {\n  username = "randomString";\n  firstName: string;\n  lastName: string;\n  age!: number;\n}\n\nconst joe = new User();\njoe.username = "jos3ph";\njoe.firstName = "Joseph";\njoe.lastName = "Hiyden";\njoe.age = 63;\n\nconsole.log(joe.username); // "jos3ph"\nconsole.log(`${joe.firstName} ${joe.lastName}`); // "Joseph Hiyden"\nconsole.log(joe.age); // 63\n')),(0,a.yg)("p",{parentName:"admonition"},"We have to explicitly state when a field or any member should be ",(0,a.yg)("inlineCode",{parentName:"p"},"private")," or ",(0,a.yg)("inlineCode",{parentName:"p"},"protected"),". ",(0,a.yg)("inlineCode",{parentName:"p"},"private")," visibility restricts member access and assignment to within the class. ",(0,a.yg)("inlineCode",{parentName:"p"},"protected")," limits the member to be accessed and set from its subclasses as well. This means that we can't access or set ",(0,a.yg)("inlineCode",{parentName:"p"},"private")," or ",(0,a.yg)("inlineCode",{parentName:"p"},"protected")," fields from an instance. Attempting to do so, as shown in the series of log statements below, throws errors:"),(0,a.yg)("pre",{parentName:"admonition"},(0,a.yg)("code",{parentName:"pre",className:"language-ts"},"class User {\n  username = \"randomString\";\n  private firstName: string;\n  private lastName: string;\n  protected age!: number;\n}\n\nconst joe = new User();\njoe.username = \"jos3ph\";\njoe.firstName = \"Joseph\"; // Property 'firstName' is private and only accessible within class 'User'.(2341)\njoe.lastName = \"Hidden\"; // Property 'firstName' is private and only accessible within class 'User'.(2341)\njoe.age = 63; // Property 'age' is protected and only accessible within class 'User' and its subclasses.(2445)\n\nconsole.log(joe.username);\nconsole.log(`${joe.firstName} ${joe.lastName}`); // 2341 Errors\nconsole.log(joe.age); // 2445 Error\n")),(0,a.yg)("br",null),(0,a.yg)("p",{parentName:"admonition"},(0,a.yg)("strong",{parentName:"p"},"TypeScript Classes - Static Members / Fields")),(0,a.yg)("p",{parentName:"admonition"},"Just as in JavaScript, we set class members on TypeScript classes with the ",(0,a.yg)("inlineCode",{parentName:"p"},"static")," keyword. Let's introduce a static field ",(0,a.yg)("inlineCode",{parentName:"p"},"userType")," to our ",(0,a.yg)("inlineCode",{parentName:"p"},"User")," class:"),(0,a.yg)("pre",{parentName:"admonition"},(0,a.yg)("code",{parentName:"pre",className:"language-ts"},'class User {\n  public static userType: string = "Guest";\n\n  username = "randomString";\n  protected age!: number;\n}\n\nconsole.log(User.userType); // "Guest"\n')),(0,a.yg)("p",{parentName:"admonition"},"As it happens in JavaScript, static fields in TypeScript represent class properties. One thing to note is that while declaring static fields, we have to place privacy modifiers (",(0,a.yg)("inlineCode",{parentName:"p"},"public")," here, which we technically don't need, but just to make a point) ",(0,a.yg)("strong",{parentName:"p"},"before")," the ",(0,a.yg)("inlineCode",{parentName:"p"},"static")," keyword. Otherwise, TypeScript feels ",(0,a.yg)("em",{parentName:"p"},"uncomfortable"),":"),(0,a.yg)("pre",{parentName:"admonition"},(0,a.yg)("code",{parentName:"pre",className:"language-ts"},"'public' modifier must precede 'static' modifier.(1029)\n")),(0,a.yg)("p",{parentName:"admonition"},(0,a.yg)("strong",{parentName:"p"},"TypeScript Classes - ",(0,a.yg)("inlineCode",{parentName:"strong"},"readonly")," Fields")),(0,a.yg)("p",{parentName:"admonition"},"TypeScript allows fields to be ",(0,a.yg)("inlineCode",{parentName:"p"},"readonly"),". As it implies, ",(0,a.yg)("inlineCode",{parentName:"p"},"readonly")," fields tempt not be assigned from an instance, even with a setter. They are legal to be initialized at the top declaration and also assigned inside the constructor:"),(0,a.yg)("pre",{parentName:"admonition"},(0,a.yg)("code",{parentName:"pre",className:"language-ts"},'class User {\n  static userType: string = "Guest";\n\n  readonly _username: string = "randomString"; // No error at initialization\n  protected age!: number;\n\n  get username() {\n    return this._username;\n  }\n\n  set username(username: string) {\n    // Error while re/assignment from setter\n    this._username = username; // Cannot assign to \'_username\' because it is a read-only property.(2540)\n  }\n\n  constructor(username: string) {\n    this._username = username; // No error while assigned from constructor\n  }\n}\n\nconst dona = new User("trump");\n\n// Error while being assigned from instance property, but gets assigned at compilation\nconsole.log((dona._username = "trump_trippin")); // Cannot assign to \'_username\' because it is a read-only property.(2540)\n')),(0,a.yg)("h3",{parentName:"admonition",id:"typescript-classes---constructor-functions"},"TypeScript Classes - Constructor Functions"),(0,a.yg)("p",{parentName:"admonition"},"As you already have noticed above, just like in regular TS functions that take parameters, class constructor parameters also get annotated with their types. Below is a more common example:"),(0,a.yg)("pre",{parentName:"admonition"},(0,a.yg)("code",{parentName:"pre",className:"language-ts"},'class User {\n  username = "randomString";\n  private firstName: string;\n  private lastName: string;\n  protected age!: number;\n\n  constructor(firstName: string, lastName: string) {\n    this.firstName = firstName;\n    this.lastName = lastName;\n  }\n}\n')),(0,a.yg)("p",{parentName:"admonition"},"It is important to note that a constructor function in a TypeScript class does ",(0,a.yg)("strong",{parentName:"p"},"not")," take types as parameters. In other words, there is nothing like this:"),(0,a.yg)("pre",{parentName:"admonition"},(0,a.yg)("code",{parentName:"pre",className:"language-ts"},"class User {\n  // Constructor fn cannot accept type param\n  constructor<AbsurdTypeParam>() {}\n}\n")),(0,a.yg)("p",{parentName:"admonition"},"Instead, the class declaration itself takes type parameters. Type parameters passed to a class are useful for defining ",(0,a.yg)("strong",{parentName:"p"},"generic class types"),", since a class ends up creating its own type. We'll explore generic classes in a ",(0,a.yg)("a",{parentName:"p",href:"#typescript-generic-classes"},"later section"),"."),(0,a.yg)("br",null),(0,a.yg)("p",{parentName:"admonition"},(0,a.yg)("strong",{parentName:"p"},"TS Classes - Constructor Return Type")),(0,a.yg)("p",{parentName:"admonition"},"It should be also noted that we do ",(0,a.yg)("strong",{parentName:"p"},"not")," need to type the return value of a TypeScript class constructor. Because, it ",(0,a.yg)("strong",{parentName:"p"},"always")," returns the instance's type, which is the type created from the class."),(0,a.yg)("pre",{parentName:"admonition"},(0,a.yg)("code",{parentName:"pre",className:"language-ts"},'class User {\n  username = "randomString";\n  private firstName: string;\n  private lastName: string;\n  protected age!: number;\n\n  // Constructor\'s return type is the type of the class\' instance\n  constructor(firstName: string, lastName: string) {\n    // constructor User(firstName: string, lastName: string): User\n    this.firstName = firstName;\n    this.lastName = lastName;\n  }\n}\n\n// joe is of type User\nconst joe = new User("Joe", "Hiyden"); // joe: User\n')),(0,a.yg)("br",null),(0,a.yg)("p",{parentName:"admonition"},(0,a.yg)("strong",{parentName:"p"},"TypeScript Class Creates a Type")),(0,a.yg)("p",{parentName:"admonition"},"It should be pretty obvious that a TypeScript class creates a type from itself:"),(0,a.yg)("pre",{parentName:"admonition"},(0,a.yg)("code",{parentName:"pre",className:"language-ts"},'// joe is of type User\nconst joe = new User("Joe", "Hiyden"); // joe: User\n')),(0,a.yg)("p",{parentName:"admonition"},(0,a.yg)("strong",{parentName:"p"},"Typescript Classes - Parameter Properties")),(0,a.yg)("p",{parentName:"admonition"},"In TypeScript, we can turn a constructor parameter into a class property using ",(0,a.yg)("strong",{parentName:"p"},"parameter properties"),". The way to implement parameter properties is by designating field visibility modifiers (",(0,a.yg)("inlineCode",{parentName:"p"},"public"),", ",(0,a.yg)("inlineCode",{parentName:"p"},"private"),", ",(0,a.yg)("inlineCode",{parentName:"p"},"protected"),") and/or accessor modifiers (",(0,a.yg)("inlineCode",{parentName:"p"},"readonly"),") to respective constructor parameters, instead of declaring field definitions that we usually perform at the top:"),(0,a.yg)("pre",{parentName:"admonition"},(0,a.yg)("code",{parentName:"pre",className:"language-ts"},'class User {\n  username = "randomString";\n  protected age!: number;\n\n  // Use field modifiers to declare parameter properties in constructor\n  constructor(private firstName: string, private lastName: string) {\n    // No assignments inside constructor body needed\n  }\n\n  fullName() {\n    return `${this.firstName} ${this.lastName}`;\n  }\n}\n\nconst joe = new User("Joe", "Hiyden");\njoe.firstName; // Property \'firstName\' is private and only accessible within class \'User\'.(2341)\nconsole.log(joe.fullName()); // "Joe Hiyden"\n')),(0,a.yg)("p",{parentName:"admonition"},"Above, we have a reworked ",(0,a.yg)("inlineCode",{parentName:"p"},"User")," class where we no longer need to declare ",(0,a.yg)("inlineCode",{parentName:"p"},"firstName")," and ",(0,a.yg)("inlineCode",{parentName:"p"},"lastName")," as fields at the top. Notice closely that we also don't need to carry out respective field assignments inside the constructor body. This way, TypeScript neatly keeps our code compact."),(0,a.yg)("h3",{parentName:"admonition",id:"typescript-classes---typing-methods"},"TypeScript Classes - Typing Methods"),(0,a.yg)("p",{parentName:"admonition"},"Applying type annotations to class methods is easy and follow the same principles as other functions. We already have the example of ",(0,a.yg)("inlineCode",{parentName:"p"},"fullName()")," method above that has an inferred return type of ",(0,a.yg)("inlineCode",{parentName:"p"},"string"),". In the below code, ",(0,a.yg)("inlineCode",{parentName:"p"},"greetUserWith()")," is another method that has an explicit return type of ",(0,a.yg)("inlineCode",{parentName:"p"},"string"),". It is annotated a ",(0,a.yg)("inlineCode",{parentName:"p"},"string")," parameter as well:"),(0,a.yg)("pre",{parentName:"admonition"},(0,a.yg)("code",{parentName:"pre",className:"language-ts"},'class User {\n  username = "randomString";\n  protected age!: number;\n\n  constructor(private firstName: string, private lastName: string) {}\n\n  fullName() {\n    return `${this.firstName} ${this.lastName}`;\n  }\n\n  greetUserWith(greeting: string): string {\n    return `${greeting}, ${this.fullName()}`;\n  }\n}\n\nconst joe = new User("Joe", "Hiyden");\nconsole.log(joe.fullName()); // "Joe Hiyden"\nconsole.log(joe.greetUserWith("Hello")); // "Hello, Joe Hiyden"\n')),(0,a.yg)("h3",{parentName:"admonition",id:"typescript-classes---typing-accessors"},"TypeScript Classes - Typing Accessors"),(0,a.yg)("p",{parentName:"admonition"},"In a similar vein, we can annotate types for accessor function parameters. Let's see how to do that for our ",(0,a.yg)("inlineCode",{parentName:"p"},"protected")," ",(0,a.yg)("inlineCode",{parentName:"p"},"_age")," field:"),(0,a.yg)("pre",{parentName:"admonition"},(0,a.yg)("code",{parentName:"pre",className:"language-ts"},'class User {\n  username = "randomString";\n  protected _age!: number;\n\n  constructor(private firstName: string, private lastName: string) {}\n\n  get age(): number {\n    return this._age;\n  }\n\n  set age(age: number) {\n    this._age = age;\n  }\n}\n\nconst joe = new User("Joe", "Hiyden");\njoe.age = 20;\nconsole.log(joe.age); // 20\n')),(0,a.yg)("p",{parentName:"admonition"},"It is worth noting that although we can annotate a type for the return value of ",(0,a.yg)("inlineCode",{parentName:"p"},"get")," accessors, TypeScript complains if we assign a type for the return value of setters. Annotating a return type for setters is not allowed, so the following is invalid:"),(0,a.yg)("pre",{parentName:"admonition"},(0,a.yg)("code",{parentName:"pre",className:"language-ts"},"set age(age: number): number { // A 'set' accessor cannot have a return type annotation.(1095)\n    this._age = age;\n};\n")),(0,a.yg)("br",null),(0,a.yg)("p",{parentName:"admonition"},"There are a couple of quirks related to accessors typing in TypeScript. Let's consider them now."),(0,a.yg)("p",{parentName:"admonition"},(0,a.yg)("strong",{parentName:"p"},"TS Classes - Setter Parameter Type Inferred from Existing Getter Param Type")),(0,a.yg)("p",{parentName:"admonition"},"For example, the above ",(0,a.yg)("inlineCode",{parentName:"p"},"age()")," ",(0,a.yg)("strong",{parentName:"p"},"setter")," can have its parameter type omitted. That's because when a getter exists, the setter's type parameter is inferred from the ",(0,a.yg)("strong",{parentName:"p"},"return type")," of getter:"),(0,a.yg)("pre",{parentName:"admonition"},(0,a.yg)("code",{parentName:"pre",className:"language-ts"},'class User {\n  username = "randomString";\n  protected _age!: number;\n\n  constructor(private firstName: string, private lastName: string) {}\n\n  // Existing getter with `number` return type\n  get age(): number {\n    return this._age;\n  }\n\n  // Type of setter parameter inferred from return type of existing getter\n  set age(age) {\n    // (parameter) age: number\n    this._age = age;\n  }\n}\n\nconst joe = new User("Joe", "Hidin");\njoe.age = 20;\nconsole.log(joe.age); // 20\n')),(0,a.yg)("p",{parentName:"admonition"},(0,a.yg)("strong",{parentName:"p"},"TS Classes - Field With Only Getter is Set to ",(0,a.yg)("inlineCode",{parentName:"strong"},"readonly"))),(0,a.yg)("p",{parentName:"admonition"},"When we have only a ",(0,a.yg)("inlineCode",{parentName:"p"},"get"),"ter method, and no corresponding setter, the field is automatically set to ",(0,a.yg)("inlineCode",{parentName:"p"},"readonly"),":"),(0,a.yg)("pre",{parentName:"admonition"},(0,a.yg)("code",{parentName:"pre",className:"language-ts"},'class User {\n  username = "randomString";\n  protected _age!: number;\n\n  constructor(private firstName: string, private lastName: string) {}\n\n  get age(): number {\n    return this._age;\n  }\n}\n\nconst joe = new User("Just", "Kiddin");\n\n// Assignment gives error with read-only message\njoe.age = 20; // Cannot assign to \'age\' because it is a read-only property.(2540)\n')),(0,a.yg)("h2",{parentName:"admonition",id:"this-object-in-typescript-classes"},(0,a.yg)("inlineCode",{parentName:"h2"},"this")," Object in TypeScript Classes"),(0,a.yg)("p",{parentName:"admonition"},"In JavaScript, the ",(0,a.yg)("inlineCode",{parentName:"p"},"this")," object on which a method is called depends on the ",(0,a.yg)("strong",{parentName:"p"},"call site")," of the method. At runtime, the ",(0,a.yg)("inlineCode",{parentName:"p"},"this")," object can be one of the root causes of unpredictable outcomes of a method call. In this section, we consider how TypeScript has a couple of options for controlling the ",(0,a.yg)("inlineCode",{parentName:"p"},"this")," object predictably in order to produce more stable outcomes."),(0,a.yg)("h3",{parentName:"admonition",id:"typescript-classes---arrow-functions-for-permanently-attaching-this-object"},"TypeScript Classes - Arrow Functions for Permanently Attaching ",(0,a.yg)("inlineCode",{parentName:"h3"},"this")," Object"),(0,a.yg)("p",{parentName:"admonition"},"As with JavaScript, when we want to permanently attach a class instance to a method, we can use the arrow syntax to define our method. For example, a redefined ",(0,a.yg)("inlineCode",{parentName:"p"},"fullName()")," method with arrow syntax:"),(0,a.yg)("pre",{parentName:"admonition"},(0,a.yg)("code",{parentName:"pre",className:"language-ts"},'class User {\n  username = "randomString";\n  protected age!: number;\n\n  constructor(private firstName: string, private lastName: string) {}\n\n  // highlight-next-line\n  fullName = () => `${this.firstName} ${this.lastName}`;\n\n  greetUserWith(greeting: string) {\n    return `${greeting}, ${this.fullName()}`;\n  }\n}\n\nconst joe = new User("Joe\'s", "Kiddin");\nconsole.log(joe.fullName()); // "Joe\'s Kiddin"\n\n// Doesn\'t lose `this` context, because it is permanently bound to instance\nconst jfn = joe.fullName;\nconsole.log(jfn()); // "Joe\'s Kiddin"\n')),(0,a.yg)("p",{parentName:"admonition"},"As it happens in JavaScript, the arrow syntax permanently binds the ",(0,a.yg)("inlineCode",{parentName:"p"},"fullName")," method to the instance of class ",(0,a.yg)("inlineCode",{parentName:"p"},"User"),", ",(0,a.yg)("inlineCode",{parentName:"p"},"joe")," here. So, regardless of whether we invoke it directly on ",(0,a.yg)("inlineCode",{parentName:"p"},"joe")," or extract it and call it later on, the ",(0,a.yg)("inlineCode",{parentName:"p"},"this")," object remains ",(0,a.yg)("inlineCode",{parentName:"p"},"joe"),"."),(0,a.yg)("p",{parentName:"admonition"},"One of the caveats of using context binding with arrow syntax is that in a derived class of ",(0,a.yg)("inlineCode",{parentName:"p"},"User"),", we can't access ",(0,a.yg)("inlineCode",{parentName:"p"},"super.fullName()")," as arrow functions don't have a ",(0,a.yg)("inlineCode",{parentName:"p"},"prototype")," property."),(0,a.yg)("h3",{parentName:"admonition",id:"typescript-classes---context-binding-with-this-parameter"},"TypeScript Classes - Context Binding with ",(0,a.yg)("inlineCode",{parentName:"h3"},"this")," Parameter"),(0,a.yg)("p",{parentName:"admonition"},"Another way TypeScript helps handle method context binding is that it spares the ",(0,a.yg)("inlineCode",{parentName:"p"},"this")," object for the first parameter to every method or accessor. When we want to bind an instance of the class to the method, we can specify the instance as the ",(0,a.yg)("inlineCode",{parentName:"p"},"this")," parameter and type it as the class itself. Like this:"),(0,a.yg)("pre",{parentName:"admonition"},(0,a.yg)("code",{parentName:"pre",className:"language-ts"},"class User {\n  username = \"randomString\";\n  protected age!: number;\n\n  constructor(private firstName: string, private lastName: string) {}\n\n  // highlight-next-line\n  fullName(this: User) {\n    return `${this.firstName} ${this.lastName}`;\n  }\n\n  greetUserWith(greeting: string) {\n    return `${greeting}, ${this.fullName()}`;\n  }\n}\n\nconst joe = new User(\"Joe's\", \"Hidin\");\nconsole.log(joe.fullName()); // \"Joe's Hidin\"\n\n// Error when taken out of context\nconst jfn = joe.fullName;\nconsole.log(jfn()); // The 'this' context of type 'void' is not assignable to method's 'this' of type 'User'.(2684)\n")),(0,a.yg)("p",{parentName:"admonition"},"Context binding with the ",(0,a.yg)("inlineCode",{parentName:"p"},"this")," parameter is specifically useful when we are sure to use the method on an instance of the ",(0,a.yg)("inlineCode",{parentName:"p"},"User")," class, and without taking it out of context. An added advantage is that we can also call it from a derived class using ",(0,a.yg)("inlineCode",{parentName:"p"},"super"),"."),(0,a.yg)("p",{parentName:"admonition"},"The drawback, as we can see above, is that the method loses the instance as its ",(0,a.yg)("inlineCode",{parentName:"p"},"this")," when it is extracted out of context."),(0,a.yg)("h2",{parentName:"admonition",id:"faq"},"FAQ"),(0,a.yg)("p",{parentName:"admonition"},(0,a.yg)("strong",{parentName:"p"},"Q: How are TypeScript classes different from JavaScript classes?"),"\nTypeScript classes differ from the ES6 classes of plain JavaScript in that they enable type annotations, access modifiers, ",(0,a.yg)("inlineCode",{parentName:"p"},"readonly")," fields, parameter properties, generics, and multiple implementations of interfaces."),(0,a.yg)("p",{parentName:"admonition"},(0,a.yg)("strong",{parentName:"p"},"Q: Do classes in TypeScript have private fields?"),"\nYes, you can use modifiers such as ",(0,a.yg)("inlineCode",{parentName:"p"},"private")," or ",(0,a.yg)("inlineCode",{parentName:"p"},"protected")," for classes in TypeScript. It's another syntax compared to ",(0,a.yg)("inlineCode",{parentName:"p"},"#private")," syntax in JavaScript ES2022."),(0,a.yg)("p",{parentName:"admonition"},(0,a.yg)("strong",{parentName:"p"},"Q: What are the purposes of ",(0,a.yg)("inlineCode",{parentName:"strong"},"readonly")," fields in TypeScript?"),"\nThe ",(0,a.yg)("inlineCode",{parentName:"p"},"readonly")," fields are supposed to create immutable properties that can only be assigned during initialization or in the constructor."),(0,a.yg)("p",{parentName:"admonition"},(0,a.yg)("strong",{parentName:"p"},"Q: How does TypeScript bind this in classes?"),"\nTypeScript provides two means to deal with ",(0,a.yg)("inlineCode",{parentName:"p"},"this"),":"),(0,a.yg)("ol",{parentName:"admonition"},(0,a.yg)("li",{parentName:"ol"},"Use arrow functions for methods to permanently bind ",(0,a.yg)("inlineCode",{parentName:"li"},"this")," to the class instance."),(0,a.yg)("li",{parentName:"ol"},"Employing the special ",(0,a.yg)("inlineCode",{parentName:"li"},"this")," parameter for explicitly specifying the type of class instance.")),(0,a.yg)("p",{parentName:"admonition"},(0,a.yg)("strong",{parentName:"p"},"Q: Is it possible to implement multiple interfaces with classes in TypeScript?"),"\nYes, TypeScript allows you to implement multiple interfaces using the keyword implements."),(0,a.yg)("p",{parentName:"admonition"},(0,a.yg)("strong",{parentName:"p"},"Q: Can static members in TypeScript have type parameters?"),"\nNo, in TypeScript, static members cannot refer to class type parameters."),(0,a.yg)("p",{parentName:"admonition"},(0,a.yg)("strong",{parentName:"p"},"Q: What is the advantage of parameter properties in TypeScript?"),"\nParameter properties in C# allow you to declare and initialize the fields directly in constructor parameters, which reduces boilerplate code."),(0,a.yg)("h2",{parentName:"admonition",id:"typescript-generic-classes"},"TypeScript Generic Classes"),(0,a.yg)("p",{parentName:"admonition"},"As it does with other generic types, TypeScript allows us to declare generic classes by passing in type parameters at class declaration. The passed in type can then be used to annotate types for any member inside the class."),(0,a.yg)("pre",{parentName:"admonition"},(0,a.yg)("code",{parentName:"pre",className:"language-ts"},'class User<T> {\n  readonly userType: T;\n\n  username = "randomString";\n  protected age!: number;\n\n  constructor(userType: T) {\n    this.userType = userType;\n  }\n}\n\ntype UserTypes = "Guest" | "Authenticated" | "Admin";\n\nconst joe = new User<string>("Guest");\nconst dae = new User<UserTypes>("Authenticated");\nconst dan = new User<UserTypes>("Unknown"); // Argument of type \'"Unknown"\' is not assignable to parameter of type \'UserTypes\'.(2345)\n\nconsole.log(joe.userType); // "Guest"\nconsole.log(dae.userType); // "Authenticated"\n')),(0,a.yg)("p",{parentName:"admonition"},"It is, however, not legal to pass class type parameters to ",(0,a.yg)("inlineCode",{parentName:"p"},"static")," members:"),(0,a.yg)("pre",{parentName:"admonition"},(0,a.yg)("code",{parentName:"pre",className:"language-ts"},'class User<T> {\n  static readonly userType: T; // Static members cannot reference class type parameters.(2302)\n\n  username = "randomString";\n  protected age!: number;\n}\n')),(0,a.yg)("h2",{parentName:"admonition",id:"typescript-classes---multiple-interfaces-with-implements"},"TypeScript Classes - Multiple Interfaces with ",(0,a.yg)("inlineCode",{parentName:"h2"},"implements")),(0,a.yg)("p",{parentName:"admonition"},"It is possible for a TypeScript class to implement more than one interface. We use the ",(0,a.yg)("inlineCode",{parentName:"p"},"implements")," clause for this. Any interface that the class satisfies can be passed to ",(0,a.yg)("inlineCode",{parentName:"p"},"implements"),". For example, the following interfaces are all satisfied by the ",(0,a.yg)("inlineCode",{parentName:"p"},"User")," class:"),(0,a.yg)("pre",{parentName:"admonition"},(0,a.yg)("code",{parentName:"pre",className:"language-ts"},'interface Identifiable {\n  fullName(): string;\n}\n\ninterface Greetable {\n  greetUserWith(greeting: string): string;\n}\n\ninterface Updatable {\n  updateUsername(username: string): void;\n}\n\nclass User<T> implements Identifiable, Greetable, Updatable {\n  readonly userType: T;\n\n  username = "randomString";\n  protected age!: number;\n\n  constructor(\n    userType: T,\n    private firstName: string,\n    private lastName: string,\n  ) {\n    this.userType = userType;\n  }\n\n  fullName() {\n    return `${this.firstName} ${this.lastName}`;\n  }\n\n  greetUserWith(greeting: string) {\n    return `${greeting}, ${this.fullName()}`;\n  }\n\n  updateUsername(username: string) {\n    this.username = username;\n  }\n}\n\nconst joe = new User<string>("Guest", "Joe", "Hidden");\nconsole.log(joe.fullName()); // "Joe Hidden"\nconsole.log(joe.greetUserWith("Hello")); // "Hello, Joe Hidden"\n')),(0,a.yg)("p",{parentName:"admonition"},"TypeScript throws a ",(0,a.yg)("inlineCode",{parentName:"p"},"2420")," error when a given interface property is not satisfied by the class. For example, for a ",(0,a.yg)("inlineCode",{parentName:"p"},"Registerable")," interface, the ",(0,a.yg)("inlineCode",{parentName:"p"},"register")," method is not implemented by ",(0,a.yg)("inlineCode",{parentName:"p"},"User"),", so it does not satisfy the ",(0,a.yg)("inlineCode",{parentName:"p"},"Registerable")," interface:"),(0,a.yg)("pre",{parentName:"admonition"},(0,a.yg)("code",{parentName:"pre",className:"language-ts"},'interface Identifiable {\n  fullName(): string;\n}\n\ninterface Greetable {\n  greetUserWith(greeting: string): string;\n}\n\ninterface Updatable {\n  updateUsername(username: string): void;\n}\n\ninterface Registerable {\n  register(userId: string): void;\n}\n\n// Complains with 2420 error because `register()` method is missing in User\nclass User<T> implements Identifiable, Greetable, Updatable, Registerable {\n  //\n  readonly userType: T;\n\n  username = "randomString";\n  protected age!: number;\n\n  constructor(\n    userType: T,\n    private firstName: string,\n    private lastName: string,\n  ) {\n    this.userType = userType;\n  }\n\n  fullName() {\n    return `${this.firstName} ${this.lastName}`;\n  }\n\n  greetUserWith(greeting: string) {\n    return `${greeting}, ${this.fullName()}`;\n  }\n\n  updateUsername(username: string) {\n    this.username = username;\n  }\n}\n')),(0,a.yg)("h2",{parentName:"admonition",id:"typescript-classes---relationship-between-class-types"},"TypeScript Classes - Relationship Between Class Types"),(0,a.yg)("p",{parentName:"admonition"},"TypeScript has a structural type system. And in structural type systems, the shape of the class and their instances are enough to compare them."),(0,a.yg)("h3",{parentName:"admonition",id:"typescript-classes---classes-with-identical-shapes-are-type-compliant"},"TypeScript Classes - Classes with Identical Shapes are Type Compliant"),(0,a.yg)("p",{parentName:"admonition"},"If the shapes of two classes are identical, their types are compliant:"),(0,a.yg)("pre",{parentName:"admonition"},(0,a.yg)("code",{parentName:"pre",className:"language-ts"},'// With --strictPropertyInitialization set to false\n\nclass User {\n  username = "randomString";\n  firstName: string;\n  lastName: string;\n  age!: number;\n}\n\nclass Admin {\n  username = "randomString";\n  firstName: string;\n  lastName: string;\n  age!: number;\n}\n\n// No complains when we type instance of Admin with User and vice versa, because User and Admin are structurally identical\nconst joe: User = new Admin(); // joe: User\nconst dona: Admin = new User(); // joe: Admin\n')),(0,a.yg)("p",{parentName:"admonition"},"Here, we are able to type ",(0,a.yg)("inlineCode",{parentName:"p"},"joe"),": an instance of ",(0,a.yg)("inlineCode",{parentName:"p"},"Admin")," with ",(0,a.yg)("inlineCode",{parentName:"p"},"User"),", and ",(0,a.yg)("inlineCode",{parentName:"p"},"dona"),": an instance of ",(0,a.yg)("inlineCode",{parentName:"p"},"User")," with ",(0,a.yg)("inlineCode",{parentName:"p"},"Admin")," because the shapes of the two classes are the same."),(0,a.yg)("h3",{parentName:"admonition",id:"typescript-classes---subtyped-classes-are-type-compliant"},"TypeScript Classes - Subtyped Classes are Type Compliant"),(0,a.yg)("p",{parentName:"admonition"},"Similarly, subtyped classes that have partial but the same members with a supertype is compliant to the supertype:"),(0,a.yg)("pre",{parentName:"admonition"},(0,a.yg)("code",{parentName:"pre",className:"language-ts"},"class User {\n  username = \"randomString\";\n  firstName: string;\n  lastName: string;\n  age!: number;\n}\n\nclass Admin {\n  username = \"randomString\";\n  firstName: string;\n  lastName: string;\n  age!: number;\n  role: string = \"Admin\";\n}\n\n// No complains typing instance of Admin with User, because User is a subtype of Admin\nconst joe: User = new Admin(); // joe: User\n\n// This time around, we can't type instance of User with Admin, because missing property in supertype\nconst dae: Admin = new User(); // Property 'role' is missing in type 'User' but required in type 'Admin'.(2741)\n")),(0,a.yg)("p",{parentName:"admonition"},"In this example, ",(0,a.yg)("inlineCode",{parentName:"p"},"joe"),", is still compliant to ",(0,a.yg)("inlineCode",{parentName:"p"},"User")," because the ",(0,a.yg)("inlineCode",{parentName:"p"},"Admin")," has all the members of ",(0,a.yg)("inlineCode",{parentName:"p"},"User")," and an additional one. The opposite (",(0,a.yg)("inlineCode",{parentName:"p"},"dae: Admin"),") is not true though, because ",(0,a.yg)("inlineCode",{parentName:"p"},"User")," has the missing member ",(0,a.yg)("inlineCode",{parentName:"p"},"role")," that is present in ",(0,a.yg)("inlineCode",{parentName:"p"},"Admin"),"."),(0,a.yg)("h2",{parentName:"admonition",id:"typescript-vs-javascript-classes-feature-comparison"},"TypeScript vs JavaScript Classes: Feature Comparison"),(0,a.yg)("table",{parentName:"admonition"},(0,a.yg)("thead",{parentName:"table"},(0,a.yg)("tr",{parentName:"thead"},(0,a.yg)("th",{parentName:"tr",align:null},"Feature"),(0,a.yg)("th",{parentName:"tr",align:null},"TypeScript Classes"),(0,a.yg)("th",{parentName:"tr",align:null},"JavaScript ES6 Classes"))),(0,a.yg)("tbody",{parentName:"table"},(0,a.yg)("tr",{parentName:"tbody"},(0,a.yg)("td",{parentName:"tr",align:null},"Type Annotations"),(0,a.yg)("td",{parentName:"tr",align:null},"Yes (fields, methods, and parameters)"),(0,a.yg)("td",{parentName:"tr",align:null},"No")),(0,a.yg)("tr",{parentName:"tbody"},(0,a.yg)("td",{parentName:"tr",align:null},"Access Modifiers (",(0,a.yg)("inlineCode",{parentName:"td"},"private"),")"),(0,a.yg)("td",{parentName:"tr",align:null},"Yes (",(0,a.yg)("inlineCode",{parentName:"td"},"public"),", ",(0,a.yg)("inlineCode",{parentName:"td"},"private"),", ",(0,a.yg)("inlineCode",{parentName:"td"},"protected"),")"),(0,a.yg)("td",{parentName:"tr",align:null},"No")),(0,a.yg)("tr",{parentName:"tbody"},(0,a.yg)("td",{parentName:"tr",align:null},(0,a.yg)("inlineCode",{parentName:"td"},"readonly")," Fields"),(0,a.yg)("td",{parentName:"tr",align:null},"Yes"),(0,a.yg)("td",{parentName:"tr",align:null},"No")),(0,a.yg)("tr",{parentName:"tbody"},(0,a.yg)("td",{parentName:"tr",align:null},"Parameter Properties"),(0,a.yg)("td",{parentName:"tr",align:null},"Yes"),(0,a.yg)("td",{parentName:"tr",align:null},"No")),(0,a.yg)("tr",{parentName:"tbody"},(0,a.yg)("td",{parentName:"tr",align:null},(0,a.yg)("inlineCode",{parentName:"td"},"this")," Parameter for Methods"),(0,a.yg)("td",{parentName:"tr",align:null},"Yes"),(0,a.yg)("td",{parentName:"tr",align:null},"No")),(0,a.yg)("tr",{parentName:"tbody"},(0,a.yg)("td",{parentName:"tr",align:null},"Generics"),(0,a.yg)("td",{parentName:"tr",align:null},"Yes"),(0,a.yg)("td",{parentName:"tr",align:null},"No")),(0,a.yg)("tr",{parentName:"tbody"},(0,a.yg)("td",{parentName:"tr",align:null},"Multiple Interface Implementation"),(0,a.yg)("td",{parentName:"tr",align:null},"Yes (",(0,a.yg)("inlineCode",{parentName:"td"},"implements"),")"),(0,a.yg)("td",{parentName:"tr",align:null},"No")))),(0,a.yg)("h2",{parentName:"admonition",id:"best-practices-of-typescript-classes"},"Best Practices of TypeScript Classes"),(0,a.yg)("ul",{parentName:"admonition"},(0,a.yg)("li",{parentName:"ul"},(0,a.yg)("strong",{parentName:"li"},"Use Readonly Fields for Immutable Data"),": Use the ",(0,a.yg)("inlineCode",{parentName:"li"},"readonly")," modifier to ensure a field is never changed after it's initialized."),(0,a.yg)("li",{parentName:"ul"},(0,a.yg)("strong",{parentName:"li"},"Leverage Parameter Properties"),": Reduce boilerplate code by initializing and declaring fields in the constructor."),(0,a.yg)("li",{parentName:"ul"},(0,a.yg)("strong",{parentName:"li"},"Use Access Modifiers"),": Use access modifiers such as ",(0,a.yg)("inlineCode",{parentName:"li"},"private"),", ",(0,a.yg)("inlineCode",{parentName:"li"},"protected"),", and ",(0,a.yg)("inlineCode",{parentName:"li"},"public")," to protect class members and guarantee encapsulation."),(0,a.yg)("li",{parentName:"ul"},(0,a.yg)("strong",{parentName:"li"},"Avoid Overusing Static Members"),": Excessive use of static members can lead to tight coupling."),(0,a.yg)("li",{parentName:"ul"},(0,a.yg)("strong",{parentName:"li"},"Use Generics"),": Write more flexible, reusable classes using type parameters."),(0,a.yg)("li",{parentName:"ul"},(0,a.yg)("strong",{parentName:"li"},"Annotate Method Return Types"),": Specify the return types for methods to make the class behavior more explicit."),(0,a.yg)("li",{parentName:"ul"},(0,a.yg)("strong",{parentName:"li"},"Test ",(0,a.yg)("inlineCode",{parentName:"strong"},"this")," binding"),": Use arrow functions or the ",(0,a.yg)("inlineCode",{parentName:"li"},"this")," parameter to ensure the ",(0,a.yg)("inlineCode",{parentName:"li"},"this")," context is correctly bound to class instances.")),(0,a.yg)("h2",{parentName:"admonition",id:"summary"},"Summary"),(0,a.yg)("p",{parentName:"admonition"},"In this post, we have traversed a long way in our exploration of classes in TypeScript. We have covered the essentials of type annotation in TS classes. We began with how to type class fields, their initialization options and visibility modifiers. We touched on ",(0,a.yg)("inlineCode",{parentName:"p"},"static")," fields, and with an example covered the concept of ",(0,a.yg)("inlineCode",{parentName:"p"},"readonly")," fields that TypeScript implements. We have went through in depth how class constructor, method and accessor parameters, and their return values are annotated. We saw how ",(0,a.yg)("inlineCode",{parentName:"p"},"readonly")," properties can be assigned from a constructor function, and how to implement parameter properties."),(0,a.yg)("p",{parentName:"admonition"},"We also expounded on how arrow functions are used to bind a method permanently to an instance and discovered how the ",(0,a.yg)("inlineCode",{parentName:"p"},"this")," parameter in TypeScript methods allows us to bind an instance more selectively to its methods."),(0,a.yg)("p",{parentName:"admonition"},"Near the end, we learned about how a class should implement multiple interfaces with the ",(0,a.yg)("inlineCode",{parentName:"p"},"implement")," clause. We also explored how subtypes from classes are compliant to those from supertyped classes and and not the other way around because of TypeScript's structural typing system.")))}y.isMDXComponent=!0}}]);