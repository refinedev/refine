"use strict";(self.webpackChunkdocumentation=self.webpackChunkdocumentation||[]).push([[86465],{58860:(e,t,n)=>{n.d(t,{xA:()=>d,yg:()=>h});var a=n(37953);function i(e,t,n){return t in e?Object.defineProperty(e,t,{value:n,enumerable:!0,configurable:!0,writable:!0}):e[t]=n,e}function r(e,t){var n=Object.keys(e);if(Object.getOwnPropertySymbols){var a=Object.getOwnPropertySymbols(e);t&&(a=a.filter((function(t){return Object.getOwnPropertyDescriptor(e,t).enumerable}))),n.push.apply(n,a)}return n}function o(e){for(var t=1;t<arguments.length;t++){var n=null!=arguments[t]?arguments[t]:{};t%2?r(Object(n),!0).forEach((function(t){i(e,t,n[t])})):Object.getOwnPropertyDescriptors?Object.defineProperties(e,Object.getOwnPropertyDescriptors(n)):r(Object(n)).forEach((function(t){Object.defineProperty(e,t,Object.getOwnPropertyDescriptor(n,t))}))}return e}function s(e,t){if(null==e)return{};var n,a,i=function(e,t){if(null==e)return{};var n,a,i={},r=Object.keys(e);for(a=0;a<r.length;a++)n=r[a],t.indexOf(n)>=0||(i[n]=e[n]);return i}(e,t);if(Object.getOwnPropertySymbols){var r=Object.getOwnPropertySymbols(e);for(a=0;a<r.length;a++)n=r[a],t.indexOf(n)>=0||Object.prototype.propertyIsEnumerable.call(e,n)&&(i[n]=e[n])}return i}var l=a.createContext({}),p=function(e){var t=a.useContext(l),n=t;return e&&(n="function"==typeof e?e(t):o(o({},t),e)),n},d=function(e){var t=p(e.components);return a.createElement(l.Provider,{value:t},e.children)},m="mdxType",c={inlineCode:"code",wrapper:function(e){var t=e.children;return a.createElement(a.Fragment,{},t)}},g=a.forwardRef((function(e,t){var n=e.components,i=e.mdxType,r=e.originalType,l=e.parentName,d=s(e,["components","mdxType","originalType","parentName"]),m=p(n),g=i,h=m["".concat(l,".").concat(g)]||m[g]||c[g]||r;return n?a.createElement(h,o(o({ref:t},d),{},{components:n})):a.createElement(h,o({ref:t},d))}));function h(e,t){var n=arguments,i=t&&t.mdxType;if("string"==typeof e||i){var r=n.length,o=new Array(r);o[0]=g;var s={};for(var l in t)hasOwnProperty.call(t,l)&&(s[l]=t[l]);s.originalType=e,s[m]="string"==typeof e?e:i,o[1]=s;for(var p=2;p<r;p++)o[p]=n[p];return a.createElement.apply(null,o)}return a.createElement.apply(null,n)}g.displayName="MDXCreateElement"},61051:(e,t,n)=>{n.r(t),n.d(t,{assets:()=>d,contentTitle:()=>l,default:()=>y,frontMatter:()=>s,metadata:()=>p,toc:()=>m});n(37953);var a=n(58860);function i(e,t,n){return t in e?Object.defineProperty(e,t,{value:n,enumerable:!0,configurable:!0,writable:!0}):e[t]=n,e}function r(e,t){return t=null!=t?t:{},Object.getOwnPropertyDescriptors?Object.defineProperties(e,Object.getOwnPropertyDescriptors(t)):function(e,t){var n=Object.keys(e);if(Object.getOwnPropertySymbols){var a=Object.getOwnPropertySymbols(e);t&&(a=a.filter((function(t){return Object.getOwnPropertyDescriptor(e,t).enumerable}))),n.push.apply(n,a)}return n}(Object(t)).forEach((function(n){Object.defineProperty(e,n,Object.getOwnPropertyDescriptor(t,n))})),e}function o(e,t){if(null==e)return{};var n,a,i=function(e,t){if(null==e)return{};var n,a,i={},r=Object.keys(e);for(a=0;a<r.length;a++)n=r[a],t.indexOf(n)>=0||(i[n]=e[n]);return i}(e,t);if(Object.getOwnPropertySymbols){var r=Object.getOwnPropertySymbols(e);for(a=0;a<r.length;a++)n=r[a],t.indexOf(n)>=0||Object.prototype.propertyIsEnumerable.call(e,n)&&(i[n]=e[n])}return i}const s={title:"Working with Drizzle ORM and PostgreSQL in Next.js",description:"This post provides a conceptual overview of Drizzle essentials and demonstrates how to start a Next.js application with Drizzle and PostgreSQL.",slug:"drizzle-react",authors:"abdullah_numan",tags:["react"],image:"https://refine.ams3.cdn.digitaloceanspaces.com/blog/2024-10-31-drizzle/social-2.png",hide_table_of_contents:!1},l=void 0,p={permalink:"/blog/drizzle-react",source:"@site/blog/2024-10-31-drizzle.md",title:"Working with Drizzle ORM and PostgreSQL in Next.js",description:"This post provides a conceptual overview of Drizzle essentials and demonstrates how to start a Next.js application with Drizzle and PostgreSQL.",date:"2024-10-31T00:00:00.000Z",formattedDate:"October 31, 2024",tags:[{label:"react",permalink:"/blog/tags/react"}],readingTime:30.035,hasTruncateMarker:!1,authors:[{name:"Abdullah Numan",title:"Fullstack Developer",url:"https://github.com/anewman15/",imageURL:"https://github.com/anewman15.png",key:"abdullah_numan"}],frontMatter:{title:"Working with Drizzle ORM and PostgreSQL in Next.js",description:"This post provides a conceptual overview of Drizzle essentials and demonstrates how to start a Next.js application with Drizzle and PostgreSQL.",slug:"drizzle-react",authors:"abdullah_numan",tags:["react"],image:"https://refine.ams3.cdn.digitaloceanspaces.com/blog/2024-10-31-drizzle/social-2.png",hide_table_of_contents:!1},prevItem:{title:"How to Use JavaScript Array some",permalink:"/blog/javascript-some-method"},nextItem:{title:"Error Handling With try, catch and finally Blocks in JavaScript",permalink:"/blog/javascript-try-catch-finally"},relatedPosts:[{title:"Using SVGs in React",description:"Let's talk about React SVG and how it makes the process of adding and handling images on modern websites more versatile and fun.",permalink:"/blog/react-svg",formattedDate:"January 7, 2025",authors:[{name:"Chidume Nnamdi",title:"Software Engineer",url:"https://github.com/philipszdavido",imageURL:"https://github.com/philipszdavido.png",key:"chidume_nnamdi"}],readingTime:15.405,date:"2025-01-07T00:00:00.000Z"},{title:"How to use the useParams hook in React Router",description:"We'll discover how to access the parameters of the current route with the useParams hook in React Router.",permalink:"/blog/react-router-useparams",formattedDate:"December 12, 2024",authors:[{name:"Joseph Mawa",title:"Web Developer",url:"https://github.com/nibble0101",imageURL:"/img/generic-profile.png",key:"joseph_mawa"}],readingTime:6.45,date:"2024-12-12T00:00:00.000Z"},{title:"Svelte vs React Comparison",description:"We will compare the optimal performance of React and Svelte",permalink:"/blog/svelte-vs-react",formattedDate:"December 8, 2022",authors:[{name:"Chidume Nnamdi",title:"Software Engineer",url:"https://github.com/philipszdavido",imageURL:"https://github.com/philipszdavido.png",key:"chidume_nnamdi"}],readingTime:9.225,date:"2022-12-08T00:00:00.000Z"}],authorPosts:[{title:"Memoization in React - How useCallback Works",description:"Improve app performance with React useCallback() hook.",permalink:"/blog/react-usecallback-guide",formattedDate:"September 26, 2024",authors:[{name:"Abdullah Numan",title:"Fullstack Developer",url:"https://github.com/anewman15/",imageURL:"https://github.com/anewman15.png",key:"abdullah_numan"}],readingTime:12.895,date:"2024-09-26T00:00:00.000Z"},{title:"How to use TypeScript Partial Type?",description:"We'll explain the TypeScript Partial utility type with examples",permalink:"/blog/typescript-partial-utility-type",formattedDate:"December 18, 2024",authors:[{name:"Abdullah Numan",title:"Fullstack Developer",url:"https://github.com/anewman15/",imageURL:"https://github.com/anewman15.png",key:"abdullah_numan"}],readingTime:5.25,date:"2024-12-18T00:00:00.000Z"},{title:"A Quick Introduction to Meta's Stylex",description:"This post quickly explores how to apply statically typed, atomic CSS styles to React components with Stylex APIs in a Next.js application.",permalink:"/blog/meta-stylex",formattedDate:"September 16, 2024",authors:[{name:"Abdullah Numan",title:"Fullstack Developer",url:"https://github.com/anewman15/",imageURL:"https://github.com/anewman15.png",key:"abdullah_numan"}],readingTime:16.035,date:"2024-09-16T00:00:00.000Z"}]},d={authorsImageUrls:[void 0]},m=[{value:"Introduction",id:"introduction",level:2},{value:"What is Drizzle ORM ?",id:"what-is-drizzle-orm-",level:2},{value:"Drizle ORM: The Core and Opt-in Packages",id:"drizle-orm-the-core-and-opt-in-packages",level:3},{value:"Why Drizzle is Special ?",id:"why-drizzle-is-special-",level:3},{value:"How Drizzle ORM Works",id:"how-drizzle-orm-works",level:3},{value:"Drizzle ORM: Essential Concepts and Features",id:"drizzle-orm-essential-concepts-and-features",level:2},{value:"Drizzle Feels Like SQL: Querying with <code>select()</code> and Relational APIs",id:"drizzle-feels-like-sql-querying-with-select-and-relational-apis",level:3},{value:"Drizzle ORM: Partial <code>select()</code>",id:"drizzle-orm-partial-select",level:4},{value:"SQL Filtering with Drizzle ORM <code>where()</code>",id:"sql-filtering-with-drizzle-orm-where",level:4},{value:"Drizzle ORM: <code>limit()</code>, <code>offset()</code> and <code>orderBy()</code>",id:"drizzle-orm-limit-offset-and-orderby",level:4},{value:"Aggregating Drizzle Data with <code>groupBy()</code>",id:"aggregating-drizzle-data-with-groupby",level:4},{value:"Joins in Drizzle ORM",id:"joins-in-drizzle-orm",level:4},{value:"Drizzle Queries for Convenient Relational Data",id:"drizzle-queries-for-convenient-relational-data",level:3},{value:"Mutations in Drizzle ORM",id:"mutations-in-drizzle-orm",level:3},{value:"Drizzle ORM: Inserting Rows",id:"drizzle-orm-inserting-rows",level:4},{value:"Drizzle ORM: Updating Rows with <code>db.update()</code>",id:"drizzle-orm-updating-rows-with-dbupdate",level:4},{value:"Drizzle ORM: SQL-like Delete Operation with <code>delete()</code>",id:"drizzle-orm-sql-like-delete-operation-with-delete",level:4},{value:"Schemas and Migrations in Drizzle ORM",id:"schemas-and-migrations-in-drizzle-orm",level:3},{value:"Understanding Schemas in Drizzle ORM",id:"understanding-schemas-in-drizzle-orm",level:4},{value:"Drizzle Column Types",id:"drizzle-column-types",level:4},{value:"Drizle Schemas: Indexes and Constraints",id:"drizle-schemas-indexes-and-constraints",level:4},{value:"Drizzle ORM: Entity Relations in a Drizzle Schema",id:"drizzle-orm-entity-relations-in-a-drizzle-schema",level:4},{value:"Drizzle Schemas: Generating TypeScript Entity Types",id:"drizzle-schemas-generating-typescript-entity-types",level:4},{value:"Drizzle with React Server Components: A Next.js Example",id:"drizzle-with-react-server-components-a-nextjs-example",level:2},{value:"Pre-requisites",id:"pre-requisites",level:3},{value:"Setting Up Drizzle ORM in A Next.js App",id:"setting-up-drizzle-orm-in-a-nextjs-app",level:3},{value:"Drizzle with Next.js: Starter Files",id:"drizzle-with-nextjs-starter-files",level:4},{value:"Getting a Local PostgreSQL Server Running",id:"getting-a-local-postgresql-server-running",level:4},{value:"Installing Drizzle ORM and Related Packages",id:"installing-drizzle-orm-and-related-packages",level:4},{value:"Configuring Drizzle with <code>drizzle.config.ts</code>",id:"configuring-drizzle-with-drizzleconfigts",level:4},{value:"Defining Drizzle Schemas, Entity Relations and Types",id:"defining-drizzle-schemas-entity-relations-and-types",level:4},{value:"Creating a PostgreSQL Client for Drizzle",id:"creating-a-postgresql-client-for-drizzle",level:4},{value:"Drizzle ORM: Generating Migration Files, Running Migrations and Seeding",id:"drizzle-orm-generating-migration-files-running-migrations-and-seeding",level:4},{value:"Extras: Performing Drizzle Operations from Next.js Server Components",id:"extras-performing-drizzle-operations-from-nextjs-server-components",level:3},{value:"Drizzle ORM with Next.js: Keep Queries in Default Server Rendered Pages",id:"drizzle-orm-with-nextjs-keep-queries-in-default-server-rendered-pages",level:4},{value:"Drizzle ORM and Next.js: Make Forms Render Client Side",id:"drizzle-orm-and-nextjs-make-forms-render-client-side",level:4},{value:"Drizzle ORM with Next.js: Move Mutation Actions Explicitly to Server Side",id:"drizzle-orm-with-nextjs-move-mutation-actions-explicitly-to-server-side",level:4},{value:"Next Steps",id:"next-steps",level:2}],c=(g="CreatePostForm",function(e){return console.warn("Component "+g+" was not imported, exported, or provided by MDXProvider as global scope"),(0,a.yg)("div",e)});var g;const h={toc:m},u="wrapper";function y(e){var{components:t}=e,n=o(e,["components"]);return(0,a.yg)(u,r(function(e){for(var t=1;t<arguments.length;t++){var n=null!=arguments[t]?arguments[t]:{},a=Object.keys(n);"function"==typeof Object.getOwnPropertySymbols&&(a=a.concat(Object.getOwnPropertySymbols(n).filter((function(e){return Object.getOwnPropertyDescriptor(n,e).enumerable})))),a.forEach((function(t){i(e,t,n[t])}))}return e}({},h,n),{components:t,mdxType:"MDXLayout"}),(0,a.yg)("h2",{id:"introduction"},"Introduction"),(0,a.yg)("p",null,(0,a.yg)("a",{parentName:"p",href:"https://orm.drizzle.team/docs/overview"},"Drizzle")," is a TypeScript based headless ORM that offers familiar database APIs that mirror native SQL and relational vocabulary. As such, Drizzle gives developers the ability to conveniently compose self-consistently type-safe database schemas, queries and mutations using their existing knowledge of relational SQL -- all within TS."),(0,a.yg)("p",null,"In this post, we get a highlight of the most essential APIs of Drizzle that makes it feel SQL-like. We first cover how querying is emulated with the ",(0,a.yg)("inlineCode",{parentName:"p"},"db.select()")," method and associated SQL-like helpers for filtering, joining and aggregating data. We particularly focus on the ",(0,a.yg)("a",{parentName:"p",href:"https://orm.drizzle.team/docs/rqb"},"Drizzle Querying APIs")," with ",(0,a.yg)("inlineCode",{parentName:"p"},"db.query"),", which comes from a more convenient wrapper around the ",(0,a.yg)("inlineCode",{parentName:"p"},"select()")," method suited for web applications. We also explore the SQL acquaintance offered by Drizzle mutation APIs for performing operations such as ",(0,a.yg)("inlineCode",{parentName:"p"},"db.insert()"),", ",(0,a.yg)("inlineCode",{parentName:"p"},"db.update()"),", ",(0,a.yg)("inlineCode",{parentName:"p"},"db.delete()"),"."),(0,a.yg)("p",null,"We discuss Drizzle the ways schemas lay the foundations of database migrations and tables created thereof. We explain with necessary snippets from PosgreSQL examples the fundamentals of how schemas in Drizzle act as source of truth for a multitude of backend and frontend features: including database entity definitions, migration file generation, migrating tables, defining entity relations and generating TypeScript types for both backend and frontend validations. We also relate to how Drizzle supports a myriad of SQL databases, including PostgreSQL, MySQL and SQLite along with backend services built on them."),(0,a.yg)("p",null,"In the later part of the post, we demonstrate how to configure Drizzle, set up Postgres schemas, and use Drizzle Queries and mutations for a simple blog app in Next.js using Postgres and React Server Components."),(0,a.yg)("h2",{id:"what-is-drizzle-orm-"},"What is Drizzle ORM ?"),(0,a.yg)("p",null,"Drizzle ORM is a TypeScript based data framework that maps database entities to programmable objects via Object Relational Mapping. ORMs like Drizzle help connect to a database server and execute queries and operations via object based APIs. In a JavaScript / TypeScript ORM, each type of database entity is represented by a JS/TS prototype. Tables are generated for each prototype, columns are represented by fields and attributes, while rows are created for each instance of the prototypes."),(0,a.yg)("h3",{id:"drizle-orm-the-core-and-opt-in-packages"},"Drizle ORM: The Core and Opt-in Packages"),(0,a.yg)("p",null,"Drizzle ORM consists of the core ",(0,a.yg)("inlineCode",{parentName:"p"},"drizzle-orm")," package, which is considered the headless part. The core supports different SQL databases, such as PostgreSQL, MySQL, SQLite alongside their different modes. For example, for our demo application in this post, we'll make use of the ",(0,a.yg)("inlineCode",{parentName:"p"},"drizzle-orm/pg-core")," subpackage to connect to an externally running PostgreSQL database."),(0,a.yg)("p",null,"Then there are opt-in packages for different kinds of adapters for these databases and backend services built from them. For example, for Postgres, we can use the ",(0,a.yg)("inlineCode",{parentName:"p"},"drizzle-orm/node-postgres")," driver to run Postgres connection in a Node.js environment. Other drivers supported by Drizzle include PostgresJS, Neon, Supabase, etc. Similar driver support exists for MySQL and SQLite. You can find the lists of dialects and drivers supported by Drizzle ",(0,a.yg)("a",{parentName:"p",href:"https://orm.drizzle.team/docs/get-started-postgresql"},"here"),"."),(0,a.yg)("p",null,"In addition to driver adapters, Drizzle enhances HTTP request data validations in the frontend and backend with its support for ",(0,a.yg)("a",{parentName:"p",href:"https://zod.dev/?id=introduction"},"Zod")," in the ",(0,a.yg)("a",{parentName:"p",href:"https://zod.dev/?id=introduction"},(0,a.yg)("inlineCode",{parentName:"a"},"drizzle-zod")," package"),"."),(0,a.yg)("h3",{id:"why-drizzle-is-special-"},"Why Drizzle is Special ?"),(0,a.yg)("p",null,"Drizzle stands out from other ORMs because of its extensive API coverage that mirrors SQL and relational vocabulary that already exists in databases. So, any database developer feels comfortable with the familiar database prototype methods and helpers provided by Drizzle."),(0,a.yg)("p",null,"In addition, Drizzle provides easy generation of TypeScript types for database entities thanks to schema based database configuration at its root. That way, entity types in Drizzle are available consistently for validations in both the back and the frontend."),(0,a.yg)("h3",{id:"how-drizzle-orm-works"},"How Drizzle ORM Works"),(0,a.yg)("p",null,"Drizzle ORM uses schemas to define database tables and generate their migration files. The schemas are defined according to the core dialect APIs. For example, the ",(0,a.yg)("inlineCode",{parentName:"p"},"drizzle-orm/pg-core")," subpackage provides us the ",(0,a.yg)("inlineCode",{parentName:"p"},"pgTable()")," function for defining database schemas for a Postgres database. There are respective core packages for MySQL and SQLite."),(0,a.yg)("p",null,"Drizzle must be configured in a backend or in a server rendered frontend application in order to place the generated migration files in an output folder. Other configurations include setting alias for source file paths, database connection ",(0,a.yg)("inlineCode",{parentName:"p"},"url"),", etc. The generated migration files are used to migrate the database tables. More on Drizzle configuration in this later ",(0,a.yg)("a",{parentName:"p",href:"#configuring-drizzle-with-drizzleconfigts"},"section"),"."),(0,a.yg)("admonition",{title:"Schema based configuration for easy migrations",type:"note"},(0,a.yg)("p",{parentName:"admonition"},"Drizzle's schema based entity and relations definitions make migrations easy by changing the root definitions anytime needed. Schema changes automatically produce appropriate migrations. This helps making changes to table columns easy to implement, without much harm to production data.")),(0,a.yg)("p",null,"Database connections, migration and sseeding are handled by Drizzle's opt-in driver adapters for chosen SQL dialects. For example, in this post, we are going to consider the ",(0,a.yg)("inlineCode",{parentName:"p"},"pg")," package and ",(0,a.yg)("inlineCode",{parentName:"p"},"drizzle-orm/node-postgres")," subpackage for connecting PostgreSQL to a Node.js runtime, performing table migrations, and performing data operations on them."),(0,a.yg)("p",null,"Drizzle can be used to serve backend APIs from a JavaScript-based runtime such as Node, Deno or serverless functions. The same Drizzle tools can be used in the frontend with any server rendered JS frontend framework such as Next.js, Svelte, etc."),(0,a.yg)("admonition",{title:"The Database Server Runs Independent of Drizzle",type:"tip"},(0,a.yg)("p",{parentName:"admonition"},"It is important to note that, the database server used with Drizzle must be created and run separately. Drizzle only needs a database ",(0,a.yg)("inlineCode",{parentName:"p"},"url")," from a database that's is already created, running, and waiting for connections.")),(0,a.yg)("h2",{id:"drizzle-orm-essential-concepts-and-features"},"Drizzle ORM: Essential Concepts and Features"),(0,a.yg)("p",null,"In this section, we highlight most of the Drizzle concepts and features essential for a web application, particularly with Next.js / React Server Components in mind. We discuss how Drizzle expressively implements querying with the ",(0,a.yg)("inlineCode",{parentName:"p"},"select()")," method and associated filtering, joining and aggregating helpers. We also drill into how Drizzle implements type-safe SQL schemas, with proper APIs for column types, indexing, constraints and relations."),(0,a.yg)("p",null,"Throughout the post, we pick snippets of working examples from ",(0,a.yg)("inlineCode",{parentName:"p"},"posts"),", ",(0,a.yg)("inlineCode",{parentName:"p"},"categories")," and ",(0,a.yg)("inlineCode",{parentName:"p"},"tops")," tables that we use in a demo application we set up in the end."),(0,a.yg)("p",null,"You can find an example schema definition in ",(0,a.yg)("a",{parentName:"p",href:"#understanding-schemas-in-drizzle-orm"},"this ",(0,a.yg)("inlineCode",{parentName:"a"},"posts")," schema that we discuss in this later section"),":"),(0,a.yg)("h3",{id:"drizzle-feels-like-sql-querying-with-select-and-relational-apis"},"Drizzle Feels Like SQL: Querying with ",(0,a.yg)("inlineCode",{parentName:"h3"},"select()")," and Relational APIs"),(0,a.yg)("p",null,"Drizzle provides us the ",(0,a.yg)("inlineCode",{parentName:"p"},"select()")," method on a ",(0,a.yg)("inlineCode",{parentName:"p"},"db")," connection instance. We can use it like the SQL ",(0,a.yg)("inlineCode",{parentName:"p"},"SELECT")," statement on a schema definition:"),(0,a.yg)("pre",null,(0,a.yg)("code",{parentName:"pre",className:"language-ts"},'import { db } from "@/drizzle/db";\nimport { posts } "@/drizzle/schema";\n\nconst postsList = db.select().from(posts);\n')),(0,a.yg)("p",null,"Both the ",(0,a.yg)("inlineCode",{parentName:"p"},"db")," and ",(0,a.yg)("inlineCode",{parentName:"p"},"posts")," schema are declarative. In other words, we have to declare and configure them beforehand. In this case, in the ",(0,a.yg)("inlineCode",{parentName:"p"},"@/drizzle/*")," directory. In ",(0,a.yg)("inlineCode",{parentName:"p"},"postsList"),", we are ",(0,a.yg)("inlineCode",{parentName:"p"},"select"),"ing all rows ",(0,a.yg)("inlineCode",{parentName:"p"},"from")," the ",(0,a.yg)("inlineCode",{parentName:"p"},"posts")," table: like in SQL by default, returning all columns."),(0,a.yg)("h4",{id:"drizzle-orm-partial-select"},"Drizzle ORM: Partial ",(0,a.yg)("inlineCode",{parentName:"h4"},"select()")),(0,a.yg)("p",null,"We can use partial select by passing a selection object to ",(0,a.yg)("inlineCode",{parentName:"p"},"select()")," that specify the columns of our interest:"),(0,a.yg)("pre",null,(0,a.yg)("code",{parentName:"pre",className:"language-ts"},"const postsTitles = await db\n  .select({\n    // highlight-start\n    id: posts.id,\n    title: posts.title,\n    // highlight-end\n  })\n  .from(posts);\n")),(0,a.yg)("p",null,"Notice, the selection object also needs to be declarative. In other words, it has to expressly declare column identifiers and their respective values using the schema (",(0,a.yg)("inlineCode",{parentName:"p"},"posts"),") fields, not just with the same column names."),(0,a.yg)("h4",{id:"sql-filtering-with-drizzle-orm-where"},"SQL Filtering with Drizzle ORM ",(0,a.yg)("inlineCode",{parentName:"h4"},"where()")),(0,a.yg)("p",null,"For filtering queries, Drizzle implements the SQL ",(0,a.yg)("inlineCode",{parentName:"p"},"WHERE")," clause with the ",(0,a.yg)("inlineCode",{parentName:"p"},"where()")," method. For example, as in the below snippet, by comparing a ",(0,a.yg)("inlineCode",{parentName:"p"},"createdAt")," timestamp, we can filter posts to get the ones created after a certain ",(0,a.yg)("inlineCode",{parentName:"p"},"d")," date:"),(0,a.yg)("pre",null,(0,a.yg)("code",{parentName:"pre",className:"language-ts"},'import { gte } from "drizzle/pg-core";\nimport { db } from "@/drizzle/db";\nimport { posts } "@/drizzle/schema";\n\nconst recentPosts = await db\n    .select()\n    .from(posts)\n    .where(gte(posts.publishedAt, d));\n')),(0,a.yg)("p",null,"We need to use the ",(0,a.yg)("inlineCode",{parentName:"p"},"where()")," method to invoke the SQL ",(0,a.yg)("inlineCode",{parentName:"p"},"WHERE")," clause. With ",(0,a.yg)("inlineCode",{parentName:"p"},"where()"),", we also need filtering helpers like ",(0,a.yg)("inlineCode",{parentName:"p"},"gte()")," for specifying query conditions and constraints. Drizzle has helper functions for all SQL filtering operations, including equal ",(0,a.yg)("inlineCode",{parentName:"p"},"eq()"),", not equal ",(0,a.yg)("inlineCode",{parentName:"p"},"ne()"),", greater than ",(0,a.yg)("inlineCode",{parentName:"p"},"gt()"),", and all those available in a given SQL dialect. You can see Drizzle's list of filter operators along with their docs ",(0,a.yg)("a",{parentName:"p",href:"https://orm.drizzle.team/docs/operators"},"here")),(0,a.yg)("admonition",{title:"Drizzle Filtering Helpers Are a passing",type:"warning"},(0,a.yg)("p",{parentName:"admonition"},"Honestly speaking, Drizzle filter helpers fail to uphold the SQL-like motivation. There are functions for all filtering operations, and although their namings sound the same, their functional implementation contribute to poor readability. Drizzle filters produce long and multiple lines of nested clumsy code, particularly when queries need multiple filters with ",(0,a.yg)("inlineCode",{parentName:"p"},"and()")," and ",(0,a.yg)("inlineCode",{parentName:"p"},"or()")," operators. For example, the following:"),(0,a.yg)("pre",{parentName:"admonition"},(0,a.yg)("code",{parentName:"pre",className:"language-ts"},"const postsList = db\n  .select()\n  .from(posts)\n  .where(and(gte(posts.publishedAt, d), lt(length(posts.content), 5000)));\n")),(0,a.yg)("p",{parentName:"admonition"},"Combining multiple filters in Drizzle is especially a pain in queries that ask for nested relational data, such as ",(0,a.yg)("inlineCode",{parentName:"p"},"categories")," along with the ",(0,a.yg)("inlineCode",{parentName:"p"},"posts"),".")),(0,a.yg)("h4",{id:"drizzle-orm-limit-offset-and-orderby"},"Drizzle ORM: ",(0,a.yg)("inlineCode",{parentName:"h4"},"limit()"),", ",(0,a.yg)("inlineCode",{parentName:"h4"},"offset()")," and ",(0,a.yg)("inlineCode",{parentName:"h4"},"orderBy()")),(0,a.yg)("p",null,"We have to chain the ",(0,a.yg)("inlineCode",{parentName:"p"},"limit()"),", ",(0,a.yg)("inlineCode",{parentName:"p"},"offset()")," and ",(0,a.yg)("inlineCode",{parentName:"p"},"orderBy()")," methods to ",(0,a.yg)("inlineCode",{parentName:"p"},"select()")," for respectively limiting, offsetting and ordering query results."),(0,a.yg)("p",null,"For example,"),(0,a.yg)("pre",null,(0,a.yg)("code",{parentName:"pre",className:"language-ts"},"const postsList = db\n  .select()\n  .from(posts)\n  .where(and(gte(posts.publishedAt, d), lt(length(posts.content), 5000)))\n  // highlight-start\n  .limit(10)\n  .offset(10)\n  .orderBy(asc(posts.title), desc(posts.publishedAt));\n// highlight-end\n")),(0,a.yg)("h4",{id:"aggregating-drizzle-data-with-groupby"},"Aggregating Drizzle Data with ",(0,a.yg)("inlineCode",{parentName:"h4"},"groupBy()")),(0,a.yg)("p",null,"Drizzle implements aggregating data with SQL ",(0,a.yg)("inlineCode",{parentName:"p"},"GROUP BY")," in the ",(0,a.yg)("inlineCode",{parentName:"p"},"groupBy()")," method. We can do aggregations like ",(0,a.yg)("inlineCode",{parentName:"p"},"count"),", ",(0,a.yg)("inlineCode",{parentName:"p"},"sum"),", ",(0,a.yg)("inlineCode",{parentName:"p"},"avg")," and so on. We can group aggregated data using ",(0,a.yg)("inlineCode",{parentName:"p"},"groupBy()")," and filter grouped data by ",(0,a.yg)("inlineCode",{parentName:"p"},"having()"),"."),(0,a.yg)("p",null,"Drizzle has complete SQL APIs for aggregation helpers. You can find the full list ",(0,a.yg)("a",{parentName:"p",href:"https://orm.drizzle.team/docs/select#aggregations"},"here"),"."),(0,a.yg)("h4",{id:"joins-in-drizzle-orm"},"Joins in Drizzle ORM"),(0,a.yg)("p",null,"Joins in Drizzle are supported for each individual SQL dialect. For PostgreSQL, Drizzle has ",(0,a.yg)("inlineCode",{parentName:"p"},"leftJoin()"),", ",(0,a.yg)("inlineCode",{parentName:"p"},"rightJoin()"),", ",(0,a.yg)("inlineCode",{parentName:"p"},"innerJoin()"),", ",(0,a.yg)("inlineCode",{parentName:"p"},"fullJoin()")," that represent respective SQL join types."),(0,a.yg)("p",null,"Feel free to check the ",(0,a.yg)("a",{parentName:"p",href:"https://orm.drizzle.team/docs/joins"},"Drizzle joins docs here"),"."),(0,a.yg)("h3",{id:"drizzle-queries-for-convenient-relational-data"},"Drizzle Queries for Convenient Relational Data"),(0,a.yg)("p",null,"Drizzle offers a convenient object oriented SQL-like querying API with ",(0,a.yg)("a",{parentName:"p",href:"https://orm.drizzle.team/docs/rqb"},"Drizzle Queries"),". Drizzle Queries is built on a ",(0,a.yg)("inlineCode",{parentName:"p"},"query")," wrapper which maps ",(0,a.yg)("inlineCode",{parentName:"p"},"select")," queries to an object prototype represented by a schema entity. For example, with Drizzle Queries, ",(0,a.yg)("inlineCode",{parentName:"p"},"db.query.posts")," produces an object mapping of the ",(0,a.yg)("inlineCode",{parentName:"p"},"posts")," table from a ",(0,a.yg)("inlineCode",{parentName:"p"},"posts")," schema."),(0,a.yg)("p",null,"The mapped object then gives us friendlier methods to query the ",(0,a.yg)("inlineCode",{parentName:"p"},"posts")," table with methods like ",(0,a.yg)("inlineCode",{parentName:"p"},"findMany()")," and ",(0,a.yg)("inlineCode",{parentName:"p"},"findFirst()"),". Drizzle Queries also supports relational navigation which gives easy single query access to related table data as nested objects. Below is an example that fetches all ",(0,a.yg)("inlineCode",{parentName:"p"},"categories")," each with their related ",(0,a.yg)("inlineCode",{parentName:"p"},"posts"),":"),(0,a.yg)("pre",null,(0,a.yg)("code",{parentName:"pre",className:"language-ts"},"const categoriesList = await db.query.categories.findMany({\n  with: {\n    posts: true,\n  },\n});\n")),(0,a.yg)("admonition",{title:"Drizzle Relations Are Configured in the Schema",type:"tip"},(0,a.yg)("p",{parentName:"admonition"},"It is important to make the distinction that Drizzle ORM is a TypeScript wrapper that invokes SQL commands from its SQL-like APIs. As such, the intended relations invoked during queries (such as ",(0,a.yg)("inlineCode",{parentName:"p"},"categories")," and ",(0,a.yg)("inlineCode",{parentName:"p"},"posts")," relation in the above example) do not get called automatically at the database server. Instead, we have to map the relations explicitly in the schema file with table relation definitions using the ",(0,a.yg)("inlineCode",{parentName:"p"},"relations()")," function. Only then, entity relations get mapped to the ",(0,a.yg)("inlineCode",{parentName:"p"},"db.query")," prototype."),(0,a.yg)("p",{parentName:"admonition"},"We get into the details of schemas and relations in this ",(0,a.yg)("a",{parentName:"p",href:"#defining-drizzle-schemas-entity-relations-and-types"},"later section"),".")),(0,a.yg)("h3",{id:"mutations-in-drizzle-orm"},"Mutations in Drizzle ORM"),(0,a.yg)("p",null,"Drizzle implements SQL mutations with ",(0,a.yg)("inlineCode",{parentName:"p"},"insert()"),", ",(0,a.yg)("inlineCode",{parentName:"p"},"update()")," and ",(0,a.yg)("inlineCode",{parentName:"p"},"delete()")," methods on the ",(0,a.yg)("inlineCode",{parentName:"p"},"db")," connection instance. These CUD actions are pretty intuitive as well."),(0,a.yg)("h4",{id:"drizzle-orm-inserting-rows"},"Drizzle ORM: Inserting Rows"),(0,a.yg)("p",null,"In order to insert a row, we need to pass the table schema to ",(0,a.yg)("inlineCode",{parentName:"p"},"insert()")," and item values to ",(0,a.yg)("inlineCode",{parentName:"p"},"values()")," chained to it. Like this:"),(0,a.yg)("pre",null,(0,a.yg)("code",{parentName:"pre",className:"language-ts"},'import { db } from "@/drizzle/db";\nimport { posts } "@/drizzle/schema";\n\nawait db.insert(posts)\n    .values({\n        title: "Post Title",\n        subtitle: "Post subtitle",\n        content: "Post content goes here",\n    });\n')),(0,a.yg)("p",null,"Again, notice that Drizzle's mutation methods reflects the syntax in SQL. Drizzle supports multiple item insertion with an array of objects passed to ",(0,a.yg)("inlineCode",{parentName:"p"},"values()"),". Also, we can return a response after insertion, with ",(0,a.yg)("inlineCode",{parentName:"p"},"returning()"),"."),(0,a.yg)("p",null,"For conflicting insert actions in PostgreSQL, such as when we attempt to ",(0,a.yg)("inlineCode",{parentName:"p"},"insert()")," values to an existing ",(0,a.yg)("inlineCode",{parentName:"p"},"id"),", we can configure desired steps with ",(0,a.yg)("a",{parentName:"p",href:"https://orm.drizzle.team/docs/insert#on-conflict-do-nothing"},(0,a.yg)("inlineCode",{parentName:"a"},"onConflictDoNothing()"))," or ",(0,a.yg)("a",{parentName:"p",href:"https://orm.drizzle.team/docs/insert#on-conflict-do-update"},(0,a.yg)("inlineCode",{parentName:"a"},"onConflictDoUpdate()"))," methods chained to the operation."),(0,a.yg)("h4",{id:"drizzle-orm-updating-rows-with-dbupdate"},"Drizzle ORM: Updating Rows with ",(0,a.yg)("inlineCode",{parentName:"h4"},"db.update()")),(0,a.yg)("p",null,"Similarly, Drizzle's ",(0,a.yg)("inlineCode",{parentName:"p"},"update()")," method is called on ",(0,a.yg)("inlineCode",{parentName:"p"},"db")," with a table schema, with the SQL-like ",(0,a.yg)("inlineCode",{parentName:"p"},"set()")," and ",(0,a.yg)("inlineCode",{parentName:"p"},"where()")," methods chained:"),(0,a.yg)("pre",null,(0,a.yg)("code",{parentName:"pre",className:"language-ts"},'import { db } from "@/drizzle/db";\nimport { posts } "@/drizzle/schema";\n\nawait db.update(posts)\n    .set({\n        subtitle: "New subtitle",\n    })\n    .where(eq(posts.id, 1));\n')),(0,a.yg)("p",null,"We can also update with ",(0,a.yg)("a",{parentName:"p",href:"https://orm.drizzle.team/docs/update#update-with-returning"},(0,a.yg)("inlineCode",{parentName:"a"},"returning()"))," chained to return a value after update."),(0,a.yg)("h4",{id:"drizzle-orm-sql-like-delete-operation-with-delete"},"Drizzle ORM: SQL-like Delete Operation with ",(0,a.yg)("inlineCode",{parentName:"h4"},"delete()")),(0,a.yg)("p",null,"We can use the ",(0,a.yg)("inlineCode",{parentName:"p"},"delete()")," method on ",(0,a.yg)("inlineCode",{parentName:"p"},"db")," with a table schema passed in to delete all rows in the table:"),(0,a.yg)("pre",null,(0,a.yg)("code",{parentName:"pre",className:"language-ts"},'import { db } from "@/drizzle/db";\nimport { posts } from "@drizzle/schema";\n\nawait db.delete(posts);\n\nawait db.delete(posts).where(isNull(posts.content));\n\nconst deletedPosts = await db\n  .delete(posts)\n  .where(isNull(posts.content))\n  .returning({ id: posts.id });\n')),(0,a.yg)("p",null,"When we need to select a number of rows that we want, we can invoke the ",(0,a.yg)("inlineCode",{parentName:"p"},"where()")," clause with necessary conditions."),(0,a.yg)("p",null,"We can also return a value from a ",(0,a.yg)("inlineCode",{parentName:"p"},"delete()")," operation by chaining ",(0,a.yg)("inlineCode",{parentName:"p"},"returning()"),"."),(0,a.yg)("h3",{id:"schemas-and-migrations-in-drizzle-orm"},"Schemas and Migrations in Drizzle ORM"),(0,a.yg)("p",null,"Alright. In this section, we delve into Drizzle schemas, migration files, performing migrations and setting up necessary client connections. Let's first try to understand what Drizzle schemas encompass."),(0,a.yg)("h4",{id:"understanding-schemas-in-drizzle-orm"},"Understanding Schemas in Drizzle ORM"),(0,a.yg)("p",null,"Database schemas in Drizzle serve a multitude of roles. They are used for:"),(0,a.yg)("ul",null,(0,a.yg)("li",{parentName:"ul"},"defining database entities, their fields and column types."),(0,a.yg)("li",{parentName:"ul"},"producing migration files."),(0,a.yg)("li",{parentName:"ul"},"defining relations between tables."),(0,a.yg)("li",{parentName:"ul"},"produce TypeScript types for database entities.")),(0,a.yg)("admonition",{title:"Drizzle Schemas Act as Single Source of Truth",type:"tip"},(0,a.yg)("p",{parentName:"admonition"},"These features makes Drizzle schemas a single source of truth for comprehensively yet so easily managing table definitions, migrations, relations and TypeScript entity types. So, at any point when we consider we'd need to add/change a field, we can directly alter the schema accordingly. Upon invocation, Drizzle automatically produces necessary migrations imposed by the changes. And all TypeScript types are inferred according to the latest schema version.")),(0,a.yg)("p",null,"For PostgreSQL, Drizzle gives us ",(0,a.yg)("inlineCode",{parentName:"p"},"pgTable()")," function from the ",(0,a.yg)("inlineCode",{parentName:"p"},"drizzle-orm/pg-core")," package to define a table. A typical Drizzle schema has table definitions with properly typed columns, entity relations between tables and inferred TypeScript types with support packages for Zod. Like this elaborate one that has a ",(0,a.yg)("inlineCode",{parentName:"p"},"posts")," schema related to ",(0,a.yg)("inlineCode",{parentName:"p"},"categories"),":"),(0,a.yg)("pre",null,(0,a.yg)("code",{parentName:"pre",className:"language-ts",metastring:'title="@/drizzle/schema/posts.ts"',title:'"@/drizzle/schema/posts.ts"'},'import { relations } from "drizzle-orm";\nimport {\n  integer,\n  pgTable,\n  serial,\n  text,\n  timestamp,\n  varchar,\n} from "drizzle-orm/pg-core";\nimport { createInsertSchema, createSelectSchema } from "drizzle-zod";\nimport { categories } from "@/drizzle/schema";\nimport * as zod from "zod";\n\nexport const posts = pgTable("posts", {\n  id: serial("id").primaryKey().unique(),\n  title: varchar("title", { length: 255 }).notNull(),\n  subtitle: varchar("subtitle", { length: 500 }),\n  content: text("content").notNull(),\n  // highlight-next-line\n  categoryId: integer("category_id").references(() => categories.id, {\n    onDelete: "cascade",\n  }),\n\n  createdAt: timestamp("created_at", { mode: "string" }).notNull().defaultNow(),\n  updatedAt: timestamp("updated_at", { mode: "string" }).notNull().defaultNow(),\n});\n\nexport const postsRelations = relations(posts, ({ one }) => ({\n  category: one(categories, {\n    fields: [posts.categoryId],\n    references: [categories.id],\n  }),\n}));\n\nexport const PostSchema = createSelectSchema(posts);\nexport const NewPostSchema = createInsertSchema(posts).pick({\n  title: true,\n  subtitle: true,\n  content: true,\n  categoryId: true,\n});\n\nexport type TPost = zod.infer<typeof PostSchema>;\nexport type TNewPost = zod.infer<typeof NewPostSchema>;\n')),(0,a.yg)("p",null,"Notice, the property identifiers in the object passed to ",(0,a.yg)("inlineCode",{parentName:"p"},"pgTable()")," are separate from the actual database column names used inside the database. We have to set column names using SQL conventions (such as ",(0,a.yg)("inlineCode",{parentName:"p"},'"category_id"'),"), and map them explicitly to their Drizzle identifiers ( ",(0,a.yg)("inlineCode",{parentName:"p"},"categoryId")," ). This is because, Drizzle schemas are declarative, and no inference is made internally from the columns object entries. Also, we have to use (imported) individual schemas (such as ",(0,a.yg)("inlineCode",{parentName:"p"},"categories")," for ",(0,a.yg)("inlineCode",{parentName:"p"},"categories_d")," above) to explicitly declare referenced columns in order to establish relations at the database level."),(0,a.yg)("p",null,"It is common to store schemas inside a ",(0,a.yg)("inlineCode",{parentName:"p"},"@/drizzle/schema/")," directory or similar convenient folder, which we have to specify inside the ",(0,a.yg)("inlineCode",{parentName:"p"},"drizzle.config.ts")," file. All schemas inside this directory need to be available to Drizzle's runtime ",(0,a.yg)("inlineCode",{parentName:"p"},"drizzle()")," method for migrating or performing operations on the database server."),(0,a.yg)("admonition",{title:"Drizzle Schemas Can Be Split",type:"tip"},(0,a.yg)("p",{parentName:"admonition"},"We can set schema definitions in a single file. But for large scale applications, it is a good practice to split schemas into separate files for better management. In such a case, for setting up a connection, we can use all the schemas contained inside the ",(0,a.yg)("inlineCode",{parentName:"p"},"@/drizzle/schema/*")," folder at once by importing them all with:"),(0,a.yg)("pre",{parentName:"admonition"},(0,a.yg)("code",{parentName:"pre",className:"language-ts"},'import * as schema from "@/drizzle/schema";\n\n// highlight-next-line\nexport const db = drizzle(client, { schema }); // Use all schemas combined with `*`\n'))),(0,a.yg)("h4",{id:"drizzle-column-types"},"Drizzle Column Types"),(0,a.yg)("p",null,"Drizzle supports all column types of all SQL dialects. In our Postgres schemas, we have used ",(0,a.yg)("inlineCode",{parentName:"p"},"serial()"),", ",(0,a.yg)("inlineCode",{parentName:"p"},"varchar()"),", ",(0,a.yg)("inlineCode",{parentName:"p"},"text()"),", ",(0,a.yg)("inlineCode",{parentName:"p"},"timestamp()"),". Other common column types include ",(0,a.yg)("inlineCode",{parentName:"p"},"integer()"),", ",(0,a.yg)("inlineCode",{parentName:"p"},"smallint()"),", ",(0,a.yg)("inlineCode",{parentName:"p"},"bigint()"),", ",(0,a.yg)("inlineCode",{parentName:"p"},"boolean()"),", ",(0,a.yg)("inlineCode",{parentName:"p"},"json()"),", ",(0,a.yg)("inlineCode",{parentName:"p"},"jsonb()"),", etc."),(0,a.yg)("p",null,"You can find a complete list of Drizzle column types in the ",(0,a.yg)("a",{parentName:"p",href:"https://orm.drizzle.team/docs/column-types/pg"},"docs here"),"."),(0,a.yg)("h4",{id:"drizle-schemas-indexes-and-constraints"},"Drizle Schemas: Indexes and Constraints"),(0,a.yg)("p",null,"We can apply indexes and constraints to our column types, as in the above ",(0,a.yg)("inlineCode",{parentName:"p"},"posts")," schema."),(0,a.yg)("p",null,"We apply indexes with ",(0,a.yg)("inlineCode",{parentName:"p"},"index()")," and ",(0,a.yg)("inlineCode",{parentName:"p"},"uniqueIndex()")," function and then chaining ",(0,a.yg)("inlineCode",{parentName:"p"},"on()")," to specify the target table column."),(0,a.yg)("p",null,"Drizzle has complete SQL-like support for constraints. Common constraints are ",(0,a.yg)("inlineCode",{parentName:"p"},"default()"),", ",(0,a.yg)("inlineCode",{parentName:"p"},"notNull()")," and ",(0,a.yg)("inlineCode",{parentName:"p"},"unique()"),". The full list of Drizzle constraints is available in the ",(0,a.yg)("a",{parentName:"p",href:"https://orm.drizzle.team/docs/indexes-constraints"},"docs here"),"."),(0,a.yg)("h4",{id:"drizzle-orm-entity-relations-in-a-drizzle-schema"},"Drizzle ORM: Entity Relations in a Drizzle Schema"),(0,a.yg)("p",null,"Let's now focus on Drizzle's entity relations."),(0,a.yg)("p",null,"We have to use the ",(0,a.yg)("inlineCode",{parentName:"p"},"relations()")," function for declaring entity relations. Drizzle's relations are exhaustingly declarative. Setting foreign keys with ",(0,a.yg)("inlineCode",{parentName:"p"},"references()")," sets relations at the database level and does not establish relation navigation on TypeScript/JavaScript runtimes. So, we have to declare them separately, in both ways:"),(0,a.yg)("pre",null,(0,a.yg)("code",{parentName:"pre",className:"language-ts"},"// Inside `posts` schema\nexport const postsRelations = relations(posts, ({ one }) => ({\n  category: one(categories, {\n    fields: [posts.categoryId],\n    references: [categories.id],\n  }),\n}));\n\n// Inside `categories` schema\nexport const categoriesRelations = relations(categories, ({ many }) => ({\n  posts: many(posts),\n}));\n")),(0,a.yg)("h4",{id:"drizzle-schemas-generating-typescript-entity-types"},"Drizzle Schemas: Generating TypeScript Entity Types"),(0,a.yg)("p",null,"Perhaps the most standout feature of Drizzle schemas is the ability to generate TypeScript types from entity table definitions. Or using ",(0,a.yg)("inlineCode",{parentName:"p"},"zod.infer<>")," In Drizzle, we are able to derive Zod schemas from table definitions by passing the table definition to the ",(0,a.yg)("inlineCode",{parentName:"p"},"createInsertSchema()")," and ",(0,a.yg)("inlineCode",{parentName:"p"},"createSelectSchema()")," functions. We can then generate necessary type definitions using ",(0,a.yg)("inlineCode",{parentName:"p"},"zod.infer<>"),". For example the type definitions for ",(0,a.yg)("inlineCode",{parentName:"p"},"posts")," are derived like this:"),(0,a.yg)("pre",null,(0,a.yg)("code",{parentName:"pre",className:"language-ts"},"export const PostSchema = createSelectSchema(posts);\nexport const NewPostSchema = createInsertSchema(posts).pick({\n  title: true,\n  subtitle: true,\n  content: true,\n  categoryId: true,\n});\n\nexport type TPost = zod.infer<typeof PostSchema>;\nexport type TNewPost = zod.infer<typeof NewPostSchema>;\n")),(0,a.yg)("h2",{id:"drizzle-with-react-server-components-a-nextjs-example"},"Drizzle with React Server Components: A Next.js Example"),(0,a.yg)("p",null,"In this section, we go through the steps for making a Next.js project work with Drizzle ORM. We also proceed towards building a simple blog and some extras with rudimentary admin pages showing how Drizzle can be used for complex data fetching and management in Next.js Server Components."),(0,a.yg)("p",null,"You may want to explore the working code in the ",(0,a.yg)("inlineCode",{parentName:"p"},"drizzle")," branch of this repository for detailed insight. Feel free to add full fledged admin features with proper authentication and authorization."),(0,a.yg)("p",null,"Let's first see how to set up Drizzle ORM in a Next.js application."),(0,a.yg)("h3",{id:"pre-requisites"},"Pre-requisites"),(0,a.yg)("p",null,"For this app, we assume you're already familiar with how Next.js works with the app router. In particular you should be hands on with how to initialize a Next.js application with TypeScript. Since initialization is an easy step, we don't include it here."),(0,a.yg)("h3",{id:"setting-up-drizzle-orm-in-a-nextjs-app"},"Setting Up Drizzle ORM in A Next.js App"),(0,a.yg)("p",null,"For this part, we consider an already initialized app router Next.js application. We have the starter files in the ",(0,a.yg)("inlineCode",{parentName:"p"},"main")," branch of ",(0,a.yg)("a",{parentName:"p",href:"https://github.com/anewman15/drizzle-demo/tree/main"},"this repository"),"."),(0,a.yg)("h4",{id:"drizzle-with-nextjs-starter-files"},"Drizzle with Next.js: Starter Files"),(0,a.yg)("p",null,"We suggest you clone the repository ",(0,a.yg)("a",{parentName:"p",href:"https://github.com/anewman15/drizzle-demo"},"here")," in a folder of your choice, and the follow these steps:"),(0,a.yg)("ol",null,(0,a.yg)("li",{parentName:"ol"},"Open the ",(0,a.yg)("inlineCode",{parentName:"li"},"drizzle-demo")," starter app in your code editor.\nThe starter code has a Next.js app router configured, ",(0,a.yg)("a",{parentName:"li",href:"https://tailwindcss.com/docs/installation"},"TailwindCSS"),", ",(0,a.yg)("a",{parentName:"li",href:"https://daisyui.com/docs/install/"},"DaisyUI"),", ",(0,a.yg)("a",{parentName:"li",href:"https://heroicons.com/"},"Heroicons")," and ",(0,a.yg)("a",{parentName:"li",href:"https://date-fns.org/docs/Getting-Started"},(0,a.yg)("inlineCode",{parentName:"a"},"date-fns"))," added to ",(0,a.yg)("inlineCode",{parentName:"li"},"package.json"),"."),(0,a.yg)("li",{parentName:"ol"},"Install all packages:")),(0,a.yg)("pre",null,(0,a.yg)("code",{parentName:"pre",className:"language-bash"},"npm i\n")),(0,a.yg)("ol",{start:3},(0,a.yg)("li",{parentName:"ol"},"Run the Next.js server:")),(0,a.yg)("pre",null,(0,a.yg)("code",{parentName:"pre",className:"language-bash"},"npm run dev\n")),(0,a.yg)("p",null,"You should have the starter app running on ",(0,a.yg)("inlineCode",{parentName:"p"},"http://localhost:3000"),". We can then proceed to start a local instance of PostgreSQL server."),(0,a.yg)("h4",{id:"getting-a-local-postgresql-server-running"},"Getting a Local PostgreSQL Server Running"),(0,a.yg)("p",null,"For this demo, we are using PostgreSQL with Drizzle. We assume you are already hands on with getting a local Postgres instance running. If not, please follow this ",(0,a.yg)("a",{parentName:"p",href:"https://www.youtube.com/watch?v=KuQUNHCeKCk"},"Youtube tutorial")," to have a Postgres database named ",(0,a.yg)("inlineCode",{parentName:"p"},"drizzle_demo")," up and running in your machine. We are going to need the database credentials for ",(0,a.yg)("inlineCode",{parentName:"p"},"drizzle_demo")," for interacting with Drizzle ORM from the Next.js app."),(0,a.yg)("h4",{id:"installing-drizzle-orm-and-related-packages"},"Installing Drizzle ORM and Related Packages"),(0,a.yg)("p",null,"In this application, we use APIs from Drizzle ORM PosgreSQL core, Drizzle's Node.js adapter for Postgres, the ",(0,a.yg)("inlineCode",{parentName:"p"},"pg")," package and Drizzle Kit for all Drizzle related stuff. ",(0,a.yg)("inlineCode",{parentName:"p"},"drizzle-orm")," contains the ",(0,a.yg)("inlineCode",{parentName:"p"},"pg-core")," and ",(0,a.yg)("inlineCode",{parentName:"p"},"node-postgres")," subpackages. So, inside the open ",(0,a.yg)("inlineCode",{parentName:"p"},"drizzle-demo")," Next.js app, add the following packages:"),(0,a.yg)("pre",null,(0,a.yg)("code",{parentName:"pre",className:"language-npm"},"npm i drizzle-orm pg\nnpm i -D drizzle-kit @types/pg\n")),(0,a.yg)("p",null,"Additionally, we use Zod with Drizzle. So, we also want ",(0,a.yg)("inlineCode",{parentName:"p"},"zod")," and ",(0,a.yg)("inlineCode",{parentName:"p"},"drizzle-zod")," packages. We also want ",(0,a.yg)("a",{parentName:"p",href:"https://www.react-hook-form.com/get-started"},"React Hook Form")," with Zod for our forms. So, we need ",(0,a.yg)("inlineCode",{parentName:"p"},"react-hook-form")," and ",(0,a.yg)("inlineCode",{parentName:"p"},"@hookform/resolvers"),". Let's add all as dependencies:"),(0,a.yg)("pre",null,(0,a.yg)("code",{parentName:"pre",className:"language-npm"},"npm i zod drizzle-zod react-hook-form @hookform/resolvers\n")),(0,a.yg)("p",null,"And finally, we need to run migrations with ",(0,a.yg)("inlineCode",{parentName:"p"},"tsx")," and ",(0,a.yg)("inlineCode",{parentName:"p"},"dotenv")," to store our environment variables:"),(0,a.yg)("pre",null,(0,a.yg)("code",{parentName:"pre",className:"language-npm"},"npm i tsx dotenv\n")),(0,a.yg)("p",null,"Okay, we have all the packages needed to get everything prepared with Drizzle."),(0,a.yg)("h4",{id:"configuring-drizzle-with-drizzleconfigts"},"Configuring Drizzle with ",(0,a.yg)("inlineCode",{parentName:"h4"},"drizzle.config.ts")),(0,a.yg)("p",null,"First things first, we need to configure Drizzle ORM in the ",(0,a.yg)("inlineCode",{parentName:"p"},"./drizzle.config.ts")," path. For this, we need the ",(0,a.yg)("inlineCode",{parentName:"p"},"defineConfig()")," function from ",(0,a.yg)("inlineCode",{parentName:"p"},"drizzle-kit"),". A typical configuration specifies the source ",(0,a.yg)("inlineCode",{parentName:"p"},"schema")," path and ",(0,a.yg)("inlineCode",{parentName:"p"},"out")," folder for putting generated migration files:"),(0,a.yg)("pre",null,(0,a.yg)("code",{parentName:"pre",className:"language-ts",metastring:'title="./drizzle.config.ts"',title:'"./drizzle.config.ts"'},'import "dotenv";\nimport { defineConfig } from "drizzle-kit";\n\nexport default defineConfig({\n  schema: "./src/drizzle/schema",\n  out: "./src/drizzle/migrations",\n  dialect: "postgresql",\n  dbCredentials: {\n    // highlight-next-line\n    url: `S{process.env.DB_URL}`,\n  },\n  verbose: true,\n  strict: true,\n});\n')),(0,a.yg)("p",null,(0,a.yg)("inlineCode",{parentName:"p"},'"./src/drizzle/schema"')," is where we manually define and store our schema files. We want Drizzle Kit's ",(0,a.yg)("inlineCode",{parentName:"p"},"npx drizzle-kit generate")," command to generate migration files and output them to ",(0,a.yg)("inlineCode",{parentName:"p"},'"./src/drizzle/migrations"'),". We can configure the output folder to be anywhere according to our choice."),(0,a.yg)("p",null,"Notice, we need to specify the ",(0,a.yg)("inlineCode",{parentName:"p"},"dialect"),". In our case, we are using ",(0,a.yg)("inlineCode",{parentName:"p"},"postgresql"),". The ",(0,a.yg)("inlineCode",{parentName:"p"},"url")," should evaluate to a Postgres database server URL, with this pattern: ",(0,a.yg)("inlineCode",{parentName:"p"},'"postgres://user:password@host:port/db"'),". It is best to store them in an ",(0,a.yg)("inlineCode",{parentName:"p"},".env")," file and import them using ",(0,a.yg)("inlineCode",{parentName:"p"},"dotenv"),"."),(0,a.yg)("h4",{id:"defining-drizzle-schemas-entity-relations-and-types"},"Defining Drizzle Schemas, Entity Relations and Types"),(0,a.yg)("p",null,"Once we have configured our ",(0,a.yg)("inlineCode",{parentName:"p"},"schema")," and ",(0,a.yg)("inlineCode",{parentName:"p"},"out")," paths, we need to define our schemas in the ",(0,a.yg)("inlineCode",{parentName:"p"},"schema")," folder. Schemas form the backbone of defining database tables. For our app, we have schemas for three tables: ",(0,a.yg)("inlineCode",{parentName:"p"},"posts"),", ",(0,a.yg)("inlineCode",{parentName:"p"},"categories")," and ",(0,a.yg)("inlineCode",{parentName:"p"},"tops"),". The ",(0,a.yg)("inlineCode",{parentName:"p"},"posts")," schema looks like this:"),(0,a.yg)("details",null,(0,a.yg)("summary",null,"Show Schema file for `posts`"),(0,a.yg)("pre",null,(0,a.yg)("code",{parentName:"pre",className:"language-ts",metastring:'title="./src/drizzle/schema/posts.ts"',title:'"./src/drizzle/schema/posts.ts"'},'import { relations } from "drizzle-orm";\nimport {\n  integer,\n  pgTable,\n  serial,\n  text,\n  timestamp,\n  varchar,\n} from "drizzle-orm/pg-core";\nimport { createInsertSchema, createSelectSchema } from "drizzle-zod";\nimport { categories } from "@/drizzle/schema";\nimport * as zod from "zod";\n\nexport const posts = pgTable("posts", {\n  id: serial("id").primaryKey().unique(),\n  title: varchar("title", { length: 255 }).notNull(),\n  subtitle: varchar("subtitle", { length: 500 }),\n  content: text("content").notNull(),\n  categoryId: integer("category_id").references(() => categories.id, {\n    onDelete: "cascade",\n  }),\n\n  createdAt: timestamp("created_at", { mode: "string" }).notNull().defaultNow(),\n  updatedAt: timestamp("updated_at", { mode: "string" }).notNull().defaultNow(),\n});\n\nexport const postsRelations = relations(posts, ({ one }) => ({\n  category: one(categories, {\n    fields: [posts.categoryId],\n    references: [categories.id],\n  }),\n}));\n\nexport const PostSchema = createSelectSchema(posts);\nexport const NewPostSchema = createInsertSchema(posts).pick({\n  title: true,\n  subtitle: true,\n  content: true,\n  categoryId: true,\n});\n\nexport type TPost = zod.infer<typeof PostSchema>;\nexport type TNewPost = zod.infer<typeof NewPostSchema>;\n'))),(0,a.yg)("p",null,"Notice, inside the ",(0,a.yg)("inlineCode",{parentName:"p"},"posts")," table, we are referencing ",(0,a.yg)("inlineCode",{parentName:"p"},"categoryId")," to ",(0,a.yg)("inlineCode",{parentName:"p"},"categories.id"),". This referencing is taking place at the database level. For navigating to and forth entity relations at the application level, we need to make Drizzle relations declarative with ",(0,a.yg)("inlineCode",{parentName:"p"},"relations()"),". So, we have used the schema file to define ",(0,a.yg)("inlineCode",{parentName:"p"},"posts")," relations with ",(0,a.yg)("inlineCode",{parentName:"p"},"categories")," in ",(0,a.yg)("inlineCode",{parentName:"p"},"postsRelations"),":"),(0,a.yg)("pre",null,(0,a.yg)("code",{parentName:"pre",className:"language-ts"},"export const postsRelations = relations(posts, ({ one }) => ({\n  category: one(categories, {\n    fields: [posts.categoryId],\n    references: [categories.id],\n  }),\n}));\n")),(0,a.yg)("p",null,"We are also creating Zod schemas and types for insert actions and select queries on ",(0,a.yg)("inlineCode",{parentName:"p"},"posts"),"."),(0,a.yg)("p",null,"Similarly, we need to define the other schemas and export them accordingly. Feel free to examine the ",(0,a.yg)("inlineCode",{parentName:"p"},"categories")," and ",(0,a.yg)("inlineCode",{parentName:"p"},"tops")," schemas in the ",(0,a.yg)("inlineCode",{parentName:"p"},"drizzle")," branch of the repository."),(0,a.yg)("p",null,"Inside the ",(0,a.yg)("inlineCode",{parentName:"p"},"./src/drizzle/schema/"),", we have an ",(0,a.yg)("inlineCode",{parentName:"p"},"index.ts")," file that exports the only ",(0,a.yg)("inlineCode",{parentName:"p"},"pgTable()")," based schemas and relations:"),(0,a.yg)("pre",null,(0,a.yg)("code",{parentName:"pre",className:"language-ts",metastring:'title="./src/drizzle/schema/index.ts"',title:'"./src/drizzle/schema/index.ts"'},'export { categories, categoriesRelations } from "./categories";\nexport { posts, postsRelations } from "./posts";\nexport { tops, topsRelations } from "./tops";\n')),(0,a.yg)("p",null,"We are going to import all of these together and use them to create a Postgres client."),(0,a.yg)("h4",{id:"creating-a-postgresql-client-for-drizzle"},"Creating a PostgreSQL Client for Drizzle"),(0,a.yg)("p",null,"Drizzle gives us the ",(0,a.yg)("inlineCode",{parentName:"p"},"drizzle()")," adapter function from ",(0,a.yg)("inlineCode",{parentName:"p"},"drizzle-orm/node-postgres")," to connect to an externally running PostgreSQL server from inside Node.js. We can create a client pool instance from the ",(0,a.yg)("inlineCode",{parentName:"p"},"Pool")," class provided by the ",(0,a.yg)("inlineCode",{parentName:"p"},"pg")," package, and then hook it up with Drizzle. Inside the ",(0,a.yg)("inlineCode",{parentName:"p"},"./src/drizzle/db.ts"),", we have it like this:"),(0,a.yg)("pre",null,(0,a.yg)("code",{parentName:"pre",className:"language-ts",metastring:'title="./src/drizzle/db.ts"',title:'"./src/drizzle/db.ts"'},'import "dotenv/config";\nimport { drizzle } from "drizzle-orm/node-postgres";\n// highlight-next-line\nimport * as schema from "@/drizzle/schema";\nimport { Pool } from "pg";\n\nexport const client = new Pool({\n  host: process.env.DB_HOST,\n  port: parseInt(process.env.DB_PORT as string),\n  user: process.env.DB_USER,\n  password: process.env.DB_PASSWORD,\n  database: process.env.DB_NAME,\n});\n\n// highlight-next-line\nexport const db = drizzle(client, { schema });\n')),(0,a.yg)("p",null,"Basically, we are creating a ",(0,a.yg)("inlineCode",{parentName:"p"},"client")," pool with the credentials from a running PostgreSQL server. We need to specify ",(0,a.yg)("inlineCode",{parentName:"p"},"host"),", ",(0,a.yg)("inlineCode",{parentName:"p"},"port"),", ",(0,a.yg)("inlineCode",{parentName:"p"},"user")," ",(0,a.yg)("inlineCode",{parentName:"p"},"password")," and ",(0,a.yg)("inlineCode",{parentName:"p"},"database")," name. This ",(0,a.yg)("inlineCode",{parentName:"p"},"client")," will then help us create a live Drizzle connection by passing it to ",(0,a.yg)("inlineCode",{parentName:"p"},"drizzle()"),"."),(0,a.yg)("p",null,"With ",(0,a.yg)("inlineCode",{parentName:"p"},"db"),", we have a live connection to perform operations on entity tables inside the database. For table operations, we have to import all schemas combined thanks to ",(0,a.yg)("inlineCode",{parentName:"p"},"* as schema")," and pass it to ",(0,a.yg)("inlineCode",{parentName:"p"},"drizzle()"),". That way, Drizzle is able to refer to all schemas on the database."),(0,a.yg)("p",null,"Alright, with this now, we are ready to generate migration files from the schemas and the PostgreSQL database is ready to run migrations."),(0,a.yg)("h4",{id:"drizzle-orm-generating-migration-files-running-migrations-and-seeding"},"Drizzle ORM: Generating Migration Files, Running Migrations and Seeding"),(0,a.yg)("p",null,"We can use Drizzle Kit to generate migration files. We can run ",(0,a.yg)("inlineCode",{parentName:"p"},"npx drizzle-kit generate")," or we can create an ",(0,a.yg)("inlineCode",{parentName:"p"},"npm")," script for this. I have created a Next.js script on ",(0,a.yg)("inlineCode",{parentName:"p"},"package.json")," under ",(0,a.yg)("inlineCode",{parentName:"p"},"scripts"),":"),(0,a.yg)("pre",null,(0,a.yg)("code",{parentName:"pre",className:"language-json"},'"scripts: {\n    "db:generate": "npx drizzle-kit generate",\n}\n')),(0,a.yg)("p",null,"So, to generate the migration files inside ",(0,a.yg)("inlineCode",{parentName:"p"},"./src/drizzle/migrations/"),", we can now run:"),(0,a.yg)("pre",null,(0,a.yg)("code",{parentName:"pre",className:"language-bash"},"npm run db:generate\n")),(0,a.yg)("p",null,"In order to run these generated migrations, we need to use a client to connect to the running PostgreSQL server perform invoke the ",(0,a.yg)("inlineCode",{parentName:"p"},"migrate()")," function from ",(0,a.yg)("inlineCode",{parentName:"p"},'"drizzle-orm/node-postgres/migrator"')," and then close out of it."),(0,a.yg)("p",null,"The important thing is that we have to invoke ",(0,a.yg)("inlineCode",{parentName:"p"},"migrate()")," inside its own file. For our app, I have a ",(0,a.yg)("inlineCode",{parentName:"p"},"./src/drizzle/migrate.ts")," file to run migrations. It looks like this:"),(0,a.yg)("pre",null,(0,a.yg)("code",{parentName:"pre",className:"language-ts",metastring:'title="./src/drizzle/migrate.ts"',title:'"./src/drizzle/migrate.ts"'},'import { drizzle } from "drizzle-orm/node-postgres";\n// highlight-next-line\nimport { migrate } from "drizzle-orm/node-postgres/migrator";\nimport { client } from "@/drizzle/db";\n\nasync function main() {\n  // highlight-next-line\n  await migrate(drizzle(client), {\n    migrationsFolder: "./src/drizzle/migrations",\n  });\n\n  await client.end();\n}\n\nmain();\n')),(0,a.yg)("p",null,"Basically, here, we need to use the ",(0,a.yg)("inlineCode",{parentName:"p"},"migrate()")," function provided by ",(0,a.yg)("inlineCode",{parentName:"p"},"drizzle-orm/node-postgres/migrator"),". ",(0,a.yg)("inlineCode",{parentName:"p"},"migrate()")," uses a Drizzle connection that needs to specify the source path of the migration files, which is the output folder from the schema migration files generator: ",(0,a.yg)("inlineCode",{parentName:"p"},'"./src/drizzle/migrations"'),". We need to make sure we close the connection since the migration operation is one off."),(0,a.yg)("p",null,"This makes us ready to perform the migrations themselves. We have to use ",(0,a.yg)("inlineCode",{parentName:"p"},"tsx")," to run the ",(0,a.yg)("inlineCode",{parentName:"p"},"main()")," function inside ",(0,a.yg)("inlineCode",{parentName:"p"},"migrate.ts"),". You can use ",(0,a.yg)("inlineCode",{parentName:"p"},"tsx ./src/drizzle/migrate.ts")," from the terminal. I have created an ",(0,a.yg)("inlineCode",{parentName:"p"},"npm")," script with ",(0,a.yg)("inlineCode",{parentName:"p"},"db:migrate"),":"),(0,a.yg)("pre",null,(0,a.yg)("code",{parentName:"pre",className:"language-json"},'"scripts: {\n    "db:migrate": "tsx ./src/drizzle/migrate.ts",\n}\n')),(0,a.yg)("p",null,"Now, we can use it whenever we need to run migrations. Run the migrations with:"),(0,a.yg)("pre",null,(0,a.yg)("code",{parentName:"pre",className:"language-bash"},"npm run db:migrate\n")),(0,a.yg)("admonition",{title:"Delete Obsolete Migration Files Whie in Development",type:"tip"},(0,a.yg)("p",{parentName:"admonition"},"When you have radical changes to the schema files and existing migration files become messy and obsolete, you can always prefer to delete the migrations folder. They can be generated fresh by running a new migration.")),(0,a.yg)("p",null,"At this, point the database should be ready to accept connections and allow table operations. We can seed the database tables with some dummy entries using our ",(0,a.yg)("inlineCode",{parentName:"p"},"db")," drizzle connection we have created earlier in ",(0,a.yg)("inlineCode",{parentName:"p"},"./src/drizzle/db.ts"),". We have a ",(0,a.yg)("inlineCode",{parentName:"p"},"./src/drizzle/seed.ts")," file that looks like this:"),(0,a.yg)("details",null,(0,a.yg)("summary",null,"Show `seed.ts` file"),(0,a.yg)("pre",null,(0,a.yg)("code",{parentName:"pre",className:"language-ts",metastring:'title="./src/drizzle/seed.ts"',title:'"./src/drizzle/seed.ts"'},'import { db } from "@/drizzle/db";\nimport { categories, posts } from "@/drizzle/schema";\nimport { tops } from "./schema/tops";\n\nasync function seed() {\n  await db.insert(categories).values([\n    {\n      name: "Technology",\n      description: "Talks about technology. Any technology",\n    },\n    { name: "Education", description: "Posts about education" },\n    { name: "Science", description: "Science stuff" },\n    { name: "Energy", description: "Renewables, sustainability" },\n    { name: "Agriculture", description: "Reports about agriculture" },\n  ]);\n\n  await db.insert(posts).values([\n    {\n      title: "The rain has a database. It\'s Drizzle",\n      subtitle: "Drizzle works through summer",\n      content:\n        "Drizzle works with React Hook Form, Zod and Next.js Server Components",\n      categoryId: 1,\n    },\n    {\n      title: "What\'s more is Whatmore",\n      subtitle: "Whatmore is not gold. More or less",\n      content:\n        "We don\'t want more. We never want more. That\'s it. That\'s where it goes.",\n      categoryId: 3,\n    },\n    {\n      title: "What\'s cookin\' ?",\n      subtitle: "The heat is up. The gas is down",\n      content:\n        "Many ways to deal with the air. The one that flies. With everything we see and don\'t see. To be see or not be see.",\n      categoryId: 3,\n    },\n    {\n      title: "What\'s a chicken? That\'s no chicken",\n      subtitle: "Chicken in the rain. Chicken in the Drizzle",\n      content: "Work more. East less. Eat more chicken. Do more Drizzle.",\n    },\n    {\n      title: "Water is gone. The rain stopped",\n      subtitle: "Drizzle goes on. To the 1000th day",\n      content: "We\'re flooded. The roads are clogged with mud. Slippery",\n      categoryId: 2,\n    },\n    {\n      title: "Drizzle is bad. It floods.",\n      subtitle: "React Hook Form is good",\n      content:\n        "Drizzle is good with Zod. Zod is from Krypton. We never go there. There\'s never flodd there.",\n    },\n  ]);\n\n  await db.insert(tops).values([{ postId: 3 }, { postId: 6 }, { postId: 4 }]);\n}\n\nseed();\n'))),(0,a.yg)("p",null,"So, inside ",(0,a.yg)("inlineCode",{parentName:"p"},"seed.ts"),", we are inserting entries to ",(0,a.yg)("inlineCode",{parentName:"p"},"categories"),", ",(0,a.yg)("inlineCode",{parentName:"p"},"posts")," and ",(0,a.yg)("inlineCode",{parentName:"p"},"tops")," tables with ",(0,a.yg)("inlineCode",{parentName:"p"},"db.insert()")," method. We can run this file with ",(0,a.yg)("inlineCode",{parentName:"p"},"tsx ./src/drizzle/seed.ts")," or just use the following ",(0,a.yg)("inlineCode",{parentName:"p"},"npm")," script for repeated invocation:"),(0,a.yg)("pre",null,(0,a.yg)("code",{parentName:"pre",className:"language-json"},'"scripts": {\n    "db:seed": "tsx ./src/drizzle/seed.ts"\n  },\n')),(0,a.yg)("p",null,"In order to seed the database run the following command:"),(0,a.yg)("pre",null,(0,a.yg)("code",{parentName:"pre",className:"language-bash"},"npm run db:seed\n")),(0,a.yg)("p",null,"At this point, if you have ",(0,a.yg)("a",{parentName:"p",href:"https://www.pgadmin.org/download/"},"pgAdmin"),", you should be able to observe the changes from the pgAdmin GUI and Query Tool. Feel free to refer to this ",(0,a.yg)("a",{parentName:"p",href:"https://www.youtube.com/watch?v=KuQUNHCeKCk"},"Youtube tutorial")," in case you need to."),(0,a.yg)("p",null,"Now that we have connected to PostgreSQL server with Drizzle and seeded the tables with data, we can use the ",(0,a.yg)("inlineCode",{parentName:"p"},"db")," connection to perform table operations from inside Next.js Server Components. Let's see how we can do this next."),(0,a.yg)("h3",{id:"extras-performing-drizzle-operations-from-nextjs-server-components"},"Extras: Performing Drizzle Operations from Next.js Server Components"),(0,a.yg)("p",null,"The most notable thing about data fetching in Drizzle is that they have to be performed serverside, as opposed to the client side JS/TS. In Next.js, since all pages are by default rendered serverside, we can easily invoke Drizzle ",(0,a.yg)("inlineCode",{parentName:"p"},"db")," queries that fetch table data to populate pages. In cases of mutations, we have to keep ",(0,a.yg)("inlineCode",{parentName:"p"},"db.insert()")," and ",(0,a.yg)("inlineCode",{parentName:"p"},"db.delete()")," operations in the serverside explicitly with the ",(0,a.yg)("inlineCode",{parentName:"p"},'"use server"')," directive. We also need to make form render client side explicitly with ",(0,a.yg)("inlineCode",{parentName:"p"},'"use client"'),"."),(0,a.yg)("p",null,"In order to clarify these ideas, in the below sections we discuss some working examples from the ",(0,a.yg)("inlineCode",{parentName:"p"},"drizzle-demo")," app. The completed code of this demo is available inside the ",(0,a.yg)("inlineCode",{parentName:"p"},"drizzle")," branch. Feel free to ",(0,a.yg)("inlineCode",{parentName:"p"},"checkout")," to that branch if you need to. Once you get a hang of it, you can examine the rest of the completed pages as well."),(0,a.yg)("h4",{id:"drizzle-orm-with-nextjs-keep-queries-in-default-server-rendered-pages"},"Drizzle ORM with Next.js: Keep Queries in Default Server Rendered Pages"),(0,a.yg)("p",null,"Next.js > 14 with app router renders pages serverside by default. This allows us to invoke Drizzle queries from inside pages, without the need to declare them explicitly with the ",(0,a.yg)("inlineCode",{parentName:"p"},'"use server"')," directive. For example, in the default page rendered at ",(0,a.yg)("inlineCode",{parentName:"p"},'"/"'),", we fetch ",(0,a.yg)("inlineCode",{parentName:"p"},"tops")," and ",(0,a.yg)("inlineCode",{parentName:"p"},"posts")," to present the DrizzleDemo Blog page:"),(0,a.yg)("details",null,(0,a.yg)("summary",null,"Show DrizzleDemo Blog page"),(0,a.yg)("pre",null,(0,a.yg)("code",{parentName:"pre",className:"language-tsx",metastring:'title="./src/app/page.tsx"',title:'"./src/app/page.tsx"'},'import React from "react";\nimport { desc } from "drizzle-orm";\n// highlight-next-line\nimport { db } from "@/drizzle/db";\nimport { posts } from "@/drizzle/schema/posts";\nimport { tops } from "@/drizzle/schema/tops";\nimport Card from "./Card";\n\nconst Home = async () => {\n  // highlight-start\n  const featuredPosts = await db.query.tops.findMany({\n    limit: 3,\n    with: {\n      post: true,\n    },\n    orderBy: desc(tops.createdAt),\n  });\n  // highlight-end\n\n  // highlight-start\n  const postsList = await db.query.posts.findMany({\n    with: {\n      category: {\n        columns: {\n          name: true,\n        },\n      },\n    },\n    orderBy: desc(posts.createdAt),\n  });\n  // highlight-end\n\n  return (\n    <div className="mx-auto">\n      <h2 className="mb-16 text-center text-4xl">\n        Welcome to Drizzle Demo Blog\n      </h2>\n      <div>\n        <div>\n          <h2 className="mb-4 text-3xl">Featured Posts</h2>\n          <div className="flex justify-start gap-6">\n            {featuredPosts?.map((top) => (\n              <Card post={top?.post} width={96} />\n            ))}\n          </div>\n        </div>\n        <div className="mb-6 mt-12">\n          <h2 className="mb-4 text-3xl">All Posts</h2>\n          <div className="flex flex-wrap justify-start gap-6">\n            {postsList?.map((post) => (\n              <Card post={post} width={80} />\n            ))}\n          </div>\n        </div>\n      </div>\n    </div>\n  );\n};\n\nexport default Home;\n'))),(0,a.yg)("p",null,"Similarly, we use the default server rendered pages to fetch data for ",(0,a.yg)("inlineCode",{parentName:"p"},"/categories"),", ",(0,a.yg)("inlineCode",{parentName:"p"},"/posts")," and ",(0,a.yg)("inlineCode",{parentName:"p"},"/tops")," routes.\nPlease feel free to examine them inside the ",(0,a.yg)("inlineCode",{parentName:"p"},"drizzle")," branch of the repository."),(0,a.yg)("h4",{id:"drizzle-orm-and-nextjs-make-forms-render-client-side"},"Drizzle ORM and Next.js: Make Forms Render Client Side"),(0,a.yg)("p",null,"Invoking mutations with Drizzle must also happen serverside. This is because Drizzle ",(0,a.yg)("inlineCode",{parentName:"p"},"db")," connection placed inside ",(0,a.yg)("inlineCode",{parentName:"p"},"./src/drizzle/db.ts")," is not accessible from client side. So, we have to split all ",(0,a.yg)("inlineCode",{parentName:"p"},"/new")," pages to have forms render client side and define mutation actions server side -- both explicitly. That way, the form makes the mutation action accessible from client side, and eventual invocation is made from serverside."),(0,a.yg)("p",null,"For example, for the page ",(0,a.yg)("inlineCode",{parentName:"p"},"/posts/new")," route, we have form data handled client side dynamically using React Hook Form and Zod inside ",(0,a.yg)("inlineCode",{parentName:"p"},"<CreatePostForm />"),":"),(0,a.yg)("details",null,(0,a.yg)("summary",null,"Show Client Rendered `",(0,a.yg)(c,{mdxType:"CreatePostForm"}),"`"),(0,a.yg)("pre",null,(0,a.yg)("code",{parentName:"pre",className:"language-tsx",metastring:'title="./src/app/posts/new/createPostsForm.tsx"',title:'"./src/app/posts/new/createPostsForm.tsx"'},'// highlight-next-line\n"use client";\n\nimport React, { ReactNode } from "react";\nimport { SubmitHandler, useForm } from "react-hook-form";\nimport { zodResolver } from "@hookform/resolvers/zod";\nimport { NewPostSchema, TNewPost } from "@/drizzle/schema/posts";\nimport { TCategory } from "@/drizzle/schema/categories";\n// highlight-next-line\nimport { createPost } from "./actions";\nimport { useRouter } from "next/navigation";\n\ntype TCreatePostFormProps = {\n  categories: TCategory[];\n};\n\nconst CreatePostForm = ({ categories }: TCreatePostFormProps) => {\n  const router = useRouter();\n\n  const {\n    reset,\n    register,\n    handleSubmit,\n    formState: { errors },\n  } = useForm<TNewPost>({\n    resolver: zodResolver(NewPostSchema),\n    mode: "onChange",\n    criteriaMode: "all",\n    shouldFocusError: true,\n    reValidateMode: "onSubmit",\n  });\n\n  // highlight-start\n  const createNewPost: SubmitHandler<TNewPost> = async (data: TNewPost) => {\n    await createPost(data);\n    reset({});\n    router.push("/");\n  };\n  // highlight-end\n\n  return (\n    // highlight-next-line\n    <form onSubmit={handleSubmit(createNewPost)}>\n      <div className="mb-4">\n        <label className="mb-2 block text-sm font-medium text-gray-700 dark:text-gray-300">\n          Title\n        </label>\n        <input\n          type="text"\n          {...register("title")}\n          className="text-field"\n          placeholder="Post title"\n        />\n        {errors?.title && <span>{errors?.title?.message as ReactNode}</span>}\n      </div>\n      <div className="mb-4">\n        <label className="mb-2 block text-sm font-medium text-gray-700 dark:text-gray-300">\n          Subtitle\n        </label>\n        <input\n          type="text"\n          {...register("subtitle")}\n          className="text-field"\n          placeholder="Add a subtitle"\n        />\n        {errors?.subtitle && (\n          <span>{errors?.subtitle?.message as ReactNode}</span>\n        )}\n      </div>\n      <div className="mb-4">\n        <label className="mb-2 block text-sm font-medium text-gray-700 dark:text-gray-300">\n          Content\n        </label>\n        <textarea\n          {...register("content")}\n          className="text-field"\n          rows={6}\n          placeholder="Add post content"\n        ></textarea>\n        {errors?.content && (\n          <span>{errors?.content?.message as ReactNode}</span>\n        )}\n      </div>\n      <div className="mb-4">\n        <label className="mb-2 block text-sm font-medium text-gray-700 dark:text-gray-300">\n          Category\n        </label>\n        <select {...register("categoryId")} className="text-field">\n          <option>Select a category</option>\n          {categories?.map((category) => (\n            <option key={category?.id} value={category?.id}>\n              {category?.name}\n            </option>\n          ))}\n        </select>\n      </div>\n      <div className="flex justify-between">\n        <button type="submit" className="btn btn-primary w-40">\n          Create Post\n        </button>\n      </div>\n    </form>\n  );\n};\n\nexport default CreatePostForm;\n'))),(0,a.yg)("p",null,"The most important thing about Drizzle forms / input fields is that they have to be rendered explicitly client side with the ",(0,a.yg)("inlineCode",{parentName:"p"},'"use client"')," directive. This is particularly needed if the forms needs to use dynamic libraries like React Hook Form and Zod. The second important aspect is to make the mutation function accessible to the form. In the above form, we import the ",(0,a.yg)("inlineCode",{parentName:"p"},"createPost()")," function that performs a ",(0,a.yg)("inlineCode",{parentName:"p"},"db.insert()")," call with Drizzle. We use it in the ",(0,a.yg)("inlineCode",{parentName:"p"},"createNewPost()")," handler:"),(0,a.yg)("pre",null,(0,a.yg)("code",{parentName:"pre",className:"language-ts"},'const createNewPost: SubmitHandler<TNewPost> = async (data: TNewPost) => {\n  await createPost(data);\n  reset({});\n  router.push("/");\n};\n')),(0,a.yg)("h4",{id:"drizzle-orm-with-nextjs-move-mutation-actions-explicitly-to-server-side"},"Drizzle ORM with Next.js: Move Mutation Actions Explicitly to Server Side"),(0,a.yg)("p",null,"Inside ",(0,a.yg)("inlineCode",{parentName:"p"},"createPost()"),", we have refactored the ",(0,a.yg)("inlineCode",{parentName:"p"},"db.insert()")," operation out into a serverside action using the ",(0,a.yg)("inlineCode",{parentName:"p"},'"use server"')," directive:"),(0,a.yg)("pre",null,(0,a.yg)("code",{parentName:"pre",className:"language-ts",metastring:'title="./src/app/posts/new/actions.ts"',title:'"./src/app/posts/new/actions.ts"'},'// highlight-next-line\n"use server";\n\nimport { db } from "@/drizzle/db";\nimport { posts, TNewPost } from "@/drizzle/schema/posts";\nimport { revalidatePath } from "next/cache";\n\nexport const createPost = async (data: TNewPost) => {\n  await db.insert(posts).values(data);\n  revalidatePath("/posts");\n};\n')),(0,a.yg)("p",null,"Splitting the Drizzle ",(0,a.yg)("inlineCode",{parentName:"p"},"db")," operation into serverside action makes the client invoke the action and perform the operation successfully from the serverside."),(0,a.yg)("h2",{id:"next-steps"},"Next Steps"),(0,a.yg)("p",null,"We have used the same dual rendering strategy for other pages in ",(0,a.yg)("inlineCode",{parentName:"p"},"posts"),", ",(0,a.yg)("inlineCode",{parentName:"p"},"categories")," and ",(0,a.yg)("inlineCode",{parentName:"p"},"tops"),". Some pages in ",(0,a.yg)("a",{parentName:"p",href:"https://github.com/anewman15/drizzle-demo/tree/drizzle"},(0,a.yg)("inlineCode",{parentName:"a"},"drizzle"))," branch show how to use Drizzle for implementing tables typical of a blog admin panel. Feel free to explore and investigate them, and use Drizzle to implement additional features such as user authentication, admin roles, and more."))}y.isMDXComponent=!0}}]);