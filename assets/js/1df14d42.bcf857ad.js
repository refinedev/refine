"use strict";(self.webpackChunkdocumentation=self.webpackChunkdocumentation||[]).push([[7237],{58860:(e,t,n)=>{n.d(t,{xA:()=>m,yg:()=>y});var a=n(37953);function r(e,t,n){return t in e?Object.defineProperty(e,t,{value:n,enumerable:!0,configurable:!0,writable:!0}):e[t]=n,e}function o(e,t){var n=Object.keys(e);if(Object.getOwnPropertySymbols){var a=Object.getOwnPropertySymbols(e);t&&(a=a.filter((function(t){return Object.getOwnPropertyDescriptor(e,t).enumerable}))),n.push.apply(n,a)}return n}function i(e){for(var t=1;t<arguments.length;t++){var n=null!=arguments[t]?arguments[t]:{};t%2?o(Object(n),!0).forEach((function(t){r(e,t,n[t])})):Object.getOwnPropertyDescriptors?Object.defineProperties(e,Object.getOwnPropertyDescriptors(n)):o(Object(n)).forEach((function(t){Object.defineProperty(e,t,Object.getOwnPropertyDescriptor(n,t))}))}return e}function l(e,t){if(null==e)return{};var n,a,r=function(e,t){if(null==e)return{};var n,a,r={},o=Object.keys(e);for(a=0;a<o.length;a++)n=o[a],t.indexOf(n)>=0||(r[n]=e[n]);return r}(e,t);if(Object.getOwnPropertySymbols){var o=Object.getOwnPropertySymbols(e);for(a=0;a<o.length;a++)n=o[a],t.indexOf(n)>=0||Object.prototype.propertyIsEnumerable.call(e,n)&&(r[n]=e[n])}return r}var g=a.createContext({}),s=function(e){var t=a.useContext(g),n=t;return e&&(n="function"==typeof e?e(t):i(i({},t),e)),n},m=function(e){var t=s(e.components);return a.createElement(g.Provider,{value:t},e.children)},p="mdxType",c={inlineCode:"code",wrapper:function(e){var t=e.children;return a.createElement(a.Fragment,{},t)}},u=a.forwardRef((function(e,t){var n=e.components,r=e.mdxType,o=e.originalType,g=e.parentName,m=l(e,["components","mdxType","originalType","parentName"]),p=s(n),u=r,y=p["".concat(g,".").concat(u)]||p[u]||c[u]||o;return n?a.createElement(y,i(i({ref:t},m),{},{components:n})):a.createElement(y,i({ref:t},m))}));function y(e,t){var n=arguments,r=t&&t.mdxType;if("string"==typeof e||r){var o=n.length,i=new Array(o);i[0]=u;var l={};for(var g in t)hasOwnProperty.call(t,g)&&(l[g]=t[g]);l.originalType=e,l[p]="string"==typeof e?e:r,i[1]=l;for(var s=2;s<o;s++)i[s]=n[s];return a.createElement.apply(null,i)}return a.createElement.apply(null,n)}u.displayName="MDXCreateElement"},5922:(e,t,n)=>{n.r(t),n.d(t,{assets:()=>m,contentTitle:()=>g,default:()=>y,frontMatter:()=>l,metadata:()=>s,toc:()=>p});n(37953);var a=n(58860);function r(e,t,n){return t in e?Object.defineProperty(e,t,{value:n,enumerable:!0,configurable:!0,writable:!0}):e[t]=n,e}function o(e,t){return t=null!=t?t:{},Object.getOwnPropertyDescriptors?Object.defineProperties(e,Object.getOwnPropertyDescriptors(t)):function(e,t){var n=Object.keys(e);if(Object.getOwnPropertySymbols){var a=Object.getOwnPropertySymbols(e);t&&(a=a.filter((function(t){return Object.getOwnPropertyDescriptor(e,t).enumerable}))),n.push.apply(n,a)}return n}(Object(t)).forEach((function(n){Object.defineProperty(e,n,Object.getOwnPropertyDescriptor(t,n))})),e}function i(e,t){if(null==e)return{};var n,a,r=function(e,t){if(null==e)return{};var n,a,r={},o=Object.keys(e);for(a=0;a<o.length;a++)n=o[a],t.indexOf(n)>=0||(r[n]=e[n]);return r}(e,t);if(Object.getOwnPropertySymbols){var o=Object.getOwnPropertySymbols(e);for(a=0;a<o.length;a++)n=o[a],t.indexOf(n)>=0||Object.prototype.propertyIsEnumerable.call(e,n)&&(r[n]=e[n])}return r}const l={title:"Git Merge vs. Git Rebase, The Ultimate Guide to Combining Branches",description:"We will dive into the key differences between git merge and git rebase.",slug:"git-merge-vs-rebase",authors:"ozgur",tags:["git","dev-tools"],image:"https://refine.ams3.cdn.digitaloceanspaces.com/blog/2025-07-8-git-merge/Frame%209%20from%20Figma.png",hide_table_of_contents:!1},g="Git Merge vs. Git Rebase: The Ultimate Guide to Combining Branches",s={permalink:"/blog/git-merge-vs-rebase",source:"@site/blog/2025-07-09-git-merge.md",title:"Git Merge vs. Git Rebase, The Ultimate Guide to Combining Branches",description:"We will dive into the key differences between git merge and git rebase.",date:"2025-07-09T00:00:00.000Z",formattedDate:"July 9, 2025",tags:[{label:"git",permalink:"/blog/tags/git"},{label:"dev-tools",permalink:"/blog/tags/dev-tools"}],readingTime:8.605,hasTruncateMarker:!1,authors:[{name:"\xd6zg\xfcr Ak\xe7a",title:"Junior Developer Relations",url:"https://github.com/doguhanozgurakca",imageURL:"https://github.com/doguhanozgurakca.png",key:"ozgur"}],frontMatter:{title:"Git Merge vs. Git Rebase, The Ultimate Guide to Combining Branches",description:"We will dive into the key differences between git merge and git rebase.",slug:"git-merge-vs-rebase",authors:"ozgur",tags:["git","dev-tools"],image:"https://refine.ams3.cdn.digitaloceanspaces.com/blog/2025-07-8-git-merge/Frame%209%20from%20Figma.png",hide_table_of_contents:!1},prevItem:{title:"Does My Code Dream of Electric Bugs?",permalink:"/blog/code-electric-bugs"},nextItem:{title:'What is "Vibe Coding"',permalink:"/blog/vibe-coding"},relatedPosts:[{title:"Introduction to Docker Compose",description:"We'll go over the basics of Docker Compose in this article, including what it is, how it works, and how to use it.",permalink:"/blog/docker-compose",formattedDate:"July 31, 2023",authors:[{name:"Muhammad Khabbab",title:"Project Manager",imageURL:"/img/generic-profile.png",key:"muhammad_khabbab"}],readingTime:11.205,date:"2023-07-31T00:00:00.000Z"},{title:"How to Use Nodemon to Automatically Restart Node.js Applications",description:"This guide shows you how to install and use Nodemon to streamline your development process.",permalink:"/blog/nodemon",formattedDate:"November 8, 2024",authors:[{name:"Necati \xd6zmen",title:"Head of Growth at Refine",url:"https://github.com/necatiozmen",description:"Feeling Irie",github:"https://github.com/necatiozmen",twitter:"https://twitter.com/necatiozmen3",linkedin:"https://www.linkedin.com/in/necatiozmen/",imageURL:"https://github.com/necatiozmen.png",key:"necati"}],readingTime:10.62,date:"2024-11-08T00:00:00.000Z"},{title:"Low Code Limitations - Exploring the Risk of Vendor Lock-In",description:"We discuss the limitations and risks associated with low-code platforms and how to avoid getting stuck with one vendor.",permalink:"/blog/low-code-tools",formattedDate:"April 19, 2024",authors:[{name:"Necati \xd6zmen",title:"Head of Growth at Refine",url:"https://github.com/necatiozmen",description:"Feeling Irie",github:"https://github.com/necatiozmen",twitter:"https://twitter.com/necatiozmen3",linkedin:"https://www.linkedin.com/in/necatiozmen/",imageURL:"https://github.com/necatiozmen.png",key:"necati"}],readingTime:7.255,date:"2024-04-19T00:00:00.000Z"}],authorPosts:[{title:"Refine AI Levels Up with Claude 4",description:"Refine AI now capitalizes on the power of Anthropic's newly released Claude 4 models, improving output quality and productivity in your future and existing Refine AI projects.",permalink:"/blog/refine-ai-claude-4",formattedDate:"May 26, 2025",authors:[{name:"\xd6zg\xfcr Ak\xe7a",title:"Junior Developer Relations",url:"https://github.com/doguhanozgurakca",imageURL:"https://github.com/doguhanozgurakca.png",key:"ozgur"}],readingTime:2.555,date:"2025-05-26T00:00:00.000Z"},{title:"Does My Code Dream of Electric Bugs?",description:"A reflective deep-dive into the surreal, uncanny relationship between AI, bugs, and human intention in software development.",permalink:"/blog/code-electric-bugs",formattedDate:"July 28, 2025",authors:[{name:"\xd6zg\xfcr Ak\xe7a",title:"Junior Developer Relations",url:"https://github.com/doguhanozgurakca",imageURL:"https://github.com/doguhanozgurakca.png",key:"ozgur"}],readingTime:6.935,date:"2025-07-28T00:00:00.000Z"},{title:"AI-First UIs: Why shadcn/ui's Model is Leading the Pack",description:"How shadcn/ui's component architecture and direct code ownership are setting the standard for AI-native UI development.",permalink:"/blog/shadcn-blog",formattedDate:"June 5, 2025",authors:[{name:"\xd6zg\xfcr Ak\xe7a",title:"Junior Developer Relations",url:"https://github.com/doguhanozgurakca",imageURL:"https://github.com/doguhanozgurakca.png",key:"ozgur"}],readingTime:6.475,date:"2025-06-05T00:00:00.000Z"}]},m={authorsImageUrls:[void 0]},p=[{value:"Part 1: <code>git merge</code> - The Story Preserver",id:"part-1-git-merge---the-story-preserver",level:2},{value:"How <code>git merge</code> Works",id:"how-git-merge-works",level:3},{value:"The &quot;Fast-Forward&quot; Merge",id:"the-fast-forward-merge",level:3},{value:"Handling Merge Conflicts",id:"handling-merge-conflicts",level:3},{value:"Part 2: <code>git rebase</code> - The History Rewriter",id:"part-2-git-rebase---the-history-rewriter",level:2},{value:"How <code>git rebase</code> Works",id:"how-git-rebase-works",level:3},{value:"The Golden Rule of Rebasing",id:"the-golden-rule-of-rebasing",level:3},{value:"Interactive Rebase: Your Personal History Janitor",id:"interactive-rebase-your-personal-history-janitor",level:3},{value:"Head-to-Head: Merge vs. Rebase",id:"head-to-head-merge-vs-rebase",level:2},{value:"Conclusion: Which One Should You Use?",id:"conclusion-which-one-should-you-use",level:2}],c={toc:p},u="wrapper";function y(e){var{components:t}=e,n=i(e,["components"]);return(0,a.yg)(u,o(function(e){for(var t=1;t<arguments.length;t++){var n=null!=arguments[t]?arguments[t]:{},a=Object.keys(n);"function"==typeof Object.getOwnPropertySymbols&&(a=a.concat(Object.getOwnPropertySymbols(n).filter((function(e){return Object.getOwnPropertyDescriptor(n,e).enumerable})))),a.forEach((function(t){r(e,t,n[t])}))}return e}({},c,n),{components:t,mdxType:"MDXLayout"}),(0,a.yg)("p",null,"As a developer, you live and breathe branches. You create them for new features, bug fixes, and experiments. But at some point, that isolated work needs to be integrated back into the main line of development. In the world of Git, two powerful commands stand ready to help: ",(0,a.yg)("inlineCode",{parentName:"p"},"git merge")," and ",(0,a.yg)("inlineCode",{parentName:"p"},"git rebase"),"."),(0,a.yg)("p",null,"Choosing between them is one of the most common points of debate and confusion among Git users. Both can achieve the goal of combining work from different branches, but they do so with fundamentally different philosophies and results. Understanding this difference is not just academic\u2014it directly impacts your project's history, your team's workflow, and your ability to debug issues down the line."),(0,a.yg)("p",null,"This guide will provide a deep dive into both commands. We'll explore how they work under the hood, visualize their impact on your commit history, discuss how to handle conflicts, and introduce powerful related techniques like interactive rebase. By the end, you'll be able to confidently choose the right tool for the right job."),(0,a.yg)("hr",null),(0,a.yg)("h2",{id:"part-1-git-merge---the-story-preserver"},"Part 1: ",(0,a.yg)("inlineCode",{parentName:"h2"},"git merge")," - The Story Preserver"),(0,a.yg)("p",null,(0,a.yg)("inlineCode",{parentName:"p"},"git merge")," is the workhorse of branch integration. Its primary goal is to take the commits from a source branch and weave them into a target branch. The key takeaway for ",(0,a.yg)("inlineCode",{parentName:"p"},"merge")," is that it ",(0,a.yg)("strong",{parentName:"p"},"preserves history as it happened"),"."),(0,a.yg)("h3",{id:"how-git-merge-works"},"How ",(0,a.yg)("inlineCode",{parentName:"h3"},"git merge")," Works"),(0,a.yg)("p",null,"Let's imagine you're working on a new feature. You create a branch called ",(0,a.yg)("inlineCode",{parentName:"p"},"feature/login")," from the ",(0,a.yg)("inlineCode",{parentName:"p"},"main")," branch."),(0,a.yg)("p",null,(0,a.yg)("strong",{parentName:"p"},"Initial State:"),"\nYour ",(0,a.yg)("inlineCode",{parentName:"p"},"main")," branch has two commits."),(0,a.yg)("pre",null,(0,a.yg)("code",{parentName:"pre"},"A---B  (main)\n")),(0,a.yg)("p",null,"You create your feature branch from here."),(0,a.yg)("pre",null,(0,a.yg)("code",{parentName:"pre"},"A---B  (main)\n     \\\n      (feature/login)\n")),(0,a.yg)("p",null,"Now, you add a commit to your feature branch."),(0,a.yg)("pre",null,(0,a.yg)("code",{parentName:"pre"},"A---B  (main)\n     \\\n      C  (feature/login)\n")),(0,a.yg)("p",null,"While you were working, a teammate pushed a new commit (",(0,a.yg)("inlineCode",{parentName:"p"},"D"),") to the ",(0,a.yg)("inlineCode",{parentName:"p"},"main")," branch. The project history has now diverged."),(0,a.yg)("pre",null,(0,a.yg)("code",{parentName:"pre"},"      D  (main)\n     /\nA---B\n     \\\n      C  (feature/login)\n")),(0,a.yg)("p",null,"To integrate your feature, you switch to the target branch (",(0,a.yg)("inlineCode",{parentName:"p"},"main"),") and run the merge command:"),(0,a.yg)("pre",null,(0,a.yg)("code",{parentName:"pre",className:"language-sh"},"# Switch to the branch you want to merge INTO\ngit switch main\n\n# Merge the feature branch INTO main\ngit merge feature/login\n")),(0,a.yg)("p",null,"Git performs a ",(0,a.yg)("strong",{parentName:"p"},"three-way merge"),". It looks at three commits to make its decision:"),(0,a.yg)("ol",null,(0,a.yg)("li",{parentName:"ol"},"The tip of the ",(0,a.yg)("inlineCode",{parentName:"li"},"main")," branch (",(0,a.yg)("inlineCode",{parentName:"li"},"D"),")"),(0,a.yg)("li",{parentName:"ol"},"The tip of the ",(0,a.yg)("inlineCode",{parentName:"li"},"feature/login")," branch (",(0,a.yg)("inlineCode",{parentName:"li"},"C"),")"),(0,a.yg)("li",{parentName:"ol"},"Their common ancestor (",(0,a.yg)("inlineCode",{parentName:"li"},"B"),")")),(0,a.yg)("p",null,"It then creates a brand new commit, called a ",(0,a.yg)("strong",{parentName:"p"},"merge commit"),". This special commit has two parents (",(0,a.yg)("inlineCode",{parentName:"p"},"C")," and ",(0,a.yg)("inlineCode",{parentName:"p"},"D"),") and represents the reconciliation of these two divergent histories."),(0,a.yg)("p",null,(0,a.yg)("strong",{parentName:"p"},"The Result:"),"\nThe history now looks like this, with the new merge commit ",(0,a.yg)("inlineCode",{parentName:"p"},"E"),"."),(0,a.yg)("pre",null,(0,a.yg)("code",{parentName:"pre"},"      D-------E  (main)\n     /         /\nA---B---------C  (feature/login)\n")),(0,a.yg)("h3",{id:"the-fast-forward-merge"},'The "Fast-Forward" Merge'),(0,a.yg)("p",null,"What if the ",(0,a.yg)("inlineCode",{parentName:"p"},"main")," branch had ",(0,a.yg)("em",{parentName:"p"},"not")," changed while you were working on your feature?"),(0,a.yg)("pre",null,(0,a.yg)("code",{parentName:"pre"},"A---B  (main)\n     \\\n      C  (feature/login)\n")),(0,a.yg)("p",null,"In this case, when you run ",(0,a.yg)("inlineCode",{parentName:"p"},"git merge feature/login"),", Git sees that ",(0,a.yg)("inlineCode",{parentName:"p"},"main")," is a direct ancestor of ",(0,a.yg)("inlineCode",{parentName:"p"},"feature/login"),'. It doesn\'t need to create a merge commit. It simply "fast-forwards" the ',(0,a.yg)("inlineCode",{parentName:"p"},"main")," pointer to point to the same commit as your feature branch."),(0,a.yg)("pre",null,(0,a.yg)("code",{parentName:"pre"},"A---B---C  (main, feature/login)\n")),(0,a.yg)("p",null,"This results in a perfectly linear history."),(0,a.yg)("h3",{id:"handling-merge-conflicts"},"Handling Merge Conflicts"),(0,a.yg)("p",null,"Conflicts happen when both branches have changed the same part of the same file. When you try to merge, Git will pause and tell you there's a conflict."),(0,a.yg)("pre",null,(0,a.yg)("code",{parentName:"pre",className:"language-sh"},"$ git merge feature/login\nAuto-merging index.js\nCONFLICT (content): Merge conflict in index.js\nAutomatic merge failed; fix conflicts and then commit the result.\n")),(0,a.yg)("p",null,"To resolve it:"),(0,a.yg)("ol",null,(0,a.yg)("li",{parentName:"ol"},(0,a.yg)("strong",{parentName:"li"},"Check the status:")," ",(0,a.yg)("inlineCode",{parentName:"li"},"git status")," will show you which files are in conflict."),(0,a.yg)("li",{parentName:"ol"},(0,a.yg)("strong",{parentName:"li"},"Open the file:")," Inside the conflicted file, Git marks the problematic areas:",(0,a.yg)("pre",{parentName:"li"},(0,a.yg)("code",{parentName:"pre",className:"language-javascript"},"<<<<<<< HEAD\n// Code from main branch\nconst greeting = 'Hello, World!';\n=======\n// Code from your feature branch\nconst greeting = 'Hi, Universe!';\n>>>>>>> feature/login\n"))),(0,a.yg)("li",{parentName:"ol"},(0,a.yg)("strong",{parentName:"li"},"Edit the file:")," Manually edit the code to be the final version you want. Remove the ",(0,a.yg)("inlineCode",{parentName:"li"},"<<<<<<<"),", ",(0,a.yg)("inlineCode",{parentName:"li"},"======="),", and ",(0,a.yg)("inlineCode",{parentName:"li"},">>>>>>>")," markers."),(0,a.yg)("li",{parentName:"ol"},(0,a.yg)("strong",{parentName:"li"},"Stage the file:")," ",(0,a.yg)("inlineCode",{parentName:"li"},"git add <conflicted-file-name>")),(0,a.yg)("li",{parentName:"ol"},(0,a.yg)("strong",{parentName:"li"},"Commit:")," Run ",(0,a.yg)("inlineCode",{parentName:"li"},"git commit"),". Git will see you're in the middle of a merge and create the merge commit for you, completing the process.")),(0,a.yg)("p",null,(0,a.yg)("strong",{parentName:"p"},"Pros of ",(0,a.yg)("inlineCode",{parentName:"strong"},"git merge"),":")),(0,a.yg)("ul",null,(0,a.yg)("li",{parentName:"ul"},(0,a.yg)("strong",{parentName:"li"},"Traceability:")," The history is a true and accurate log of what happened. A merge commit acts as a clear record that a feature was integrated."),(0,a.yg)("li",{parentName:"ul"},(0,a.yg)("strong",{parentName:"li"},"Non-destructive:")," It never changes existing commits, which is a safe practice, especially for shared branches."),(0,a.yg)("li",{parentName:"ul"},(0,a.yg)("strong",{parentName:"li"},"Contextual:")," It keeps the context of a feature branch intact\u2014you can see the entire history of the branch's development.")),(0,a.yg)("p",null,(0,a.yg)("strong",{parentName:"p"},"Cons of ",(0,a.yg)("inlineCode",{parentName:"strong"},"git merge"),":")),(0,a.yg)("ul",null,(0,a.yg)("li",{parentName:"ul"},(0,a.yg)("strong",{parentName:"li"},"Cluttered History:")," If your team merges frequently, the ",(0,a.yg)("inlineCode",{parentName:"li"},"git log --graph")," can become a complex, branching mess of merge commits that is hard to read.")),(0,a.yg)("hr",null),(0,a.yg)("h2",{id:"part-2-git-rebase---the-history-rewriter"},"Part 2: ",(0,a.yg)("inlineCode",{parentName:"h2"},"git rebase")," - The History Rewriter"),(0,a.yg)("p",null,(0,a.yg)("inlineCode",{parentName:"p"},"git rebase")," offers a different way to combine work. Instead of creating a merge commit, its goal is to create a ",(0,a.yg)("strong",{parentName:"p"},"clean, linear history"),". It achieves this by ",(0,a.yg)("strong",{parentName:"p"},"rewriting commits"),"."),(0,a.yg)("h3",{id:"how-git-rebase-works"},"How ",(0,a.yg)("inlineCode",{parentName:"h3"},"git rebase")," Works"),(0,a.yg)("p",null,"Let's use the same divergent history scenario:"),(0,a.yg)("pre",null,(0,a.yg)("code",{parentName:"pre"},"      D  (main)\n     /\nA---B\n     \\\n      C  (feature/login)\n")),(0,a.yg)("p",null,"To use rebase, you check out the branch you want to move (",(0,a.yg)("inlineCode",{parentName:"p"},"feature/login"),") and rebase it ",(0,a.yg)("em",{parentName:"p"},"onto")," the target (",(0,a.yg)("inlineCode",{parentName:"p"},"main"),")."),(0,a.yg)("pre",null,(0,a.yg)("code",{parentName:"pre",className:"language-sh"},"# Switch to the branch with your work\ngit switch feature/login\n\n# Rebase it onto the main branch\ngit rebase main\n")),(0,a.yg)("p",null,"Git does the following:"),(0,a.yg)("ol",null,(0,a.yg)("li",{parentName:"ol"},"Finds the common ancestor (",(0,a.yg)("inlineCode",{parentName:"li"},"B"),")."),(0,a.yg)("li",{parentName:"ol"},'"Saves" the commits unique to your feature branch (in this case, ',(0,a.yg)("inlineCode",{parentName:"li"},"C"),") as temporary patches."),(0,a.yg)("li",{parentName:"ol"},"Resets your ",(0,a.yg)("inlineCode",{parentName:"li"},"feature/login")," branch to the latest commit on ",(0,a.yg)("inlineCode",{parentName:"li"},"main")," (",(0,a.yg)("inlineCode",{parentName:"li"},"D"),")."),(0,a.yg)("li",{parentName:"ol"},"Applies the saved patches one by one, creating ",(0,a.yg)("strong",{parentName:"li"},"new commits")," on top of ",(0,a.yg)("inlineCode",{parentName:"li"},"main"),".")),(0,a.yg)("p",null,(0,a.yg)("strong",{parentName:"p"},"The Result:"),"\nThe history becomes perfectly linear. Notice that ",(0,a.yg)("inlineCode",{parentName:"p"},"C")," has become ",(0,a.yg)("inlineCode",{parentName:"p"},"C'"),", indicating it's a new commit with the same changes."),(0,a.yg)("pre",null,(0,a.yg)("code",{parentName:"pre"},"A---B---D---C' (feature/login)\n         \\\n          (main)\n")),(0,a.yg)("p",null,"The old commit ",(0,a.yg)("inlineCode",{parentName:"p"},"C")," is now orphaned and will eventually be garbage collected by Git. Now, ",(0,a.yg)("inlineCode",{parentName:"p"},"feature/login")," can be fast-forward merged into ",(0,a.yg)("inlineCode",{parentName:"p"},"main"),"."),(0,a.yg)("pre",null,(0,a.yg)("code",{parentName:"pre",className:"language-sh"},"git switch main\ngit merge feature/login # This will be a simple fast-forward\n")),(0,a.yg)("h3",{id:"the-golden-rule-of-rebasing"},"The Golden Rule of Rebasing"),(0,a.yg)("p",null,"Because ",(0,a.yg)("inlineCode",{parentName:"p"},"rebase")," rewrites history by creating new commits, there is one critical rule you must always follow:"),(0,a.yg)("blockquote",null,(0,a.yg)("p",{parentName:"blockquote"},(0,a.yg)("strong",{parentName:"p"},"Do not rebase a branch that is shared publicly with others."))),(0,a.yg)("p",null,"If you rebase a branch that your teammates have pulled, you are creating a divergent history. Their repository still has the old commits, while yours has the new, rewritten ones. When you both try to push, Git will become hopelessly confused. Only rebase branches that exist locally on your machine."),(0,a.yg)("h3",{id:"interactive-rebase-your-personal-history-janitor"},"Interactive Rebase: Your Personal History Janitor"),(0,a.yg)("p",null,"One of the most powerful features of rebase is its interactive mode: ",(0,a.yg)("inlineCode",{parentName:"p"},"git rebase -i"),". This allows you to clean up your own local commit history ",(0,a.yg)("em",{parentName:"p"},"before")," you share your work with others."),(0,a.yg)("p",null,"Imagine you're on your feature branch and your history looks messy:"),(0,a.yg)("pre",null,(0,a.yg)("code",{parentName:"pre"},"A---B---C---D---E (feature/login)\n")),(0,a.yg)("ul",null,(0,a.yg)("li",{parentName:"ul"},"Commit ",(0,a.yg)("inlineCode",{parentName:"li"},"C"),': "WIP"'),(0,a.yg)("li",{parentName:"ul"},"Commit ",(0,a.yg)("inlineCode",{parentName:"li"},"D"),': "fixed a typo"'),(0,a.yg)("li",{parentName:"ul"},"Commit ",(0,a.yg)("inlineCode",{parentName:"li"},"E"),': "actually implement the feature"')),(0,a.yg)("p",null,"Before you merge this, you can clean it up."),(0,a.yg)("pre",null,(0,a.yg)("code",{parentName:"pre",className:"language-sh"},"# Rebase interactively against the commit you branched from (B's hash, or main)\ngit rebase -i main\n")),(0,a.yg)("p",null,"This opens a text editor with a list of your commits:"),(0,a.yg)("pre",null,(0,a.yg)("code",{parentName:"pre"},"pick <hash_C> WIP\npick <hash_D> fixed a typo\npick <hash_E> actually implement the feature\n\n# Commands:\n# p, pick = use commit\n# s, squash = use commit, but meld into previous commit\n# ... and others like reword, edit, drop\n")),(0,a.yg)("p",null,"You can change ",(0,a.yg)("inlineCode",{parentName:"p"},"pick")," to ",(0,a.yg)("inlineCode",{parentName:"p"},"squash")," to combine the first two commits into the third one."),(0,a.yg)("pre",null,(0,a.yg)("code",{parentName:"pre"},"pick <hash_C> WIP\nsquash <hash_D> fixed a typo\nsquash <hash_E> actually implement the feature\n")),(0,a.yg)("p",null,"Save and close. Git will then prompt you to write a new, clean commit message for the combined commit. Your history now looks pristine:"),(0,a.yg)("pre",null,(0,a.yg)("code",{parentName:"pre"},"A---B---F (feature/login)\n")),(0,a.yg)("p",null,"Where ",(0,a.yg)("inlineCode",{parentName:"p"},"F"),' is a single, clean commit titled "Implement User Login Feature".'),(0,a.yg)("p",null,(0,a.yg)("strong",{parentName:"p"},"Pros of ",(0,a.yg)("inlineCode",{parentName:"strong"},"git rebase"),":")),(0,a.yg)("ul",null,(0,a.yg)("li",{parentName:"ul"},(0,a.yg)("strong",{parentName:"li"},"Linear History:")," The primary benefit is a clean, easy-to-read commit history."),(0,a.yg)("li",{parentName:"ul"},(0,a.yg)("strong",{parentName:"li"},"Clarity:")," It's easier to follow the progression of the project without noisy merge commits."),(0,a.yg)("li",{parentName:"ul"},(0,a.yg)("strong",{parentName:"li"},"Powerful Cleanup:")," Interactive rebase is an incredible tool for crafting a meaningful commit history.")),(0,a.yg)("p",null,(0,a.yg)("strong",{parentName:"p"},"Cons of ",(0,a.yg)("inlineCode",{parentName:"strong"},"git rebase"),":")),(0,a.yg)("ul",null,(0,a.yg)("li",{parentName:"ul"},(0,a.yg)("strong",{parentName:"li"},"Rewrites History:")," This can be dangerous if not used correctly on private branches."),(0,a.yg)("li",{parentName:"ul"},(0,a.yg)("strong",{parentName:"li"},"Loses Context:")," You lose the record of when a branch was created and merged."),(0,a.yg)("li",{parentName:"ul"},(0,a.yg)("strong",{parentName:"li"},"More Complex:")," It can be more complex to handle conflicts, as you may have to resolve them on each commit being replayed.")),(0,a.yg)("hr",null),(0,a.yg)("h2",{id:"head-to-head-merge-vs-rebase"},"Head-to-Head: Merge vs. Rebase"),(0,a.yg)("table",null,(0,a.yg)("thead",{parentName:"table"},(0,a.yg)("tr",{parentName:"thead"},(0,a.yg)("th",{parentName:"tr",align:null},"Feature"),(0,a.yg)("th",{parentName:"tr",align:null},(0,a.yg)("inlineCode",{parentName:"th"},"git merge")),(0,a.yg)("th",{parentName:"tr",align:null},(0,a.yg)("inlineCode",{parentName:"th"},"git rebase")))),(0,a.yg)("tbody",{parentName:"table"},(0,a.yg)("tr",{parentName:"tbody"},(0,a.yg)("td",{parentName:"tr",align:null},(0,a.yg)("strong",{parentName:"td"},"History Shape")),(0,a.yg)("td",{parentName:"tr",align:null},"Branching, graph-like (non-linear)"),(0,a.yg)("td",{parentName:"tr",align:null},"Perfectly linear")),(0,a.yg)("tr",{parentName:"tbody"},(0,a.yg)("td",{parentName:"tr",align:null},(0,a.yg)("strong",{parentName:"td"},"History Integrity")),(0,a.yg)("td",{parentName:"tr",align:null},"Preserves original commits; adds a merge commit"),(0,a.yg)("td",{parentName:"tr",align:null},"Rewrites commits, creating new ones")),(0,a.yg)("tr",{parentName:"tbody"},(0,a.yg)("td",{parentName:"tr",align:null},(0,a.yg)("strong",{parentName:"td"},"Collaboration")),(0,a.yg)("td",{parentName:"tr",align:null},"Safe for public, shared branches"),(0,a.yg)("td",{parentName:"tr",align:null},"Safe only for local, private branches")),(0,a.yg)("tr",{parentName:"tbody"},(0,a.yg)("td",{parentName:"tr",align:null},(0,a.yg)("strong",{parentName:"td"},"Ease of Use")),(0,a.yg)("td",{parentName:"tr",align:null},"Simpler concept, fewer risks"),(0,a.yg)("td",{parentName:"tr",align:null},'More complex, requires understanding the "Golden Rule"')),(0,a.yg)("tr",{parentName:"tbody"},(0,a.yg)("td",{parentName:"tr",align:null},(0,a.yg)("strong",{parentName:"td"},"Conflict Resolution")),(0,a.yg)("td",{parentName:"tr",align:null},"Resolve all conflicts at once, then commit"),(0,a.yg)("td",{parentName:"tr",align:null},"Resolve conflicts one commit at a time as they are replayed")))),(0,a.yg)("hr",null),(0,a.yg)("h2",{id:"conclusion-which-one-should-you-use"},"Conclusion: Which One Should You Use?"),(0,a.yg)("p",null,'There is no single "better" command. The choice depends entirely on your team\'s workflow and preferences.'),(0,a.yg)("ul",null,(0,a.yg)("li",{parentName:"ul"},(0,a.yg)("p",{parentName:"li"},(0,a.yg)("strong",{parentName:"p"},"Choose ",(0,a.yg)("inlineCode",{parentName:"strong"},"git merge")," when:")),(0,a.yg)("ul",{parentName:"li"},(0,a.yg)("li",{parentName:"ul"},"You are working on a shared/public branch."),(0,a.yg)("li",{parentName:"ul"},"Your team values a precise and untampered historical record."),(0,a.yg)("li",{parentName:"ul"},"You want to maintain the distinct context of a feature branch."))),(0,a.yg)("li",{parentName:"ul"},(0,a.yg)("p",{parentName:"li"},(0,a.yg)("strong",{parentName:"p"},"Choose ",(0,a.yg)("inlineCode",{parentName:"strong"},"git rebase")," when:")),(0,a.yg)("ul",{parentName:"li"},(0,a.yg)("li",{parentName:"ul"},"You are working on your own local, private branch."),(0,a.yg)("li",{parentName:"ul"},"You want to present a clean, linear series of commits to the main branch."),(0,a.yg)("li",{parentName:"ul"},"You value a readable project history over a strictly chronological one.")))),(0,a.yg)("p",null,"A popular and effective workflow is to ",(0,a.yg)("strong",{parentName:"p"},"use ",(0,a.yg)("inlineCode",{parentName:"strong"},"rebase")," locally to clean up your own work and then ",(0,a.yg)("inlineCode",{parentName:"strong"},"merge")," it into the shared branch"),". This gives you the best of both worlds: a clean feature history combined with a merge commit that signals the integration of a complete feature."),(0,a.yg)("p",null,"The best way to learn is to try. Create a test repository, make some branches, and see for yourself how ",(0,a.yg)("inlineCode",{parentName:"p"},"merge")," and ",(0,a.yg)("inlineCode",{parentName:"p"},"rebase")," shape the history. Gaining mastery over these two commands will make you a more effective and collaborative developer."))}y.isMDXComponent=!0}}]);