"use strict";(self.webpackChunkdocumentation=self.webpackChunkdocumentation||[]).push([[70728],{15680:(e,n,t)=>{t.d(n,{xA:()=>p,yg:()=>m});var r=t(96540);function o(e,n,t){return n in e?Object.defineProperty(e,n,{value:t,enumerable:!0,configurable:!0,writable:!0}):e[n]=t,e}function a(e,n){var t=Object.keys(e);if(Object.getOwnPropertySymbols){var r=Object.getOwnPropertySymbols(e);n&&(r=r.filter((function(n){return Object.getOwnPropertyDescriptor(e,n).enumerable}))),t.push.apply(t,r)}return t}function i(e){for(var n=1;n<arguments.length;n++){var t=null!=arguments[n]?arguments[n]:{};n%2?a(Object(t),!0).forEach((function(n){o(e,n,t[n])})):Object.getOwnPropertyDescriptors?Object.defineProperties(e,Object.getOwnPropertyDescriptors(t)):a(Object(t)).forEach((function(n){Object.defineProperty(e,n,Object.getOwnPropertyDescriptor(t,n))}))}return e}function s(e,n){if(null==e)return{};var t,r,o=function(e,n){if(null==e)return{};var t,r,o={},a=Object.keys(e);for(r=0;r<a.length;r++)t=a[r],n.indexOf(t)>=0||(o[t]=e[t]);return o}(e,n);if(Object.getOwnPropertySymbols){var a=Object.getOwnPropertySymbols(e);for(r=0;r<a.length;r++)t=a[r],n.indexOf(t)>=0||Object.prototype.propertyIsEnumerable.call(e,t)&&(o[t]=e[t])}return o}var u=r.createContext({}),l=function(e){var n=r.useContext(u),t=n;return e&&(t="function"==typeof e?e(n):i(i({},n),e)),t},p=function(e){var n=l(e.components);return r.createElement(u.Provider,{value:n},e.children)},d="mdxType",c={inlineCode:"code",wrapper:function(e){var n=e.children;return r.createElement(r.Fragment,{},n)}},g=r.forwardRef((function(e,n){var t=e.components,o=e.mdxType,a=e.originalType,u=e.parentName,p=s(e,["components","mdxType","originalType","parentName"]),d=l(t),g=o,m=d["".concat(u,".").concat(g)]||d[g]||c[g]||a;return t?r.createElement(m,i(i({ref:n},p),{},{components:t})):r.createElement(m,i({ref:n},p))}));function m(e,n){var t=arguments,o=n&&n.mdxType;if("string"==typeof e||o){var a=t.length,i=new Array(a);i[0]=g;var s={};for(var u in n)hasOwnProperty.call(n,u)&&(s[u]=n[u]);s.originalType=e,s[d]="string"==typeof e?e:o,i[1]=s;for(var l=2;l<a;l++)i[l]=t[l];return r.createElement.apply(null,i)}return r.createElement.apply(null,t)}g.displayName="MDXCreateElement"},95069:(e,n,t)=>{t.r(n),t.d(n,{assets:()=>p,contentTitle:()=>u,default:()=>x,frontMatter:()=>s,metadata:()=>l,toc:()=>d});t(96540);var r=t(15680);function o(e,n,t){return n in e?Object.defineProperty(e,n,{value:t,enumerable:!0,configurable:!0,writable:!0}):e[n]=t,e}function a(e,n){return n=null!=n?n:{},Object.getOwnPropertyDescriptors?Object.defineProperties(e,Object.getOwnPropertyDescriptors(n)):function(e,n){var t=Object.keys(e);if(Object.getOwnPropertySymbols){var r=Object.getOwnPropertySymbols(e);n&&(r=r.filter((function(n){return Object.getOwnPropertyDescriptor(e,n).enumerable}))),t.push.apply(t,r)}return t}(Object(n)).forEach((function(t){Object.defineProperty(e,t,Object.getOwnPropertyDescriptor(n,t))})),e}function i(e,n){if(null==e)return{};var t,r,o=function(e,n){if(null==e)return{};var t,r,o={},a=Object.keys(e);for(r=0;r<a.length;r++)t=a[r],n.indexOf(t)>=0||(o[t]=e[t]);return o}(e,n);if(Object.getOwnPropertySymbols){var a=Object.getOwnPropertySymbols(e);for(r=0;r<a.length;r++)t=a[r],n.indexOf(t)>=0||Object.prototype.propertyIsEnumerable.call(e,t)&&(o[t]=e[t])}return o}const s={title:"Remix"},u=void 0,l={unversionedId:"routing/integrations/remix/index",id:"routing/integrations/remix/index",title:"Remix",description:"Refine provides router bindings and utilities for Remix. This package will provide easy integration between Refine and Remix for both existing projects and new projects without giving up the benefits of Remix.",source:"@site/docs/routing/integrations/remix/index.md",sourceDirName:"routing/integrations/remix",slug:"/routing/integrations/remix/",permalink:"/docs/routing/integrations/remix/",draft:!1,editUrl:"https://github.com/refinedev/refine/tree/master/documentation/docs/routing/integrations/remix/index.md",tags:[],version:"current",lastUpdatedBy:"Ali Emir \u015een",lastUpdatedAt:1712303720,formattedLastUpdatedAt:"Apr 5, 2024",frontMatter:{title:"Remix"},sidebar:"mainSidebar",previous:{title:"Next.js",permalink:"/docs/routing/integrations/next-js/"},next:{title:"useResourceParams",permalink:"/docs/routing/hooks/use-resource-params/"}},p={},d=[{value:"Usage",id:"usage",level:2},{value:"Additional Components",id:"additional-components",level:2},{value:"NavigateToResource",id:"navigatetoresource",level:3},{value:"Properties",id:"properties",level:4},{value:"UnsavedChangesNotifier",id:"unsavedchangesnotifier",level:3},{value:"Properties",id:"properties-1",level:4},{value:"parseTableParams",id:"parsetableparams",level:3},{value:"Authentication",id:"authentication",level:2},{value:"Server Side Authentication with <code>createCookieSessionStorage</code>",id:"server-side-authentication-with-createcookiesessionstorage",level:3},{value:"Server Side Authentication with Self service Cookie",id:"server-side-authentication-with-self-service-cookie",level:3},{value:"Access Control",id:"access-control",level:2},{value:"Server Side",id:"server-side",level:3},{value:"Client Side",id:"client-side",level:3},{value:"FAQ",id:"faq",level:2},{value:"Can I use nested routes?",id:"can-i-use-nested-routes",level:3},{value:"How to make SSR work?",id:"how-to-make-ssr-work",level:3},{value:"How to persist <code>syncWithLocation</code> in SSR?",id:"how-to-persist-syncwithlocation-in-ssr",level:3},{value:"Handling 404s",id:"handling-404s",level:3},{value:"RefineRoutes",id:"refineroutes",level:3},{value:"Example",id:"example",level:2}],c=e=>function(n){return console.warn("Component "+e+" was not imported, exported, or provided by MDXProvider as global scope"),(0,r.yg)("div",n)},g=c("InstallPackagesCommand"),m=c("CreateRefineAppCommand"),h=c("DocThumbsUpDownFeedbackWidget"),y=c("CodeSandboxExample"),f={toc:d},v="wrapper";function x(e){var{components:n}=e,t=i(e,["components"]);return(0,r.yg)(v,a(function(e){for(var n=1;n<arguments.length;n++){var t=null!=arguments[n]?arguments[n]:{},r=Object.keys(t);"function"==typeof Object.getOwnPropertySymbols&&(r=r.concat(Object.getOwnPropertySymbols(t).filter((function(e){return Object.getOwnPropertyDescriptor(t,e).enumerable})))),r.forEach((function(n){o(e,n,t[n])}))}return e}({},f,t),{components:n,mdxType:"MDXLayout"}),(0,r.yg)("p",null,"Refine provides router bindings and utilities for ",(0,r.yg)("a",{parentName:"p",href:"https://remix.run"},"Remix"),". This package will provide easy integration between Refine and ",(0,r.yg)("strong",{parentName:"p"},"Remix")," for both existing projects and new projects without giving up the benefits of ",(0,r.yg)("strong",{parentName:"p"},"Remix"),"."),(0,r.yg)(g,{args:"@refinedev/remix-router",mdxType:"InstallPackagesCommand"}),(0,r.yg)("p",null,"We recommend using ",(0,r.yg)("inlineCode",{parentName:"p"},"create refine-app")," to initialize your Refine projects. It configures the project according to your needs including SSR with Remix!"),(0,r.yg)(m,{args:"-o refine-remix my-refine-remix-app",mdxType:"CreateRefineAppCommand"}),(0,r.yg)("p",null,(0,r.yg)("a",{parentName:"p",href:"/docs/routing/router-provider"},"Refer to the Router Provider documentation for detailed information. ","\u2192")),(0,r.yg)("admonition",{title:"Legacy Router",type:"simple"},(0,r.yg)("p",{parentName:"admonition"},(0,r.yg)("inlineCode",{parentName:"p"},"@refinedev/remix-router")," also exports the legacy router provider and it will be available until the next major version of Refine. It is recommended to use the new router provider instead of the legacy one."),(0,r.yg)("p",{parentName:"admonition"},"If you are using the legacy router provider, it can be imported from ",(0,r.yg)("inlineCode",{parentName:"p"},"@refinedev/remix-router/legacy")," and passed to the ",(0,r.yg)("inlineCode",{parentName:"p"},"legacyRouterProvider")," prop of the ",(0,r.yg)("inlineCode",{parentName:"p"},"Refine")," component.")),(0,r.yg)("h2",{id:"usage"},"Usage"),(0,r.yg)(h,{id:"usage",mdxType:"DocThumbsUpDownFeedbackWidget"},(0,r.yg)("p",null,"We'll use the ",(0,r.yg)("inlineCode",{parentName:"p"},"routerProvider")," from ",(0,r.yg)("inlineCode",{parentName:"p"},"@refinedev/remix-router")," to set up the router bindings for Refine. We'll define the action routes for our resources in the ",(0,r.yg)("inlineCode",{parentName:"p"},"resources")," array and define our routes in ",(0,r.yg)("inlineCode",{parentName:"p"},"app/routes")," directory."),(0,r.yg)("p",null,"We'll create four pages for our resources:"),(0,r.yg)("ul",null,(0,r.yg)("li",{parentName:"ul"},(0,r.yg)("inlineCode",{parentName:"li"},"app/routes/posts._index.tsx")," - List page for posts"),(0,r.yg)("li",{parentName:"ul"},(0,r.yg)("inlineCode",{parentName:"li"},"app/routes/posts.show.$id.tsx")," - Detail page for posts"),(0,r.yg)("li",{parentName:"ul"},(0,r.yg)("inlineCode",{parentName:"li"},"app/routes/categories._index.tsx")," - List page for categories"),(0,r.yg)("li",{parentName:"ul"},(0,r.yg)("inlineCode",{parentName:"li"},"app/routes/categories.show.$id.tsx")," - Detail page for categories")),(0,r.yg)("p",null,"And we'll create one page for the index route and use it to redirect to the ",(0,r.yg)("inlineCode",{parentName:"p"},"posts")," resource:"),(0,r.yg)("ul",null,(0,r.yg)("li",{parentName:"ul"},(0,r.yg)("inlineCode",{parentName:"li"},"app/routes/_index.tsx")," - Index page")),(0,r.yg)("p",null,"Notice that we're using the V2 for route file naming convention for our routes. You can find more information about it in the ",(0,r.yg)("a",{parentName:"p",href:"https://remix.run/docs/en/main/file-conventions/route-files-v2"},"Remix documentation"),"."),(0,r.yg)("p",null,"Currently, to enable that you need to add the following line to your ",(0,r.yg)("inlineCode",{parentName:"p"},"remix.config.js")," file:"),(0,r.yg)("pre",null,(0,r.yg)("code",{parentName:"pre",className:"language-node",metastring:"title=remix.config.js",title:"remix.config.js"},"module.exports = {\n  future: {\n    v2_routeConvention: true,\n  },\n};\n")),(0,r.yg)("p",null,"Let's start with the initialization of the Refine app in the ",(0,r.yg)("inlineCode",{parentName:"p"},"app/root.tsx")," file:"),(0,r.yg)("pre",null,(0,r.yg)("code",{parentName:"pre",className:"language-tsx",metastring:"title=app/root.tsx",title:"app/root.tsx"},'import {\n  Links,\n  LiveReload,\n  Meta,\n  Outlet,\n  Scripts,\n  ScrollRestoration,\n} from "@remix-run/react";\n\nimport { Refine } from "@refinedev/core";\nimport dataProvider from "@refinedev/simple-rest";\nimport routerProvider from "@refinedev/remix-router";\n\nimport { Layout } from "components/Layout";\n\nexport default function App(): JSX.Element {\n  return (\n    <html lang="en">\n      <head>\n        <Meta />\n        <Links />\n      </head>\n      <body>\n        <Refine\n          dataProvider={dataProvider("https://api.fake-rest.refine.dev")}\n          // highlight-next-line\n          routerProvider={routerProvider}\n          resources={[\n            {\n              name: "posts",\n              list: "/posts",\n              show: "/posts/show/:id",\n            },\n            {\n              name: "categories",\n              list: "/categories",\n              show: "/categories/show/:id",\n            },\n          ]}\n        >\n          <Layout>\n            <Outlet />\n          </Layout>\n        </Refine>\n        <ScrollRestoration />\n        <Scripts />\n        <LiveReload />\n      </body>\n    </html>\n  );\n}\n')),(0,r.yg)("admonition",{title:"Good to know",type:"simple"},(0,r.yg)("p",{parentName:"admonition"},"Remix uses the ",(0,r.yg)("inlineCode",{parentName:"p"},"$")," symbol to indicate parameters but Refine uses the colon syntax (",(0,r.yg)("inlineCode",{parentName:"p"},":param"),") for route parameters. This won't cause any problems since Refine only uses the colon syntax as an indicator for route parameters and the communication between Refine and the router is handled by the ",(0,r.yg)("inlineCode",{parentName:"p"},"routerProvider")," prop.")),(0,r.yg)("p",null,"Your action definitions in the resources can contain additional parameters and nested routes. Passing these parameters when navigating to the pages are handled by the current available parameters and the ",(0,r.yg)("inlineCode",{parentName:"p"},"meta")," props of the related hooks and components."),(0,r.yg)("p",null,"Refine supports route parameters defined with ",(0,r.yg)("inlineCode",{parentName:"p"},":param")," syntax. You can use these parameters in your action definitions and create your routes accordingly. For example, if you have a ",(0,r.yg)("inlineCode",{parentName:"p"},"posts")," resource and you want to create a route for the ",(0,r.yg)("inlineCode",{parentName:"p"},"show")," action of a specific post, you can define the ",(0,r.yg)("inlineCode",{parentName:"p"},"show")," action as ",(0,r.yg)("inlineCode",{parentName:"p"},"/posts/show/:id")," and use the ",(0,r.yg)("inlineCode",{parentName:"p"},"id")," parameter in your component."),(0,r.yg)("p",null,"Now we can create our pages in the ",(0,r.yg)("inlineCode",{parentName:"p"},"routes")," directory:"),(0,r.yg)("pre",null,(0,r.yg)("code",{parentName:"pre",className:"language-tsx",metastring:"title=app/routes/posts._index.tsx",title:"app/routes/posts._index.tsx"},'import { useTable } from "@refinedev/core";\nimport { NavLink } from "@remix-run/react";\n\ntype IPost = {\n  id: string;\n  title: string;\n  description: string;\n};\n\nexport default function PostList() {\n  // `posts` resource will be inferred from the route.\n  // Because we\'ve defined `/posts` as the `list` action of the `posts` resource.\n  const {\n    tableQueryResult: { data, isLoading },\n  } = useTable<IPost>();\n\n  const getToPath = useGetToPath();\n\n  const tableData = data?.data;\n\n  return (\n    <div>\n      {isLoading && <p>Loading...</p>}\n      {!isLoading && (\n        <ul>\n          {tableData?.map((post) => (\n            <li key={post.id}>\n              <NavLink\n                to={getToPath({\n                  resource: "categories",\n                  action: "show",\n                  meta: { id: category.id },\n                })}\n              >\n                {post.title}\n              </NavLink>\n            </li>\n          ))}\n        </ul>\n      )}\n    </div>\n  );\n}\n')),(0,r.yg)("pre",null,(0,r.yg)("code",{parentName:"pre",className:"language-tsx",metastring:"title=app/routes/posts.show.$id.tsx",title:"app/routes/posts.show.$id.tsx"},'import { useShow } from "@refinedev/core";\n\ntype IPost = {\n    id: string;\n    title: string;\n    description: string;\n}\n\nexport default function PostShow() {\n    // `posts` resource and the `id` will be inferred from the route.\n    // Because we\'ve defined `/posts/show/:id` as the `show` action of the `posts` resource.\n    const { queryResult: { data, isLoading } } = useShow<IPost>();\n\n    const postData = data?.data;\n\n    return (\n        <div>\n            {isLoading && <p>Loading...</p>}\n            {!isLoading && (\n                <h1>{postData?.title}</h1>\n                <p>{postData?.description}</p>\n            )}\n        </div>\n    );\n}\n')),(0,r.yg)("pre",null,(0,r.yg)("code",{parentName:"pre",className:"language-tsx",metastring:"title=app/routes/categories._index.tsx",title:"app/routes/categories._index.tsx"},'import { useTable, getToPath } from "@refinedev/core";\nimport { NavLink } from "@remix-run/react";\n\ntype ICategory = {\n  id: string;\n  label: string;\n};\n\nexport default function CategoryList() {\n  // `categories` resource will be inferred from the route.\n  // Because we\'ve defined `/categories` as the `list` action of the `categories` resource.\n  const {\n    tableQueryResult: { data, isLoading },\n  } = useTable<ICategory>();\n\n  const getToPath = useGetToPath();\n\n  const tableData = data?.data;\n\n  return (\n    <div>\n      {isLoading && <p>Loading...</p>}\n      {!isLoading && (\n        <ul>\n          {tableData?.map((category) => (\n            <li key={category.id}>\n              <NavLink\n                to={getToPath({\n                  resource: "categories",\n                  action: "show",\n                  meta: { id: category.id },\n                })}\n              >\n                {category.label}\n              </NavLink>\n            </li>\n          ))}\n        </ul>\n      )}\n    </div>\n  );\n}\n')),(0,r.yg)("pre",null,(0,r.yg)("code",{parentName:"pre",className:"language-tsx",metastring:"title=app/routes/categories.show.$id.tsx",title:"app/routes/categories.show.$id.tsx"},'import { useShow } from "@refinedev/core";\n\ntype ICategory = {\n  id: string;\n  label: string;\n};\n\nexport default function CategoryShow() {\n  // `categories` resource and the `id` will be inferred from the route.\n  // Because we\'ve defined `/categories/show/:id` as the `show` action of the `categories` resource.\n  const {\n    queryResult: { data, isLoading },\n  } = useShow<ICategory>();\n\n  const categoryData = data?.data;\n\n  return (\n    <div>\n      <h1>{categoryData?.label}</h1>\n    </div>\n  );\n}\n')),(0,r.yg)("p",null,"Now, we'll use ",(0,r.yg)("a",{parentName:"p",href:"#navigatetoresource"},(0,r.yg)("inlineCode",{parentName:"a"},"NavigateToResource"))," component to redirect to the ",(0,r.yg)("inlineCode",{parentName:"p"},"posts")," resource when the user visits the home page."),(0,r.yg)("p",null,"Even though we're using the ",(0,r.yg)("inlineCode",{parentName:"p"},"NavigateToResource")," component, when using Remix it's better to handle such redirect operations in the server side rather than the client side. You can use the ",(0,r.yg)("inlineCode",{parentName:"p"},"loader")," function to redirect the user to the ",(0,r.yg)("inlineCode",{parentName:"p"},"/posts"),"."),(0,r.yg)("pre",null,(0,r.yg)("code",{parentName:"pre",className:"language-tsx",metastring:"title=app/routes/_index.tsx",title:"app/routes/_index.tsx"},'import { NavigateToResource } from "@refinedev/remix-router";\n\nexport default function Index() {\n  return <NavigateToResource />;\n}\n'))),(0,r.yg)("h2",{id:"additional-components"},"Additional Components"),(0,r.yg)(h,{id:"additional-components",mdxType:"DocThumbsUpDownFeedbackWidget"},(0,r.yg)("p",null,(0,r.yg)("inlineCode",{parentName:"p"},"@refinedev/remix-router")," package also includes some additional components that can be useful in some cases.")),(0,r.yg)("h3",{id:"navigatetoresource"},"NavigateToResource"),(0,r.yg)(h,{id:"navigatetoresource",mdxType:"DocThumbsUpDownFeedbackWidget"},(0,r.yg)("p",null,"A basic component to navigate to a resource page. It is useful when you want to navigate to a resource page at the index route of your app."),(0,r.yg)("pre",null,(0,r.yg)("code",{parentName:"pre",className:"language-tsx",metastring:"title=app/routes/index.tsx",title:"app/routes/index.tsx"},'import { NavigateToResource } from "@refinedev/remix-router";\n\nexport default function IndexPage() {\n  return <NavigateToResource />;\n}\n'))),(0,r.yg)("h4",{id:"properties"},"Properties"),(0,r.yg)(h,{id:"properties",mdxType:"DocThumbsUpDownFeedbackWidget"},(0,r.yg)("p",null,(0,r.yg)("inlineCode",{parentName:"p"},"resource")," (optional) - The name of the resource to navigate to. It will redirect to the first ",(0,r.yg)("inlineCode",{parentName:"p"},"list")," route in the ",(0,r.yg)("inlineCode",{parentName:"p"},"resources")," array if not provided."),(0,r.yg)("p",null,(0,r.yg)("inlineCode",{parentName:"p"},"meta")," (optional) - The meta object to use if the route has parameters in it. The parameters in the current location will also be used to compose the route but ",(0,r.yg)("inlineCode",{parentName:"p"},"meta")," will take precedence.")),(0,r.yg)("h3",{id:"unsavedchangesnotifier"},"UnsavedChangesNotifier"),(0,r.yg)(h,{id:"unsavedchangesnotifier",mdxType:"DocThumbsUpDownFeedbackWidget"},(0,r.yg)("p",null,"This component enables the ",(0,r.yg)("inlineCode",{parentName:"p"},"warnWhenUnsavedChanges")," feature of Refine. It will show a warning message when user tries to navigate away from the current page without saving the changes. Also checks for ",(0,r.yg)("inlineCode",{parentName:"p"},"beforeunload")," event to warn the user when they try to close the browser tab or window."),(0,r.yg)("p",null,"Place this component inside the ",(0,r.yg)("inlineCode",{parentName:"p"},"<Refine>")," components children to enable this feature."),(0,r.yg)("pre",null,(0,r.yg)("code",{parentName:"pre",className:"language-tsx",metastring:"title=app/root.tsx",title:"app/root.tsx"},'import { Refine } from "@refinedev/core";\nimport { UnsavedChangesNotifier } from "@refinedev/remix-router";\n\nexport default function App(): JSX.Element {\n  return (\n    <Refine\n    /* ... */\n    >\n      <Outlet />\n      {/* highlight-next-line */}\n      <UnsavedChangesNotifier />\n    </Refine>\n  );\n}\n'))),(0,r.yg)("h4",{id:"properties-1"},"Properties"),(0,r.yg)(h,{id:"properties-1",mdxType:"DocThumbsUpDownFeedbackWidget"},(0,r.yg)("p",null,(0,r.yg)("inlineCode",{parentName:"p"},"translationKey")," (optional) - The translation key for the warning message. Default value is ",(0,r.yg)("inlineCode",{parentName:"p"},"warnWhenUnsavedChanges"),". Useful when you use an i18n provider."),(0,r.yg)("p",null,(0,r.yg)("inlineCode",{parentName:"p"},"message")," (optional) - The warning message. Default value is ",(0,r.yg)("inlineCode",{parentName:"p"},"Are you sure you want to leave? You have unsaved changes.")," Useful when you don't use an i18n provider.")),(0,r.yg)("h3",{id:"parsetableparams"},"parseTableParams"),(0,r.yg)(h,{id:"parsetableparams",mdxType:"DocThumbsUpDownFeedbackWidget"},(0,r.yg)("p",null,"This function can be used to parse the query parameters of a table page. It can be useful when you want to use the query parameters in your server side functions (",(0,r.yg)("inlineCode",{parentName:"p"},"loader"),") to fetch the data such as ",(0,r.yg)("a",{parentName:"p",href:"#how-to-persist-syncwithlocation-in-ssr"},"persisting the table state"))),(0,r.yg)("h2",{id:"authentication"},"Authentication"),(0,r.yg)(h,{id:"authentication",mdxType:"DocThumbsUpDownFeedbackWidget"},(0,r.yg)("p",null,"In Remix you can achieve authentication control in multiple ways;"),(0,r.yg)("p",null,"On the client-side ",(0,r.yg)("a",{parentName:"p",href:"/docs/authentication/components/authenticated"},(0,r.yg)("inlineCode",{parentName:"a"},"Authenticated"))," component from ",(0,r.yg)("inlineCode",{parentName:"p"},"@refinedev/core")," can be used to protect your pages from unauthenticated access."),(0,r.yg)("p",null,"On the server-side ",(0,r.yg)("inlineCode",{parentName:"p"},"authProvider"),"'s ",(0,r.yg)("inlineCode",{parentName:"p"},"check")," function inside server side functions (",(0,r.yg)("inlineCode",{parentName:"p"},"loader"),") to redirect unauthorized users to other pages using ",(0,r.yg)("inlineCode",{parentName:"p"},"redirect")," from ",(0,r.yg)("inlineCode",{parentName:"p"},"@remix-run/node"),"."),(0,r.yg)("admonition",{title:"Implementation Tips",type:"simple"},(0,r.yg)("p",{parentName:"admonition"},"For page level access control, server-side approach is recommended."))),(0,r.yg)("h3",{id:"server-side-authentication-with-createcookiesessionstorage"},"Server Side Authentication with ",(0,r.yg)("inlineCode",{parentName:"h3"},"createCookieSessionStorage")),(0,r.yg)(h,{id:"server-side-authentication-with-createcookiesessionstorage",mdxType:"DocThumbsUpDownFeedbackWidget"},(0,r.yg)("p",null,"First, let's create our ",(0,r.yg)("inlineCode",{parentName:"p"},"AuthProvider"),". For more information on ",(0,r.yg)("inlineCode",{parentName:"p"},"AuthProvider"),", visit our ",(0,r.yg)("a",{parentName:"p",href:"/docs/authentication/auth-provider"},"AuthProvider documentation"),"."),(0,r.yg)("pre",null,(0,r.yg)("code",{parentName:"pre",className:"language-tsx",metastring:'title="app/authProvider.ts"',title:'"app/authProvider.ts"'},'import { AuthProvider } from "@refinedev/core";\n\nconst mockUsers = [\n  {\n    username: "admin",\n    roles: ["admin"],\n  },\n  {\n    username: "editor",\n    roles: ["editor"],\n  },\n];\n\nexport const authProvider: AuthProvider = {\n  login: async ({ username, password, remember }) => {\n    // Suppose we actually send a request to the back end here.\n    const user = mockUsers.find((item) => item.username === username);\n\n    if (user) {\n      return {\n        success: true,\n        redirectTo: "/",\n      };\n    }\n\n    return {\n      success: false,\n      error: {\n        message: "Login failed",\n        name: "Invalid email or password",\n      },\n    };\n  },\n  logout: async () => {\n    return {\n      success: true,\n      redirectTo: "/",\n    };\n  },\n  onError: async (error) => {\n    if (error && error.statusCode === 401) {\n      return {\n        logout: true,\n        redirectTo: "/login",\n      };\n    }\n\n    return {};\n  },\n  check: async ({ request, storage }) => {\n    const session = await storage.getSession(request.headers.get("Cookie"));\n\n    const user = session.get("user");\n\n    if (!user) {\n      return {\n        authenticated: false,\n        logout: true,\n        redirectTo: "/login",\n      };\n    }\n    return {\n      authenticated: true,\n    };\n  },\n  getPermissions: async () => {\n    return null;\n  },\n  getIdentity: async () => {\n    return null;\n  },\n};\n')),(0,r.yg)("p",null,"Next, let's create the ",(0,r.yg)("inlineCode",{parentName:"p"},"app/session.server.ts")," file as mentioned in the ",(0,r.yg)("a",{parentName:"p",href:"https://remix.run/docs/en/v1/tutorials/jokes#authentication"},(0,r.yg)("inlineCode",{parentName:"a"},"Jokes App"))," tutorial"),(0,r.yg)("pre",null,(0,r.yg)("code",{parentName:"pre",className:"language-tsx",metastring:'title="app/session.server.ts"',title:'"app/session.server.ts"'},'import { createCookieSessionStorage, redirect } from "@remix-run/node";\nimport { authProvider } from "./authProvider";\n\ntype LoginForm = {\n  username: string;\n  password: string;\n};\n\n// normally you want this to be env variable\nconst sessionSecret = "SUPER_SECRET_SESSION"; //process.env.SESSION_SECRET;\n\nif (!sessionSecret) {\n  throw new Error("SESSION_SECRET must be set");\n}\n\nconst storage = createCookieSessionStorage({\n  cookie: {\n    name: "RJ_session",\n    // normally you want this to be `secure: true`\n    // but that doesn\'t work on localhost for Safari\n    // https://web.dev/when-to-use-local-https/\n    secure: process.env.NODE_ENV === "production",\n    secrets: [sessionSecret],\n    sameSite: "lax",\n    path: "/",\n    maxAge: 60 * 60 * 24 * 30,\n    httpOnly: true,\n  },\n});\n\nexport async function login({ username, password }: LoginForm) {\n  try {\n    const user = await authProvider.login({ username, password });\n    if (user) {\n      return { user };\n    }\n  } catch (error) {\n    return error;\n  }\n}\n\nexport async function requireUserId(\n  request: Request,\n  redirectTo: string = new URL(request.url).pathname,\n) {\n  try {\n    const user = await authProvider.check?.({ request, storage });\n    return user;\n  } catch (error) {\n    const searchParams = new URLSearchParams([["to", redirectTo]]);\n    throw redirect(`/login?${searchParams}`);\n  }\n}\n\nexport async function createUserSession(user: object, redirectTo: string) {\n  const session = await storage.getSession();\n  session.set("user", { ...user });\n  return redirect(redirectTo, {\n    headers: {\n      "Set-Cookie": await storage.commitSession(session),\n    },\n  });\n}\n\nexport async function logout(request: Request) {\n  const session = await storage.getSession(request.headers.get("Cookie"));\n  return redirect("/login", {\n    headers: {\n      "Set-Cookie": await storage.destroySession(session),\n    },\n  });\n}\n')),(0,r.yg)("p",null,"In the ",(0,r.yg)("inlineCode",{parentName:"p"},"login")," and ",(0,r.yg)("inlineCode",{parentName:"p"},"requireUserId")," functions, we call the corresponding functions of our ",(0,r.yg)("inlineCode",{parentName:"p"},"AuthProvider"),"."),(0,r.yg)("p",null,"Now let's create our login page"),(0,r.yg)("pre",null,(0,r.yg)("code",{parentName:"pre",className:"language-tsx",metastring:'title="app/routes/login.tsx"',title:'"app/routes/login.tsx"'},'import React from "react";\nimport { useTranslate } from "@refinedev/core";\n\nimport { login, createUserSession } from "~/session.server";\nimport { ActionFunction } from "@remix-run/node";\nimport { useSearchParams } from "@remix-run/react";\n\nexport interface ILoginForm {\n  username: string;\n  password: string;\n}\n\nconst LoginPage: React.FC = () => {\n  const translate = useTranslate();\n  const [searchParams] = useSearchParams();\n\n  return (\n    <>\n      <h1>{translate("pages.login.title", "Sign in your account")}</h1>\n      <form method="post">\n        <input\n          type="hidden"\n          name="redirectTo"\n          value={searchParams.get("to") ?? undefined}\n        />\n        <table>\n          <tbody>\n            <tr>\n              <td>\n                {translate("pages.login.username", undefined, "username")}:\n              </td>\n              <td>\n                <input\n                  name="username"\n                  type="text"\n                  size={20}\n                  autoCorrect="off"\n                  spellCheck={false}\n                  autoCapitalize="off"\n                  autoFocus\n                  required\n                />\n              </td>\n            </tr>\n            <tr>\n              <td>\n                {translate("pages.login.password", undefined, "password")}:\n              </td>\n              <td>\n                <input type="password" name="password" required size={20} />\n              </td>\n            </tr>\n          </tbody>\n        </table>\n        <br />\n        <input type="submit" value="login" />\n      </form>\n    </>\n  );\n};\n\nexport const action: ActionFunction = async ({ request }) => {\n  const form = await request.formData();\n  const username = form.get("username") as string;\n  const password = form.get("password") as string;\n  const redirectTo = form.get("redirectTo") || "/";\n  // highlight-start\n  const user = await login({ username, password });\n  if (!user) {\n    return null;\n  }\n\n  return createUserSession(user as any, redirectTo as string);\n  // highlight-end\n};\n\nexport default LoginPage;\n')),(0,r.yg)("p",null,"Yeeyy! Now our users can login! \ud83c\udf89"),(0,r.yg)("p",null,"Remember, actions and loaders run on the server, so console.log calls you put in those you can't see in the browser console. Those will show up in the terminal window you're running your server in."),(0,r.yg)("p",null,"We can call the ",(0,r.yg)("inlineCode",{parentName:"p"},"requireUserId")," function on our routes where we want the authentication check done."),(0,r.yg)("pre",null,(0,r.yg)("code",{parentName:"pre",className:"language-tsx"},'import { json, LoaderFunction } from "@remix-run/node";\n//highlight-next-line\nimport { requireUserId } from "~/session.server";\n\nexport const loader: LoaderFunction = async ({ params, request, context }) => {\n  //highlight-next-line\n  await requireUserId(request);\n\n  return json({});\n};\n')),(0,r.yg)("p",null,"Finally, let's make sure our users can log out. For this, we create a routes for ",(0,r.yg)("inlineCode",{parentName:"p"},"/logout"),"."),(0,r.yg)("pre",null,(0,r.yg)("code",{parentName:"pre",className:"language-tsx",metastring:'title="/app/routes/logout.tsx"',title:'"/app/routes/logout.tsx"'},'import type { LoaderFunction } from "@remix-run/node";\n\nimport { logout } from "~/session.server";\n\nexport const loader: LoaderFunction = async ({ request }) => {\n  return await logout(request);\n};\n'))),(0,r.yg)("h3",{id:"server-side-authentication-with-self-service-cookie"},"Server Side Authentication with Self service Cookie"),(0,r.yg)(h,{id:"server-side-authentication-with-self-service-cookie",mdxType:"DocThumbsUpDownFeedbackWidget"},(0,r.yg)("p",null,"First, let's install the ",(0,r.yg)("inlineCode",{parentName:"p"},"js-cookie")," and ",(0,r.yg)("inlineCode",{parentName:"p"},"cookie")," packages in our project."),(0,r.yg)(g,{args:"js-cookie cookie",mdxType:"InstallPackagesCommand"}),(0,r.yg)(g,{args:"-D @types/js-cookie",mdxType:"InstallPackagesCommand"}),(0,r.yg)("p",null,"We will set/destroy cookies in the ",(0,r.yg)("inlineCode",{parentName:"p"},"login"),", ",(0,r.yg)("inlineCode",{parentName:"p"},"logout")," and ",(0,r.yg)("inlineCode",{parentName:"p"},"check")," functions of our ",(0,r.yg)("inlineCode",{parentName:"p"},"AuthProvider"),"."),(0,r.yg)("pre",null,(0,r.yg)("code",{parentName:"pre",className:"language-tsx",metastring:'title="app/authProvider.ts"',title:'"app/authProvider.ts"'},'import { AuthProvider } from "@refinedev/core";\n// highlight-start\nimport Cookies from "js-cookie";\nimport * as cookie from "cookie";\n// highlight-end\n\nconst mockUsers = [\n  {\n    username: "admin",\n    roles: ["admin"],\n  },\n  {\n    username: "editor",\n    roles: ["editor"],\n  },\n];\n\n// highlight-next-line\nconst COOKIE_NAME = "user";\n\nexport const authProvider: AuthProvider = {\n  login: ({ username, password, remember }) => {\n    // Suppose we actually send a request to the back end here.\n    const user = mockUsers.find((item) => item.username === username);\n\n    if (user) {\n      // highlight-next-line\n      Cookies.set(COOKIE_NAME, JSON.stringify(user));\n      return {\n        success: true,\n      };\n    }\n\n    return {\n      success: false,\n    };\n  },\n  logout: () => {\n    // highlight-next-line\n    Cookies.remove(COOKIE_NAME);\n\n    return {\n      success: true,\n      redirectTo: "/login",\n    };\n  },\n  onError: (error) => {\n    if (error && error.statusCode === 401) {\n      return {\n        error: new Error("Unauthorized"),\n        logout: true,\n        redirectTo: "/login",\n      };\n    }\n\n    return {};\n  },\n  check: async (context) => {\n    // highlight-start\n    let user = undefined;\n    if (context) {\n      // for SSR\n      const { request } = context;\n      const parsedCookie = cookie.parse(request.headers.get("Cookie"));\n      user = parsedCookie[COOKIE_NAME];\n    } else {\n      // for CSR\n      const parsedCookie = Cookies.get(COOKIE_NAME);\n      user = parsedCookie ? JSON.parse(parsedCookie) : undefined;\n    }\n    // highlight-end\n\n    if (!user) {\n      return {\n        authenticated: false,\n        error: {\n          message: "Check failed",\n          name: "Unauthorized",\n        },\n        logout: true,\n        redirectTo: "/login",\n      };\n    }\n\n    return {\n      authenticated: true,\n    };\n  },\n  getPermissions: async () => {\n    return null;\n  },\n  getIdentity: async () => {\n    return null;\n  },\n};\n')),(0,r.yg)("p",null,"Tadaa! that's all! \ud83c\udf89"),(0,r.yg)("p",null,"Now, we can check the authentication in loaders of our routes."),(0,r.yg)("pre",null,(0,r.yg)("code",{parentName:"pre",className:"language-tsx",metastring:'title="app/routes/_index.tsx"',title:'"app/routes/_index.tsx"'},'import { json, LoaderFunction } from "@remix-run/node";\nimport { authProvider } from "~/authProvider";\n\nexport const loader: LoaderFunction = async ({ params, request, context }) => {\n  // We\'ve handled the SSR case in our `check` function by sending the `request` as parameter.\n  const { authenticated } = await authProvider.check(request);\n\n  if (!authenticated) {\n    return json({}, { status: 401 });\n  }\n\n  return null;\n};\n')),(0,r.yg)("p",null,"This needs to be done for all the routes that we want to protect.")),(0,r.yg)("h2",{id:"access-control"},"Access Control"),(0,r.yg)(h,{id:"access-control",mdxType:"DocThumbsUpDownFeedbackWidget"},(0,r.yg)("p",null,"There are two ways to do Server Side Authentication with Remix. You can choose one of the two methods according to your use case.")),(0,r.yg)("h3",{id:"server-side"},"Server Side"),(0,r.yg)(h,{id:"server-side",mdxType:"DocThumbsUpDownFeedbackWidget"},(0,r.yg)("p",null,"On the server-side ",(0,r.yg)("inlineCode",{parentName:"p"},"accessControlProvider"),"'s ",(0,r.yg)("inlineCode",{parentName:"p"},"can")," function inside server side functions (",(0,r.yg)("inlineCode",{parentName:"p"},"loader"),") to redirect unauthorized users to other pages using ",(0,r.yg)("inlineCode",{parentName:"p"},"redirect")," from ",(0,r.yg)("inlineCode",{parentName:"p"},"@remix-run/node"),"."),(0,r.yg)("p",null,"First, let's build our ",(0,r.yg)("a",{parentName:"p",href:"/docs/authorization/access-control-provider"},"AccessControlProvider")),(0,r.yg)("pre",null,(0,r.yg)("code",{parentName:"pre",className:"language-tsx",metastring:'title="app/acccessControlProvider.ts"',title:'"app/acccessControlProvider.ts"'},'export const accessControlProvider = {\n  can: async ({ resource, action, params }) => {\n    if (resource === "posts" && action === "edit") {\n      return {\n        can: false,\n        reason: "Unauthorized",\n      };\n    }\n\n    return { can: true };\n  },\n};\n')),(0,r.yg)("p",null,"You can also access resource object directly."),(0,r.yg)("pre",null,(0,r.yg)("code",{parentName:"pre",className:"language-tsx"},'const resourceName = params?.resource?.name;\nconst anyUsefulMeta = params?.resource?.meta?.yourUsefulMeta;\n\nexport const accessControlProvider = {\n  can: async ({ resource, action, params }) => {\n    if (\n      resourceName === "posts" &&\n      anyUsefulMeta === true &&\n      action === "edit"\n    ) {\n      return {\n        can: false,\n        reason: "Unauthorized",\n      };\n    }\n  },\n};\n')),(0,r.yg)("p",null,"Then, let's create our posts route."),(0,r.yg)("pre",null,(0,r.yg)("code",{parentName:"pre",className:"language-tsx",metastring:'title="app/routes/_protected.posts._index.tsx"',title:'"app/routes/_protected.posts._index.tsx"'},'import { useLoaderData } from "@remix-run/react";\nimport { json, LoaderFunctionArgs } from "@remix-run/node";\nimport dataProvider from "@refinedev/simple-rest";\n\nimport { IPost } from "../interfaces";\nimport { API_URL } from "~/constants";\nimport { accessControlProvider } from "../accessControlProvider";\n\nconst PostList: React.FC = () => {\n  const { initialData } = useLoaderData<typeof loader>();\n\n  return <>{/* ... */}</>;\n};\n\nexport default PostList;\n\nexport async function loader({ request }: LoaderFunctionArgs) {\n  const can = accessControlProvider.can({\n    resource: "posts",\n    action: "list",\n  });\n\n  if (!can) {\n    return json({}, { status: 403 });\n  }\n\n  const data = await dataProvider(API_URL).getList<IPost>({\n    resource: "posts",\n  });\n\n  return json({ initialData: data });\n}\n')),(0,r.yg)("p",null,"Tadaa! that's all! \ud83c\udf89")),(0,r.yg)("h3",{id:"client-side"},"Client Side"),(0,r.yg)(h,{id:"client-side",mdxType:"DocThumbsUpDownFeedbackWidget"},(0,r.yg)("p",null,"For client-side, you can wrap your pages with ",(0,r.yg)("a",{parentName:"p",href:"/docs/authorization/components/can-access"},(0,r.yg)("inlineCode",{parentName:"a"},"CanAccess"))," component from ",(0,r.yg)("inlineCode",{parentName:"p"},"@refinedev/core")," to protect your pages from unauthorized access."),(0,r.yg)("pre",null,(0,r.yg)("code",{parentName:"pre",className:"language-tsx"},'import { CanAccess } from "@refinedev/core";\n\nexport const MyPage = () => (\n  <CanAccess>\n    <div>{/* ... */}</div>\n  </CanAccess>\n);\n'))),(0,r.yg)("h2",{id:"faq"},"FAQ"),(0,r.yg)("h3",{id:"can-i-use-nested-routes"},"Can I use nested routes?"),(0,r.yg)(h,{id:"can-i-use-nested-routes",mdxType:"DocThumbsUpDownFeedbackWidget"},(0,r.yg)("p",null,"Yes, you can use nested routes in your app. Refine will match the routes depending on how you define the action paths in your resources. Additional parameters and nesting is supported. Refine will not limit you and your router in route configuration, all you need to do is to pass the appropriate path to the related resource and the action in the ",(0,r.yg)("inlineCode",{parentName:"p"},"resources")," array (This is also optional but recommended due to the features it provides)."),(0,r.yg)("p",null,"You can use ",(0,r.yg)("inlineCode",{parentName:"p"},":param")," syntax to define parameters in your routes.")),(0,r.yg)("h3",{id:"how-to-make-ssr-work"},"How to make SSR work?"),(0,r.yg)(h,{id:"how-to-make-ssr-work",mdxType:"DocThumbsUpDownFeedbackWidget"},(0,r.yg)("p",null,"You can always use the methods provided from the ",(0,r.yg)("inlineCode",{parentName:"p"},"dataProvider")," to fetch data in your pages. To do this, you can use ",(0,r.yg)("inlineCode",{parentName:"p"},"loader")," function and pass the data to your page as a prop."),(0,r.yg)("p",null,"All you need to do is to pass the data as the ",(0,r.yg)("inlineCode",{parentName:"p"},"initialData")," to your data hooks using the ",(0,r.yg)("inlineCode",{parentName:"p"},"queryOptions")," prop."),(0,r.yg)("pre",null,(0,r.yg)("code",{parentName:"pre",className:"language-tsx"},'import { useList } from "@refinedev/core";\nimport { useLoaderData } from "@remix-run/react";\n\nimport { dataProvider } from "src/providers";\n\ntype IPost = {\n  id: number;\n  title: string;\n  description: string;\n};\n\nexport async function loader() {\n  const { data } = await dataProvider.getList<IPost>("posts", {\n    pagination: {\n      page: 1,\n      perPage: 10,\n    },\n  });\n\n  return json(data);\n}\n\nexport default function Posts() {\n  const initialPosts = useLoaderData<typeof loader>();\n\n  const {\n    tableQueryResult: { data },\n  } = useTable<IPost>({\n    queryOptions: {\n      initialData: initialPosts,\n    },\n  });\n\n  return <>{/* ... */}</>;\n}\n'))),(0,r.yg)("h3",{id:"how-to-persist-syncwithlocation-in-ssr"},"How to persist ",(0,r.yg)("inlineCode",{parentName:"h3"},"syncWithLocation")," in SSR?"),(0,r.yg)(h,{id:"how-to-persist-syncwithlocation-in-ssr",mdxType:"DocThumbsUpDownFeedbackWidget"},(0,r.yg)("p",null,"If ",(0,r.yg)("inlineCode",{parentName:"p"},"syncWithLocation")," is enabled, query parameters must be handled while doing SSR."),(0,r.yg)("pre",null,(0,r.yg)("code",{parentName:"pre",className:"language-tsx"},'import { json, LoaderFunction } from "@remix-run/node";\n// highlight-next-line\nimport { parseTableParams } from "@refinedev/remix-router";\nimport dataProvider from "@refinedev/simple-rest";\n\nconst API_URL = "https://api.fake-rest.refine.dev";\n\nexport const loader: LoaderFunction = async ({ params, request }) => {\n  const { resource } = params;\n  const url = new URL(request.url);\n\n  // highlight-next-line\n  const tableParams = parseTableParams(url.search);\n\n  try {\n    const data = await dataProvider(API_URL).getList({\n      resource: resource as string,\n      ...tableParams, // this includes `filters`, `sorters` and `pagination`\n    });\n\n    return json({ initialData: data });\n  } catch (error) {\n    return json({});\n  }\n};\n\nexport default function MyListRoute() {\n  return <>{/* ... */}</>;\n}\n')),(0,r.yg)("p",null,(0,r.yg)("inlineCode",{parentName:"p"},"parseTableParams")," parses the query string and returns query parameters(",(0,r.yg)("a",{parentName:"p",href:"/docs/core/interface-references/#crudfilters"},"refer here for their interfaces"),"). They can be directly used for ",(0,r.yg)("inlineCode",{parentName:"p"},"dataProvider")," methods that accept them.")),(0,r.yg)("h3",{id:"handling-404s"},"Handling 404s"),(0,r.yg)(h,{id:"handling-404s",mdxType:"DocThumbsUpDownFeedbackWidget"},(0,r.yg)("p",null,"In the earlier versions of Refine, if ",(0,r.yg)("inlineCode",{parentName:"p"},"authProvider")," was defined, we've redirected the users to the ",(0,r.yg)("inlineCode",{parentName:"p"},"/login")," route even with the 404s and 404 pages were only available to the authenticated users. Now, the routes are handled by the users, so you can handle the 404s however you like."),(0,r.yg)("p",null,"In remix, you can use a splat ($) route to handle the 404s. Check out the ",(0,r.yg)("a",{parentName:"p",href:"https://remix.run/docs/en/main/guides/routing#md-splats"},"remix docs")," for more information."),(0,r.yg)("p",null,(0,r.yg)("strong",{parentName:"p"},"Using ",(0,r.yg)("inlineCode",{parentName:"strong"},"loader"))),(0,r.yg)("pre",null,(0,r.yg)("code",{parentName:"pre",className:"language-tsx",metastring:'title="app/routes/$.tsx"',title:'"app/routes/$.tsx"'},'import { json, LoaderFunction } from "@remix-run/node";\n\nexport const loader: LoaderFunction = async ({ params, request, context }) => {\n  return json({}, { status: 404 });\n};\n')),(0,r.yg)("p",null,(0,r.yg)("strong",{parentName:"p"},"Using ",(0,r.yg)("inlineCode",{parentName:"strong"},"Authenticated"))),(0,r.yg)("pre",null,(0,r.yg)("code",{parentName:"pre",className:"language-tsx",metastring:'title="app/routes/$.tsx"',title:'"app/routes/$.tsx"'},'import { Authenticated } from "@refinedev/core";\n\nexport default function NotFound() {\n  return (\n    <Authenticated>\n      <div>I\'m the 404 page for the authenticated users.</div>\n    </Authenticated>\n  );\n}\n'))),(0,r.yg)("h3",{id:"refineroutes"},"RefineRoutes"),(0,r.yg)(h,{id:"refineroutes",mdxType:"DocThumbsUpDownFeedbackWidget"},(0,r.yg)("p",null,"While this may work for the simple cases, it is not recommended to use this component. Defining your routes separately will give you more control over your routes and will allow you to use the full potential of your router."),(0,r.yg)("p",null,"This component can be used to render the matching route in your resources by using the ",(0,r.yg)("inlineCode",{parentName:"p"},"resources")," prop. It will only take effect if the action properties in the resource definitions are assigned to components or objects with ",(0,r.yg)("inlineCode",{parentName:"p"},"component")," property."),(0,r.yg)("p",null,"It will render the component for the matching route and pass it as a ",(0,r.yg)("inlineCode",{parentName:"p"},"JSX.Element")," to the ",(0,r.yg)("inlineCode",{parentName:"p"},"children")," function. You can use this to render your components in a single catch-all route. If there's no matching route ",(0,r.yg)("inlineCode",{parentName:"p"},"undefined")," will be passed to the ",(0,r.yg)("inlineCode",{parentName:"p"},"children")," function. In this case, you can render an error page or redirect the user to another page."),(0,r.yg)("p",null,"We'll define our resources in the ",(0,r.yg)("inlineCode",{parentName:"p"},"<Refine>")," component:"),(0,r.yg)("pre",null,(0,r.yg)("code",{parentName:"pre",className:"language-tsx",metastring:"title=app/root.tsx",title:"app/root.tsx"},'return (\n  <Refine\n    resources={[\n      {\n        name: "posts",\n        list: "/posts",\n        show: "/posts/show/:id",\n      },\n      {\n        name: "categories",\n        list: "/categories",\n      },\n    ]}\n  >\n    {/* ... */}\n  </Refine>\n);\n')),(0,r.yg)("p",null,"Then, we'll create a catch-all route to render the matching route in our resources:"),(0,r.yg)("pre",null,(0,r.yg)("code",{parentName:"pre",className:"language-tsx",metastring:"title=app/routes/$.tsx",title:"app/routes/$.tsx"},'import { RefineRoutes } from "@refinedev/remix-router";\n\nimport { ErrorPage } from "components/error";\n\nexport default function CatchAll() {\n  return (\n    <RefineRoutes>\n      {(matchingRoute) => {\n        if (matchingRoute) {\n          return { matchingRoute };\n        }\n\n        return <ErrorPage />;\n      }}\n    </RefineRoutes>\n  );\n}\n')),(0,r.yg)("p",null,"When components are used to define the resource actions, default paths will be used. You can override the default paths by assigning an object with ",(0,r.yg)("inlineCode",{parentName:"p"},"component")," and ",(0,r.yg)("inlineCode",{parentName:"p"},"path")," properties to the action properties."),(0,r.yg)("p",null,"Default paths are:"),(0,r.yg)("ul",null,(0,r.yg)("li",{parentName:"ul"},(0,r.yg)("inlineCode",{parentName:"li"},"list"),": ",(0,r.yg)("inlineCode",{parentName:"li"},"/resources")),(0,r.yg)("li",{parentName:"ul"},(0,r.yg)("inlineCode",{parentName:"li"},"create"),": ",(0,r.yg)("inlineCode",{parentName:"li"},"/resources/create")),(0,r.yg)("li",{parentName:"ul"},(0,r.yg)("inlineCode",{parentName:"li"},"edit"),": ",(0,r.yg)("inlineCode",{parentName:"li"},"/resources/edit/:id")),(0,r.yg)("li",{parentName:"ul"},(0,r.yg)("inlineCode",{parentName:"li"},"show"),": ",(0,r.yg)("inlineCode",{parentName:"li"},"/resources/show/:id")))),(0,r.yg)("h2",{id:"example"},"Example"),(0,r.yg)(h,{id:"example",mdxType:"DocThumbsUpDownFeedbackWidget"},(0,r.yg)(y,{path:"with-remix-antd",mdxType:"CodeSandboxExample"}),(0,r.yg)(y,{path:"with-remix-headless",hideSandbox:!0,mdxType:"CodeSandboxExample"})))}x.isMDXComponent=!0}}]);