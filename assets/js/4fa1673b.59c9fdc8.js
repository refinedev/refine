"use strict";(self.webpackChunkdocumentation=self.webpackChunkdocumentation||[]).push([[45141],{58860:(e,n,t)=>{t.d(n,{xA:()=>m,yg:()=>u});var o=t(37953);function a(e,n,t){return n in e?Object.defineProperty(e,n,{value:t,enumerable:!0,configurable:!0,writable:!0}):e[n]=t,e}function i(e,n){var t=Object.keys(e);if(Object.getOwnPropertySymbols){var o=Object.getOwnPropertySymbols(e);n&&(o=o.filter((function(n){return Object.getOwnPropertyDescriptor(e,n).enumerable}))),t.push.apply(t,o)}return t}function r(e){for(var n=1;n<arguments.length;n++){var t=null!=arguments[n]?arguments[n]:{};n%2?i(Object(t),!0).forEach((function(n){a(e,n,t[n])})):Object.getOwnPropertyDescriptors?Object.defineProperties(e,Object.getOwnPropertyDescriptors(t)):i(Object(t)).forEach((function(n){Object.defineProperty(e,n,Object.getOwnPropertyDescriptor(t,n))}))}return e}function s(e,n){if(null==e)return{};var t,o,a=function(e,n){if(null==e)return{};var t,o,a={},i=Object.keys(e);for(o=0;o<i.length;o++)t=i[o],n.indexOf(t)>=0||(a[t]=e[t]);return a}(e,n);if(Object.getOwnPropertySymbols){var i=Object.getOwnPropertySymbols(e);for(o=0;o<i.length;o++)t=i[o],n.indexOf(t)>=0||Object.prototype.propertyIsEnumerable.call(e,t)&&(a[t]=e[t])}return a}var l=o.createContext({}),p=function(e){var n=o.useContext(l),t=n;return e&&(t="function"==typeof e?e(n):r(r({},n),e)),t},m=function(e){var n=p(e.components);return o.createElement(l.Provider,{value:n},e.children)},c="mdxType",g={inlineCode:"code",wrapper:function(e){var n=e.children;return o.createElement(o.Fragment,{},n)}},d=o.forwardRef((function(e,n){var t=e.components,a=e.mdxType,i=e.originalType,l=e.parentName,m=s(e,["components","mdxType","originalType","parentName"]),c=p(t),d=a,u=c["".concat(l,".").concat(d)]||c[d]||g[d]||i;return t?o.createElement(u,r(r({ref:n},m),{},{components:t})):o.createElement(u,r({ref:n},m))}));function u(e,n){var t=arguments,a=n&&n.mdxType;if("string"==typeof e||a){var i=t.length,r=new Array(i);r[0]=d;var s={};for(var l in n)hasOwnProperty.call(n,l)&&(s[l]=n[l]);s.originalType=e,s[c]="string"==typeof e?e:a,r[1]=s;for(var p=2;p<i;p++)r[p]=t[p];return o.createElement.apply(null,r)}return o.createElement.apply(null,t)}d.displayName="MDXCreateElement"},10972:(e,n,t)=>{t.r(n),t.d(n,{assets:()=>m,contentTitle:()=>l,default:()=>y,frontMatter:()=>s,metadata:()=>p,toc:()=>c});t(37953);var o=t(58860);function a(e,n,t){return n in e?Object.defineProperty(e,n,{value:t,enumerable:!0,configurable:!0,writable:!0}):e[n]=t,e}function i(e,n){return n=null!=n?n:{},Object.getOwnPropertyDescriptors?Object.defineProperties(e,Object.getOwnPropertyDescriptors(n)):function(e,n){var t=Object.keys(e);if(Object.getOwnPropertySymbols){var o=Object.getOwnPropertySymbols(e);n&&(o=o.filter((function(n){return Object.getOwnPropertyDescriptor(e,n).enumerable}))),t.push.apply(t,o)}return t}(Object(n)).forEach((function(t){Object.defineProperty(e,t,Object.getOwnPropertyDescriptor(n,t))})),e}function r(e,n){if(null==e)return{};var t,o,a=function(e,n){if(null==e)return{};var t,o,a={},i=Object.keys(e);for(o=0;o<i.length;o++)t=i[o],n.indexOf(t)>=0||(a[t]=e[t]);return a}(e,n);if(Object.getOwnPropertySymbols){var i=Object.getOwnPropertySymbols(e);for(o=0;o<i.length;o++)t=i[o],n.indexOf(t)>=0||Object.prototype.propertyIsEnumerable.call(e,t)&&(a[t]=e[t])}return a}const s={title:"React Memo Guide with Examples",description:"Improve app performance with React.memo().",slug:"react-memo-guide",authors:"abdullah_numan",tags:["react"],image:"https://refine.ams3.cdn.digitaloceanspaces.com/blog/2022-09-13-react-memo/social2.png",hide_table_of_contents:!1},l=void 0,p={permalink:"/blog/react-memo-guide",source:"@site/blog/2024-09-19-react-memo.md",title:"React Memo Guide with Examples",description:"Improve app performance with React.memo().",date:"2024-09-19T00:00:00.000Z",formattedDate:"September 19, 2024",tags:[{label:"react",permalink:"/blog/tags/react"}],readingTime:18.645,hasTruncateMarker:!1,authors:[{name:"Abdullah Numan",title:"Fullstack Developer",url:"https://github.com/anewman15/",imageURL:"https://github.com/anewman15.png",key:"abdullah_numan"}],frontMatter:{title:"React Memo Guide with Examples",description:"Improve app performance with React.memo().",slug:"react-memo-guide",authors:"abdullah_numan",tags:["react"],image:"https://refine.ams3.cdn.digitaloceanspaces.com/blog/2022-09-13-react-memo/social2.png",hide_table_of_contents:!1},prevItem:{title:"TDD vs BDD - A Detailed Guide",permalink:"/blog/tdd-vs-bdd"},nextItem:{title:"React useMemo Hook Guide with Examples",permalink:"/blog/react-usememo"},relatedPosts:[{title:"How to create React draggable components with react-dnd",description:"We'll be using the react-dnd library to create draggable components in React.",permalink:"/blog/react-draggable-components-with-react-dnd",formattedDate:"December 24, 2024",authors:[{name:"David Omotayo",title:"Frontend developer",url:"https://github.com/david4473",imageURL:"https://github.com/david4473.png",key:"david_omotayo"}],readingTime:23.51,date:"2024-12-24T00:00:00.000Z"},{title:"Essentials of Managing Form State with React Hook Form",description:"This post covers the essentials of form state management with React Hook Form library.",permalink:"/blog/react-hook-form",formattedDate:"November 6, 2024",authors:[{name:"Abdullah Numan",title:"Fullstack Developer",url:"https://github.com/anewman15/",imageURL:"https://github.com/anewman15.png",key:"abdullah_numan"}],readingTime:32.685,date:"2024-11-06T00:00:00.000Z"},{title:"Memoization in React - How useCallback Works",description:"Improve app performance with React useCallback() hook.",permalink:"/blog/react-usecallback-guide",formattedDate:"September 26, 2024",authors:[{name:"Abdullah Numan",title:"Fullstack Developer",url:"https://github.com/anewman15/",imageURL:"https://github.com/anewman15.png",key:"abdullah_numan"}],readingTime:12.895,date:"2024-09-26T00:00:00.000Z"}],authorPosts:[{title:"TypeScript Record Type with Examples",description:"We'll explore TypeScript Record type with examples.",permalink:"/blog/typescript-record-type",formattedDate:"January 6, 2025",authors:[{name:"Abdullah Numan",title:"Fullstack Developer",url:"https://github.com/anewman15/",imageURL:"https://github.com/anewman15.png",key:"abdullah_numan"}],readingTime:8.085,date:"2025-01-06T00:00:00.000Z"},{title:"Pilot & Refine architecture",description:"We'll be taking a look at the architecture of Refine and how week of RefineWeek series will be structured.",permalink:"/blog/refine-react-invoice-generator-1",formattedDate:"April 10, 2023",authors:[{name:"Abdullah Numan",title:"Fullstack Developer",url:"https://github.com/anewman15/",imageURL:"https://github.com/anewman15.png",key:"abdullah_numan"}],readingTime:9.195,date:"2023-04-10T00:00:00.000Z"},{title:"TypeScript keyof with Examples",description:"This post explains with examples how the keyof operator is used to define advanced types in TypeScript.",permalink:"/blog/typescript-keyof",formattedDate:"April 1, 2024",authors:[{name:"Abdullah Numan",title:"Fullstack Developer",url:"https://github.com/anewman15/",imageURL:"https://github.com/anewman15.png",key:"abdullah_numan"}],readingTime:10.1,date:"2024-04-01T00:00:00.000Z"}]},m={authorsImageUrls:[void 0]},c=[{value:"Introduction",id:"introduction",level:2},{value:"What is Memoization?",id:"what-is-memoization",level:2},{value:"Why Memoization in React?",id:"why-memoization-in-react",level:2},{value:"Excessive Re-rendering Due to Ancestor Re-rendering",id:"excessive-re-rendering-due-to-ancestor-re-rendering",level:3},{value:"Expensive Utilities",id:"expensive-utilities",level:3},{value:"Passing Callbacks to Children",id:"passing-callbacks-to-children",level:3},{value:"Memoization in React",id:"memoization-in-react",level:2},{value:"About the React Memoization Series",id:"about-the-react-memoization-series",level:2},{value:"Project Overview",id:"project-overview",level:2},{value:"Setup",id:"setup",level:3},{value:"Investigation",id:"investigation",level:3},{value:"Memoizing a Functional Component using <code>React.memo()</code>",id:"memoizing-a-functional-component-using-reactmemo",level:2},{value:"What is <code>React.memo</code> ?",id:"what-is-reactmemo-",level:3},{value:"React.memo() - How to Memoize Component Props",id:"reactmemo---how-to-memoize-component-props",level:3},{value:"Best Practices for Using <code>React.memo()</code>",id:"best-practices-for-using-reactmemo",level:2},{value:"Use it for frequently re-rendered components",id:"use-it-for-frequently-re-rendered-components",level:3},{value:"Avoid overusing <code>React.memo()</code>",id:"avoid-overusing-reactmemo",level:3},{value:"Shallow comparison only",id:"shallow-comparison-only",level:3},{value:"Don\u2019t memoize static or rarely updated components",id:"dont-memoize-static-or-rarely-updated-components",level:3},{value:"When to Use <code>React.memo</code>",id:"when-to-use-reactmemo",level:3},{value:"When Not to Use <code>React.memo</code>",id:"when-not-to-use-reactmemo",level:3},{value:"React.memo: Prop Comparison",id:"reactmemo-prop-comparison",level:3},{value:"Using React Memo with Custom Comparators",id:"using-react-memo-with-custom-comparators",level:3},{value:"You can Profile Components in DevTools",id:"you-can-profile-components-in-devtools",level:2},{value:"Bonus: Deep vs Shallow Comparison in Memoization",id:"bonus-deep-vs-shallow-comparison-in-memoization",level:2},{value:"Shallow Comparison",id:"shallow-comparison",level:3},{value:"Deep Comparison",id:"deep-comparison",level:3},{value:"Custom Comparators for Deep Comparison",id:"custom-comparators-for-deep-comparison",level:3},{value:"When to Use Deep Comparison",id:"when-to-use-deep-comparison",level:3},{value:"Best Practices",id:"best-practices",level:3},{value:"Summary",id:"summary",level:2},{value:"Live Example",id:"live-example",level:2}],g=(d="CodeSandboxExample",function(e){return console.warn("Component "+d+" was not imported, exported, or provided by MDXProvider as global scope"),(0,o.yg)("div",e)});var d;const u={toc:c},h="wrapper";function y(e){var{components:n}=e,t=r(e,["components"]);return(0,o.yg)(h,i(function(e){for(var n=1;n<arguments.length;n++){var t=null!=arguments[n]?arguments[n]:{},o=Object.keys(t);"function"==typeof Object.getOwnPropertySymbols&&(o=o.concat(Object.getOwnPropertySymbols(t).filter((function(e){return Object.getOwnPropertyDescriptor(t,e).enumerable})))),o.forEach((function(n){a(e,n,t[n])}))}return e}({},u,t),{components:n,mdxType:"MDXLayout"}),(0,o.yg)("p",null,(0,o.yg)("strong",{parentName:"p"},"This article was last updated on September 19, 2024, to add sections on Deep vs Shallow Comparison in Memoization, Profiling Components in DevTools, and Best Practices for Using ",(0,o.yg)("inlineCode",{parentName:"strong"},"React.memo()"),".")),(0,o.yg)("h2",{id:"introduction"},"Introduction"),(0,o.yg)("p",null,"This post introduces the ",(0,o.yg)("a",{parentName:"p",href:"https://refine.dev/blog/react-memo-guide/"},"React Memoization Series")," and demonstrates the usage of the ",(0,o.yg)("a",{parentName:"p",href:"https://react.dev/reference/react/memo"},(0,o.yg)("inlineCode",{parentName:"a"},"React.memo"))," API. ",(0,o.yg)("inlineCode",{parentName:"p"},"React.memo")," memoizes a functional component and its props. Doing so helps prevent unnecessary re-renderings that originate from the re-renderings of the component's parent / ancestors."),(0,o.yg)("p",null,"This is the first post of a three-part series hosted on ",(0,o.yg)("a",{parentName:"p",href:"https://refine.dev/blog"},"Refine blog")," on the use of memoization in React."),(0,o.yg)("p",null,"The other two posts in the series cover the usage of React ",(0,o.yg)("inlineCode",{parentName:"p"},"useMemo()")," and ",(0,o.yg)("inlineCode",{parentName:"p"},"useCallback()")," hooks."),(0,o.yg)("p",null,"Steps we'll cover in this post:"),(0,o.yg)("ul",null,(0,o.yg)("li",{parentName:"ul"},(0,o.yg)("a",{parentName:"li",href:"#what-is-memoization"},"What is Memoization?")),(0,o.yg)("li",{parentName:"ul"},(0,o.yg)("a",{parentName:"li",href:"#why-memoization-in-react"},"Why Memoization in React?")),(0,o.yg)("li",{parentName:"ul"},(0,o.yg)("a",{parentName:"li",href:"#memoization-in-react"},"Memoization in React")),(0,o.yg)("li",{parentName:"ul"},(0,o.yg)("a",{parentName:"li",href:"#about-the-react-memoization-series"},"About the React Memoization Series")),(0,o.yg)("li",{parentName:"ul"},(0,o.yg)("a",{parentName:"li",href:"#project-overview"},"Project Overview")),(0,o.yg)("li",{parentName:"ul"},(0,o.yg)("a",{parentName:"li",href:"#memoizing-a-functional-component-using-reactmemo"},"Memoizing a Functional Component using ",(0,o.yg)("inlineCode",{parentName:"a"},"React.memo()"))),(0,o.yg)("li",{parentName:"ul"},(0,o.yg)("a",{parentName:"li",href:"#best-practices-for-using-reactmemo"},"Best Practices for Using ",(0,o.yg)("inlineCode",{parentName:"a"},"React.memo()"))),(0,o.yg)("li",{parentName:"ul"},(0,o.yg)("a",{parentName:"li",href:"#you-can-profile-components-in-devtools"},"You can Profile Components in DevTools")),(0,o.yg)("li",{parentName:"ul"},(0,o.yg)("a",{parentName:"li",href:"#bonus-deep-vs-shallow-comparison-in-memoization"},"Bonus: Deep vs Shallow Comparison in Memoization")),(0,o.yg)("li",{parentName:"ul"},(0,o.yg)("a",{parentName:"li",href:"#live-example"},"Live Example"))),(0,o.yg)("h2",{id:"what-is-memoization"},"What is Memoization?"),(0,o.yg)("p",null,"Memoization is an performance optimization technique that allows us to minimize the use of memory and time while executing a resource-intensive function. It works by storing the last computed value or object from the function. Memoization lets us bypass the function's costly computations when the function is called with the same parameters repeatedly."),(0,o.yg)("h2",{id:"why-memoization-in-react"},"Why Memoization in React?"),(0,o.yg)("p",null,"Memoization plays a crucial role in enhancing the performance of a React component. It addresses following shortcomings in React:"),(0,o.yg)("h3",{id:"excessive-re-rendering-due-to-ancestor-re-rendering"},"Excessive Re-rendering Due to Ancestor Re-rendering"),(0,o.yg)("p",null,"React is all about re/rendering components in the virtual DOM prior to updating the actual Document Object Model in the browser. Re-render in an ancestor component, by default, triggers a re-render in a descendent component."),(0,o.yg)("p",null,"For example, a local state update in a parent component causes it to re-render. This, in turn, causes its children to re-render."),(0,o.yg)("p",null,"Such behavior in React causes a lot of memory and time to be wasted on useless renderings of the descendent components. Excessive re-renderings, therefore impact a React app's performance negatively."),(0,o.yg)("h3",{id:"expensive-utilities"},"Expensive Utilities"),(0,o.yg)("p",null,"In addition, resource intensive functions such as utilities used in data processing, transformation and manipulation lower a React app's performance. Functions used for sorting, filtering and mapping traverse large sets of data and therefore slows down an application."),(0,o.yg)("h3",{id:"passing-callbacks-to-children"},"Passing Callbacks to Children"),(0,o.yg)("p",null,"Performance of a React app is also adversely effected due to callback functions passed from a parent component to a child. This happens because a new function object from the callback is created in memory every time the child re-renders. So, multiple copies of the same callback function are spun off in runtime and they consume resources unnecessarily."),(0,o.yg)("h2",{id:"memoization-in-react"},"Memoization in React"),(0,o.yg)("p",null,"Using ",(0,o.yg)("strong",{parentName:"p"},"memoization")," the right way in React helps in mitigating these drawbacks and facilitates better use of computing resources in a React app."),(0,o.yg)("p",null,"Memoization can be used in a number of ways for optimizing the performance of a React app. React components can be memoized to prevent unnecessary component re-renders originating from ancestors participating in the component hierarchy. In functional React, component memoization is done using the ",(0,o.yg)("inlineCode",{parentName:"p"},"React.memo")," API."),(0,o.yg)("p",null,"Caching values of expensive utility functions and memoizing callbacks are two common ways of boosting a React app's performance. Caching function values is done using ",(0,o.yg)("inlineCode",{parentName:"p"},"useMemo()")," hook. And callback functions are memoized with the ",(0,o.yg)("inlineCode",{parentName:"p"},"useCallback()")," hook."),(0,o.yg)("h2",{id:"about-the-react-memoization-series"},"About the React Memoization Series"),(0,o.yg)("p",null,"The ",(0,o.yg)("strong",{parentName:"p"},"React Memoization Series")," is a three part guide on how to implement memoization in a React app. Each part demonstrates in the browser console how memoization contributes to performance optimization."),(0,o.yg)("p",null,"The three parts are:"),(0,o.yg)("ol",null,(0,o.yg)("li",{parentName:"ol"},(0,o.yg)("a",{parentName:"li",href:"https://refine.dev/blog/react-memo-guide/"},"React Memo Guide with Examples")),(0,o.yg)("li",{parentName:"ol"},(0,o.yg)("a",{parentName:"li",href:"https://refine.dev/blog/react-usememo/"},"React useMemo Hook Guide With Examples")),(0,o.yg)("li",{parentName:"ol"},(0,o.yg)("a",{parentName:"li",href:"https://refine.dev/blog/react-usecallback-guide/"},"Memoization in React - How useCallback Works"))),(0,o.yg)("p",null,"In the first post, we implement memoizing a React component with ",(0,o.yg)("inlineCode",{parentName:"p"},"React.memo()")," and demonstrate how unnecessary re-renders coming from ancestor state updates are prevented. The second post covers how caching the value of an expensive utility function with ",(0,o.yg)("inlineCode",{parentName:"p"},"useMemo")," stops repetitive invocations of data heavy computations that slow down a React app. In the third part, we get an idea on how memoization of callbacks passed to child components helps reduce application memory consumption."),(0,o.yg)("p",null,"We will begin with an example that involves memoizing a functional component with ",(0,o.yg)("inlineCode",{parentName:"p"},"React.memo()"),". In the subsequent posts, we will gradually extend it to include use cases for the ",(0,o.yg)("inlineCode",{parentName:"p"},"useMemo()")," and ",(0,o.yg)("inlineCode",{parentName:"p"},"useCallback()")," hooks."),(0,o.yg)("h2",{id:"project-overview"},"Project Overview"),(0,o.yg)("p",null,"This series is a demo rather than a step-by-step coding tutorial. It is intended to demonstrate how memoization contributes to performance optimization in a React app. We've made the code available ",(0,o.yg)("a",{parentName:"p",href:"#live-stackblitz-example"},"here"),"."),(0,o.yg)("p",null,"All the components have been already coded. We'll be showing how memoization is implemented using ",(0,o.yg)("inlineCode",{parentName:"p"},"React.memo"),", ",(0,o.yg)("inlineCode",{parentName:"p"},"useMemo()")," and ",(0,o.yg)("inlineCode",{parentName:"p"},"useCallback")," APIs by examining relevant code snippets and highlighting lines on the existing components."),(0,o.yg)("p",null,"We'll follow the impact of memoization mainly from the browser's console."),(0,o.yg)("h3",{id:"setup"},"Setup"),(0,o.yg)("p",null,"In order to properly follow this tutorial, we recommend you run the app in a browser - since we will be visiting the console to investigate the impact of memoization on our React app."),(0,o.yg)("p",null,"For this to happen, please follow the below steps as outlined ",(0,o.yg)("a",{parentName:"p",href:"https://github.com/refinedev/refine/tree/main/examples/blog-react-memoization-memo"},"here"),":"),(0,o.yg)("ol",null,(0,o.yg)("li",{parentName:"ol"},"Clone ",(0,o.yg)("a",{parentName:"li",href:"https://github.com/refinedev/refine/tree/main/examples/blog-react-memoization-memo"},"this repository"),"."),(0,o.yg)("li",{parentName:"ol"},"Open it in your code editor and install the packages:")),(0,o.yg)("pre",null,(0,o.yg)("code",{parentName:"pre",className:"language-bash"},"yarn install\n")),(0,o.yg)("ol",{start:3},(0,o.yg)("li",{parentName:"ol"},"Then run the app:")),(0,o.yg)("pre",null,(0,o.yg)("code",{parentName:"pre",className:"language-bash"},"yarn start\n")),(0,o.yg)("ol",{start:4},(0,o.yg)("li",{parentName:"ol"},"Open Google Chrome and navigate to ",(0,o.yg)("inlineCode",{parentName:"li"},"http://localhost:3000"),"."),(0,o.yg)("li",{parentName:"ol"},"Use ",(0,o.yg)("inlineCode",{parentName:"li"},"CTRL")," + ",(0,o.yg)("inlineCode",{parentName:"li"},"Shift")," + ",(0,o.yg)("inlineCode",{parentName:"li"},"J")," on Ubuntu or ",(0,o.yg)("inlineCode",{parentName:"li"},"Command")," + ",(0,o.yg)("inlineCode",{parentName:"li"},"Option")," + ",(0,o.yg)("inlineCode",{parentName:"li"},"J")," on Mac to inspect the webpage and open browser's console.")),(0,o.yg)("h3",{id:"investigation"},"Investigation"),(0,o.yg)("p",null,"If you look at the project folder in your code editor, you'll find that ",(0,o.yg)("inlineCode",{parentName:"p"},"react-memoization")," is created using ",(0,o.yg)("inlineCode",{parentName:"p"},"create-react-app"),"."),(0,o.yg)("p",null,"The app is based on the idea of a list of posts on a blog. There are several components involving a user presented the latest posts and a list of the user's posts. Allow yourself some time to understand the components individually, their relationships, their state changes, and how props are passed through. It is crucial to pay close attention to how the change of a parent's state triggers re-render of its descendants."),(0,o.yg)("p",null,"Let's dig into the components and check out what's happening."),(0,o.yg)("p",null,(0,o.yg)("strong",{parentName:"p"},"The ",(0,o.yg)("inlineCode",{parentName:"strong"},"<App />")," Component")),(0,o.yg)("p",null,"To begin with, we have an ",(0,o.yg)("inlineCode",{parentName:"p"},"<App />")," component that houses ",(0,o.yg)("inlineCode",{parentName:"p"},"<Blog />"),"."),(0,o.yg)("p",null,"If we look inside ",(0,o.yg)("inlineCode",{parentName:"p"},"<App />"),", we can see that we're storing a ",(0,o.yg)("inlineCode",{parentName:"p"},"signedIn")," state with ",(0,o.yg)("inlineCode",{parentName:"p"},"useState()")," hook. We also have a toggler function that alters the value of ",(0,o.yg)("inlineCode",{parentName:"p"},"signedIn"),":"),(0,o.yg)("pre",null,(0,o.yg)("code",{parentName:"pre",className:"language-tsx",metastring:'title="src/components/App.jsx"',title:'"src/components/App.jsx"'},'import { useState } from "react";\nimport Blog from "./components/Blog";\n\nfunction App() {\n  const [signedIn, setSignedIn] = useState(false);\n  const handleClick = () => setSignedIn(!signedIn);\n\n  console.log("Rendering App component");\n\n  return (\n    <main>\n      <nav>\n        <button onClick={handleClick}>Sign Out</button>\n      </nav>\n      <Blog signedIn={signedIn} setSignedIn={setSignedIn} />\n    </main>\n  );\n}\n\nexport default App;\n')),(0,o.yg)("p",null,"In the JSX, we pass ",(0,o.yg)("inlineCode",{parentName:"p"},"signedIn")," to ",(0,o.yg)("inlineCode",{parentName:"p"},"<Blog />"),"."),(0,o.yg)("p",null,(0,o.yg)("strong",{parentName:"p"},"The ",(0,o.yg)("inlineCode",{parentName:"strong"},"<Blog />")," Component")),(0,o.yg)("p",null,"Looking inside ",(0,o.yg)("inlineCode",{parentName:"p"},"<Blog />"),", it fetches a list of posts with a click on the ",(0,o.yg)("inlineCode",{parentName:"p"},"Get Latest Post")," button and sets the ",(0,o.yg)("inlineCode",{parentName:"p"},"updatedPosts")," state:"),(0,o.yg)("pre",null,(0,o.yg)("code",{parentName:"pre",className:"language-tsx",metastring:'title="src/components/Blog.jsx"',title:'"src/components/Blog.jsx"'},'import React, { useEffect, useMemo, useState } from "react";\nimport fetchUpdatedPosts from "../fetch/fetchUpdatedPosts";\nimport allPosts from "./../data/allPosts.json";\nimport sortPosts from "../utils/sortPosts";\nimport LatestPost from "./LatestPost";\nimport UserPostsIndex from "./UserPostsIndex";\n\nconst Blog = ({ signedIn }) => {\n  const [updatedPosts, setUpdatedPosts] = useState(allPosts);\n  const [localTime, setLocalTime] = useState(new Date().toLocaleTimeString());\n\n  const getLatestPosts = () => {\n    const posts = fetchUpdatedPosts();\n    setUpdatedPosts(posts);\n  };\n\n  const sortedPosts = sortPosts(updatedPosts);\n\n  useEffect(() => {\n    const id = setInterval(\n      () => setLocalTime(new Date().toLocaleTimeString()),\n      1000,\n    );\n    return () => clearInterval(id);\n  }, []);\n\n  console.log("Rendering Blog component");\n\n  return (\n    <div>\n      <div>{localTime}</div>\n      <button onClick={getLatestPosts}>Get Latest Post</button>\n      //highlight-next-line\n      <LatestPost signedIn={signedIn} post={sortedPosts[0]} />\n      <UserPostsIndex signedIn={signedIn} />\n    </div>\n  );\n};\n\nexport default Blog;\n')),(0,o.yg)("p",null,"We can see that the ",(0,o.yg)("inlineCode",{parentName:"p"},"updatedPosts")," are sorted with the ",(0,o.yg)("inlineCode",{parentName:"p"},"sortPosts")," utility and the first item from the sorted array is then passed to ",(0,o.yg)("inlineCode",{parentName:"p"},"<LatestPost />")," component along with ",(0,o.yg)("inlineCode",{parentName:"p"},"signedIn"),"."),(0,o.yg)("p",null,(0,o.yg)("strong",{parentName:"p"},"The ",(0,o.yg)("inlineCode",{parentName:"strong"},"<LatestPost />")," Component")),(0,o.yg)("p",null,"Then coming to ",(0,o.yg)("inlineCode",{parentName:"p"},"<LatestPost />"),", it nests the ",(0,o.yg)("inlineCode",{parentName:"p"},"<Post />")," component, which we are going to memoize with ",(0,o.yg)("inlineCode",{parentName:"p"},"React.memo()"),"."),(0,o.yg)("p",null,"Let's quickly run through ",(0,o.yg)("inlineCode",{parentName:"p"},"<LatestPost />")," to see what it does:"),(0,o.yg)("pre",null,(0,o.yg)("code",{parentName:"pre",className:"language-tsx",metastring:'title="src/components/LatestPost.jsx"',title:'"src/components/LatestPost.jsx"'},'import React, { useEffect, useState } from "react";\nimport Post from "./Post";\n\nconst LatestPost = ({ signedIn, post }) => {\n  const [likesCount, setLikesCount] = useState(null);\n\n  useEffect(() => {\n    const id = setInterval(() => {\n      setLikesCount((likesCount) => likesCount + 1);\n    }, 3000);\n\n    return () => clearInterval(id);\n  }, []);\n\n  console.log("Rendering LatestPost component");\n\n  return (\n    <div>\n      {post ? (\n        <>\n          //highlight-next-line\n          <Post signedIn={signedIn} post={post} />\n          {likesCount && (\n            <div className="my-1 p-1">\n              <span>{likesCount} Likes</span>\n            </div>\n          )}\n        </>\n      ) : (\n        <p>Click on Get Latest Post button</p>\n      )}\n    </div>\n  );\n};\n\nexport default LatestPost;\n')),(0,o.yg)("p",null,"We can see that ",(0,o.yg)("inlineCode",{parentName:"p"},"<LatestPost />")," changes its local state of ",(0,o.yg)("inlineCode",{parentName:"p"},"likesCount")," every 3 seconds in the ",(0,o.yg)("inlineCode",{parentName:"p"},"useEffect()")," hook. Because of this, ",(0,o.yg)("inlineCode",{parentName:"p"},"<LatestPost />")," should re-render every 3 seconds. So should ",(0,o.yg)("inlineCode",{parentName:"p"},"<Post />")," as a consequence of being a child of ",(0,o.yg)("inlineCode",{parentName:"p"},"<LatestPost />"),":"),(0,o.yg)("p",null,(0,o.yg)("strong",{parentName:"p"},"The ",(0,o.yg)("inlineCode",{parentName:"strong"},"Post />")," Component")),(0,o.yg)("p",null,"Let's now focus on ",(0,o.yg)("inlineCode",{parentName:"p"},"<Post />"),". It receives ",(0,o.yg)("inlineCode",{parentName:"p"},"signedIn")," and ",(0,o.yg)("inlineCode",{parentName:"p"},"post")," as props and displays the content of ",(0,o.yg)("inlineCode",{parentName:"p"},"post"),":"),(0,o.yg)("pre",null,(0,o.yg)("code",{parentName:"pre",className:"language-tsx",metastring:'title="src/components/Post.jsx"',title:'"src/components/Post.jsx"'},'import React from "react";\n\nconst Post = ({ signedIn, post }) => {\n  console.log("Rendering Post component");\n\n  return (\n    <div className="">\n      {post && (\n        <div className="post p-1">\n          <h1 className="heading-sm py-1">{post.title}</h1>\n          <p>{post.body}</p>\n        </div>\n      )}\n    </div>\n  );\n};\n\nexport default Post;\n')),(0,o.yg)("p",null,"Notice we are logging to the console the event when ",(0,o.yg)("inlineCode",{parentName:"p"},"<Post />")," gets rendered: ",(0,o.yg)("inlineCode",{parentName:"p"},"console.log('Rendering Post component');")),(0,o.yg)("p",null,"When we check the console, we can expect to see that ",(0,o.yg)("inlineCode",{parentName:"p"},"<Post />")," is re-rendered with a change in ",(0,o.yg)("inlineCode",{parentName:"p"},"likesCount")," from ",(0,o.yg)("inlineCode",{parentName:"p"},"<LatestPost />"),". This would be happening even though ",(0,o.yg)("inlineCode",{parentName:"p"},"<Post />")," does not depend on ",(0,o.yg)("inlineCode",{parentName:"p"},"likesCount"),"."),(0,o.yg)("p",null,"If we examine closely, we can see that this is indeed the case: we have ",(0,o.yg)("inlineCode",{parentName:"p"},"<Post />")," rendering again and again following an interval:"),(0,o.yg)("img",{style:{alignSelf:"center",width:"400px"},src:"https://refine.ams3.cdn.digitaloceanspaces.com/blog/2022-09-13-react-memo/memo1.png",alt:"memo1"}),(0,o.yg)("br",null),(0,o.yg)("p",null,"Notice, rendering ",(0,o.yg)("inlineCode",{parentName:"p"},"<Post />")," is accompanied by ",(0,o.yg)("inlineCode",{parentName:"p"},"<LatestPost />")," at 3 seconds interval, so it is consistent that ",(0,o.yg)("inlineCode",{parentName:"p"},"<Post />"),"'s re-renders are happening due to ",(0,o.yg)("inlineCode",{parentName:"p"},"likesCount")," state changes in ",(0,o.yg)("inlineCode",{parentName:"p"},"<LatestPost />"),". That is, they are coming at ",(0,o.yg)("inlineCode",{parentName:"p"},"3000ms")," intervals from ",(0,o.yg)("inlineCode",{parentName:"p"},"<LatestPost />"),"'s ",(0,o.yg)("inlineCode",{parentName:"p"},"useEffect()")," hook."),(0,o.yg)("p",null,"All these re-renders are futile for ",(0,o.yg)("inlineCode",{parentName:"p"},"<Post />")," and costly for the app. So we are going to prevent them using component memoization."),(0,o.yg)("h2",{id:"memoizing-a-functional-component-using-reactmemo"},"Memoizing a Functional Component using ",(0,o.yg)("inlineCode",{parentName:"h2"},"React.memo()")),(0,o.yg)("p",null,"Now, if we memoize ",(0,o.yg)("inlineCode",{parentName:"p"},"<Post />")," with ",(0,o.yg)("inlineCode",{parentName:"p"},"React.memo()"),", the re-renders should stop."),(0,o.yg)("p",null,"So, in ",(0,o.yg)("inlineCode",{parentName:"p"},"<Post />"),", let's update the component export with the highlighted code:"),(0,o.yg)("pre",null,(0,o.yg)("code",{parentName:"pre",className:"language-tsx",metastring:'title="src/components/Post.jsx"',title:'"src/components/Post.jsx"'},"const Post = ({ signedIn, post }) => {\n\nconsole.log('Rendering Post component');\n\n  return ( ... );\n};\n\n//highlight-next-line\nexport default React.memo(Post);\n")),(0,o.yg)("p",null,"Looking at the console, we can see that ",(0,o.yg)("inlineCode",{parentName:"p"},"Post")," is no longer re-rendered at 3s intervals:"),(0,o.yg)("img",{style:{alignSelf:"center",width:"400px"},src:"https://refine.ams3.cdn.digitaloceanspaces.com/blog/2022-09-13-react-memo/memo2.png",alt:"memo2"}),(0,o.yg)("br",null),(0,o.yg)("p",null,"It is clear that memoizing ",(0,o.yg)("inlineCode",{parentName:"p"},"<Post />")," reduces the number of re-renders. In a real app, this is a huge blessing because re-renders due to frequent likes turn out to be very costly for a social media app's performance."),(0,o.yg)("p",null,"But what exactly happened?"),(0,o.yg)("h3",{id:"what-is-reactmemo-"},"What is ",(0,o.yg)("inlineCode",{parentName:"h3"},"React.memo")," ?"),(0,o.yg)("p",null,"Well, with ",(0,o.yg)("inlineCode",{parentName:"p"},"export default React.memo(Post);"),", we produced a new component that re-renders only when its props and internal state is changed."),(0,o.yg)("p",null,(0,o.yg)("inlineCode",{parentName:"p"},"React.memo()")," is a Higher Order Component (HOC) that memoizes the passed in component along with the value of its props. Doing so helps in optimizing its performance by preventing unnecessary re-renders due to changes it does not depend on, e.g. the unrelated state changes in ancestor components."),(0,o.yg)("p",null,(0,o.yg)("inlineCode",{parentName:"p"},"React.memo")," does this by memoizing the component function itself and the accepted props. When the values of the props change, the component re-renders."),(0,o.yg)("h3",{id:"reactmemo---how-to-memoize-component-props"},"React.memo() - How to Memoize Component Props"),(0,o.yg)("p",null,"We can see that ",(0,o.yg)("inlineCode",{parentName:"p"},"<Post />")," receives ",(0,o.yg)("inlineCode",{parentName:"p"},"signedIn")," and ",(0,o.yg)("inlineCode",{parentName:"p"},"post")," props."),(0,o.yg)("p",null,"Now, unlike with ",(0,o.yg)("inlineCode",{parentName:"p"},"likesCount"),", ",(0,o.yg)("inlineCode",{parentName:"p"},"<Post />")," ",(0,o.yg)("strong",{parentName:"p"},"depends on")," ",(0,o.yg)("inlineCode",{parentName:"p"},"signIn")," and ",(0,o.yg)("inlineCode",{parentName:"p"},"post"),". And ",(0,o.yg)("strong",{parentName:"p"},"React memo")," caches these props and checks for incoming changes in them. Incoming changes to them triggers a re-render. So, altering any of ",(0,o.yg)("inlineCode",{parentName:"p"},"signedIn")," or ",(0,o.yg)("inlineCode",{parentName:"p"},"post")," re-renders ",(0,o.yg)("inlineCode",{parentName:"p"},"Post"),"."),(0,o.yg)("p",null,"If we look back inside ",(0,o.yg)("inlineCode",{parentName:"p"},"<App />"),", we see that ",(0,o.yg)("inlineCode",{parentName:"p"},"signedIn")," originated from there and gets relayed via ",(0,o.yg)("inlineCode",{parentName:"p"},"<Blog />")," and ",(0,o.yg)("inlineCode",{parentName:"p"},"<LatestPost />")," to ",(0,o.yg)("inlineCode",{parentName:"p"},"<Post />")," as props. We have a button in the navbar that toggles the value of ",(0,o.yg)("inlineCode",{parentName:"p"},"signedIn"),":"),(0,o.yg)("pre",null,(0,o.yg)("code",{parentName:"pre",className:"language-jsx"},'<nav className="navbar">\n  <button className="btn btn-danger" onClick={handleClick}>\n    Sign Out\n  </button>\n</nav>\n')),(0,o.yg)("p",null,"In the browser, let's try toggling its value to see the effect on memoized ",(0,o.yg)("inlineCode",{parentName:"p"},"<Post />"),"."),(0,o.yg)("p",null,"Add the following console log statement to ",(0,o.yg)("inlineCode",{parentName:"p"},"<Post />")," in order to log the value of ",(0,o.yg)("inlineCode",{parentName:"p"},"signedIn")," to the console:"),(0,o.yg)("pre",null,(0,o.yg)("code",{parentName:"pre",className:"language-tsx"},"//highlight-next-line\nconsole.log(signedIn);\n")),(0,o.yg)("p",null,"When we click on the ",(0,o.yg)("inlineCode",{parentName:"p"},"Sign Out")," button in the navbar, we can see in the console that ",(0,o.yg)("inlineCode",{parentName:"p"},"<Post />")," re-renders after ",(0,o.yg)("inlineCode",{parentName:"p"},"<LatestPost />"),":"),(0,o.yg)("img",{width:"400px",src:"https://refine.ams3.cdn.digitaloceanspaces.com/blog/2022-09-13-react-memo/memo3.png",style:{alignSelf:"center"},alt:"memo3"}),(0,o.yg)("br",null),(0,o.yg)("p",null,"This is now because ",(0,o.yg)("strong",{parentName:"p"},"React memo")," caches the props passed to the component and checks for incoming changes. Notice the Boolean value of ",(0,o.yg)("inlineCode",{parentName:"p"},"signedIn")," printed to the console. A change in ",(0,o.yg)("inlineCode",{parentName:"p"},"signedIn"),"'s state renews the memoization and a re-render of the component is triggered."),(0,o.yg)("h2",{id:"best-practices-for-using-reactmemo"},"Best Practices for Using ",(0,o.yg)("inlineCode",{parentName:"h2"},"React.memo()")),(0,o.yg)("p",null,"I wanted to share a few best practices for using ",(0,o.yg)("inlineCode",{parentName:"p"},"React.memo()")," with some code examples. These can help improve the performance of our React components:"),(0,o.yg)("h3",{id:"use-it-for-frequently-re-rendered-components"},"Use it for frequently re-rendered components"),(0,o.yg)("p",null,"If a component is being re-rendered unnecessarily due to its parent re-rendering, ",(0,o.yg)("inlineCode",{parentName:"p"},"React.memo()")," can help. For example, if we have a component like this:"),(0,o.yg)("pre",null,(0,o.yg)("code",{parentName:"pre",className:"language-jsx"},'const Post = ({ title, content }) => {\n  console.log("Rendering Post component");\n  return (\n    <div>\n      <h1>{title}</h1>\n      <p>{content}</p>\n    </div>\n  );\n};\n\nexport default Post;\n')),(0,o.yg)("p",null,"We can prevent unnecessary re-renders by wrapping it with ",(0,o.yg)("inlineCode",{parentName:"p"},"React.memo()"),":"),(0,o.yg)("pre",null,(0,o.yg)("code",{parentName:"pre",className:"language-jsx"},'const Post = React.memo(({ title, content }) => {\n  console.log("Rendering Post component");\n  return (\n    <div>\n      <h1>{title}</h1>\n      <p>{content}</p>\n    </div>\n  );\n});\n\nexport default Post;\n')),(0,o.yg)("p",null,"Now, this component will only re-render if its ",(0,o.yg)("inlineCode",{parentName:"p"},"title")," or ",(0,o.yg)("inlineCode",{parentName:"p"},"content")," props change."),(0,o.yg)("h3",{id:"avoid-overusing-reactmemo"},"Avoid overusing ",(0,o.yg)("inlineCode",{parentName:"h3"},"React.memo()")),(0,o.yg)("p",null,"It\u2019s important not to use ",(0,o.yg)("inlineCode",{parentName:"p"},"React.memo()")," everywhere. If a component\u2019s props change frequently, memoization can add more overhead than improvement. Use it only when the props don't change often."),(0,o.yg)("h3",{id:"shallow-comparison-only"},"Shallow comparison only"),(0,o.yg)("p",null,"By default, ",(0,o.yg)("inlineCode",{parentName:"p"},"React.memo()")," performs a shallow comparison of props. If you\u2019re passing complex objects or arrays, you might need to write a custom comparison function. For example:"),(0,o.yg)("pre",null,(0,o.yg)("code",{parentName:"pre",className:"language-jsx"},'const Post = React.memo(\n  ({ title, content }) => {\n    console.log("Rendering Post component");\n    return (\n      <div>\n        <h1>{title}</h1>\n        <p>{content}</p>\n      </div>\n    );\n  },\n  (prevProps, nextProps) => {\n    return prevProps.title === nextProps.title; // Custom comparison\n  },\n);\n')),(0,o.yg)("p",null,"In this example, we are only checking if the ",(0,o.yg)("inlineCode",{parentName:"p"},"title")," has changed. The component will only re-render if the ",(0,o.yg)("inlineCode",{parentName:"p"},"title")," prop changes, even if ",(0,o.yg)("inlineCode",{parentName:"p"},"content")," changes."),(0,o.yg)("h3",{id:"dont-memoize-static-or-rarely-updated-components"},"Don\u2019t memoize static or rarely updated components"),(0,o.yg)("p",null,"If a component is static or doesn\u2019t receive changing props, there\u2019s no need to use ",(0,o.yg)("inlineCode",{parentName:"p"},"React.memo()"),". For example, this component doesn\u2019t benefit from memoization:"),(0,o.yg)("pre",null,(0,o.yg)("code",{parentName:"pre",className:"language-jsx"},"const Footer = () => {\n  return <footer>Footer content</footer>;\n};\n\n// No need to memoize here\n")),(0,o.yg)("p",null,"Memoization would add unnecessary complexity without improving performance."),(0,o.yg)("p",null,"By following these best practices and using ",(0,o.yg)("inlineCode",{parentName:"p"},"React.memo()")," in the right situations, we can optimize performance without adding extra overhead."),(0,o.yg)("h3",{id:"when-to-use-reactmemo"},"When to Use ",(0,o.yg)("inlineCode",{parentName:"h3"},"React.memo")),(0,o.yg)("p",null,"This is actually what we want. Because we don't want ",(0,o.yg)("inlineCode",{parentName:"p"},"<Post />")," to re-render when we don't need it to, and we want to re-render it when we need it to."),(0,o.yg)("p",null,"If value of ",(0,o.yg)("inlineCode",{parentName:"p"},"signedIn")," never changed, we know ",(0,o.yg)("inlineCode",{parentName:"p"},"<Post />")," will never be re-rendered because of ",(0,o.yg)("inlineCode",{parentName:"p"},"signedIn"),". In that case, caching ",(0,o.yg)("inlineCode",{parentName:"p"},"signedIn")," doesn't do us any favor."),(0,o.yg)("p",null,"So, typically we should use ",(0,o.yg)("inlineCode",{parentName:"p"},"React.memo")," when we want to prevent re-renderings due to state changes that do not concern our component and only allow re-renderings due to prop changes that happen often or are driven by an event."),(0,o.yg)("h3",{id:"when-not-to-use-reactmemo"},"When Not to Use ",(0,o.yg)("inlineCode",{parentName:"h3"},"React.memo")),(0,o.yg)("p",null,"In our example, had we resorted to ",(0,o.yg)("inlineCode",{parentName:"p"},"React.memo()")," solely to retain the value of ",(0,o.yg)("inlineCode",{parentName:"p"},"signedIn")," and ",(0,o.yg)("strong",{parentName:"p"},"not")," to prevent re-renders due to changes in ",(0,o.yg)("inlineCode",{parentName:"p"},"likesCount")," or ",(0,o.yg)("inlineCode",{parentName:"p"},"post"),", we would not get much performance benefit."),(0,o.yg)("p",null,"Instead, we would be bringing the comparison function into the scene for no reason, which adds to the performance cost. So, it is ",(0,o.yg)("strong",{parentName:"p"},"not")," recommended to memoize a component if its prop values ",(0,o.yg)("strong",{parentName:"p"},"don't")," change often."),(0,o.yg)("p",null,"It is therefore important to figure out the performance gains by measuring and analyzing runtime performance using browser utilities like Chrome DevTools."),(0,o.yg)("h3",{id:"reactmemo-prop-comparison"},"React.memo: Prop Comparison"),(0,o.yg)("p",null,(0,o.yg)("strong",{parentName:"p"},"React memo")," checks for changes between the previous and current values for a given prop passed to the component. The default function carries out a shallow comparison on each passed in prop. It checks for equality of incoming values with the existing ones."),(0,o.yg)("p",null,"In our ",(0,o.yg)("inlineCode",{parentName:"p"},"React.memo(Post)")," memo, the current states of ",(0,o.yg)("inlineCode",{parentName:"p"},"signedIn")," and ",(0,o.yg)("inlineCode",{parentName:"p"},"post")," are checked for equality to their incoming states. If both values for each prop are equal, the memoized value is retained and re-render prevented. If they are not equal, the new value is cached and ",(0,o.yg)("inlineCode",{parentName:"p"},"<Post />")," re-renders."),(0,o.yg)("h3",{id:"using-react-memo-with-custom-comparators"},"Using React Memo with Custom Comparators"),(0,o.yg)("p",null,"It is possible to customize the comparison by passing in a comparator function to the ",(0,o.yg)("inlineCode",{parentName:"p"},"React.memo()")," HOC as a second argument:"),(0,o.yg)("pre",null,(0,o.yg)("code",{parentName:"pre",className:"language-tsx"},"React.memo(Post, customComparator);\n")),(0,o.yg)("p",null,"For example, we can specify dependencies for ",(0,o.yg)("inlineCode",{parentName:"p"},"React.memo()")," and choose to compare only the props we want to:"),(0,o.yg)("pre",null,(0,o.yg)("code",{parentName:"pre",className:"language-tsx",metastring:'title="src/components/Post.jsx"',title:'"src/components/Post.jsx"'},'import React from "react";\n\nconst Post = ({ signedIn, post }) => {\n  console.log("Rendering Post component");\n\n  return ( ... );\n};\n\n//highlight-start\nconst customComparator = (prevProps, nextProps) => {\n  return nextProps.post === prevProps.post;\n};\n//highlight-end\n\n//highlight-start\nexport default React.memo(Post, customComparator);\n//highlight-end\n')),(0,o.yg)("p",null,"Here, we are omitting ",(0,o.yg)("inlineCode",{parentName:"p"},"signedIn")," from the comparison by including only ",(0,o.yg)("inlineCode",{parentName:"p"},"post"),". Now, if we click on ",(0,o.yg)("inlineCode",{parentName:"p"},"Sign Out")," button, ",(0,o.yg)("inlineCode",{parentName:"p"},"Post")," is not being re-rendered:"),(0,o.yg)("img",{style:{alignSelf:"center",width:"400px"},src:"https://refine.ams3.cdn.digitaloceanspaces.com/blog/2022-09-13-react-memo/memo4.png",alt:"memo4"}),(0,o.yg)("br",null),(0,o.yg)("p",null,"This is because, our ",(0,o.yg)("inlineCode",{parentName:"p"},"customComparator")," checks for equality of incoming values of only ",(0,o.yg)("inlineCode",{parentName:"p"},"post")," and excludes ",(0,o.yg)("inlineCode",{parentName:"p"},"signedIn")," from the comparison."),(0,o.yg)("h2",{id:"you-can-profile-components-in-devtools"},"You can Profile Components in DevTools"),(0,o.yg)("p",null,"I wanted to share some tips on ",(0,o.yg)("strong",{parentName:"p"},"Profiling Components in DevTools")," to help us identify and fix performance bottlenecks in our React app."),(0,o.yg)("p",null,(0,o.yg)("strong",{parentName:"p"},"Opening the React Profiler")),(0,o.yg)("ul",null,(0,o.yg)("li",{parentName:"ul"},"Install the ",(0,o.yg)("strong",{parentName:"li"},"React Developer Tools")," extension for Chrome or Firefox."),(0,o.yg)("li",{parentName:"ul"},"Open ",(0,o.yg)("strong",{parentName:"li"},"DevTools")," (",(0,o.yg)("inlineCode",{parentName:"li"},"F12")," or ",(0,o.yg)("inlineCode",{parentName:"li"},"Ctrl + Shift + I"),"), go to the ",(0,o.yg)("strong",{parentName:"li"},"Profiler")," tab, and click ",(0,o.yg)("strong",{parentName:"li"},'"Record"')," before interacting with the app.")),(0,o.yg)("p",null,(0,o.yg)("strong",{parentName:"p"},"Capturing Component Renders")),(0,o.yg)("p",null,"Interact with the app while recording (e.g., clicking buttons, changing state). The Profiler will track which components re-render and how long each takes."),(0,o.yg)("p",null,(0,o.yg)("strong",{parentName:"p"},"Analyzing Results")),(0,o.yg)("p",null,"After recording, view the timeline to inspect:"),(0,o.yg)("ul",null,(0,o.yg)("li",{parentName:"ul"},(0,o.yg)("strong",{parentName:"li"},"Render Time"),": Time taken for each component render."),(0,o.yg)("li",{parentName:"ul"},(0,o.yg)("strong",{parentName:"li"},"Render Reason"),": Prop or state changes causing re-renders.")),(0,o.yg)("p",null,(0,o.yg)("strong",{parentName:"p"},"Optimizing Slow Renders")),(0,o.yg)("p",null,"If a component (e.g., ",(0,o.yg)("inlineCode",{parentName:"p"},"Post"),") is re-rendering unnecessarily, wrap it in ",(0,o.yg)("inlineCode",{parentName:"p"},"React.memo()")," to prevent it from re-rendering when props haven't changed."),(0,o.yg)("p",null,(0,o.yg)("strong",{parentName:"p"},"Highlight Updates")),(0,o.yg)("p",null,"Enable ",(0,o.yg)("strong",{parentName:"p"},'"Highlight Updates"')," in the ",(0,o.yg)("strong",{parentName:"p"},"React")," tab to visually see components that re-render, making it easier to spot unnecessary updates."),(0,o.yg)("p",null,"Using the Profiler, we can quickly identify and optimize slow re-renders."),(0,o.yg)("h2",{id:"bonus-deep-vs-shallow-comparison-in-memoization"},"Bonus: Deep vs Shallow Comparison in Memoization"),(0,o.yg)("p",null,"I wanted to go over deep vs shallow comparison in memoization and how that affects performance optimization in React, especially when using ",(0,o.yg)("inlineCode",{parentName:"p"},"React.memo()")," and other memoization techniques."),(0,o.yg)("h3",{id:"shallow-comparison"},"Shallow Comparison"),(0,o.yg)("p",null,"By default, React does ",(0,o.yg)("strong",{parentName:"p"},"shallow comparison")," to check if a component\u2019s props have changed to decide whether to re-render it. Shallow comparison means React checks for changes only at the top level of an object or array and doesn't go into nested properties."),(0,o.yg)("p",null,"For example:"),(0,o.yg)("pre",null,(0,o.yg)("code",{parentName:"pre",className:"language-jsx"},'const person1 = { name: "John" };\nconst person2 = { name: "John" };\n\nconsole.log(person1 === person2); // false - because of different object references\n')),(0,o.yg)("p",null,"Even though ",(0,o.yg)("inlineCode",{parentName:"p"},"person1")," and ",(0,o.yg)("inlineCode",{parentName:"p"},"person2")," have the same data, during a shallow comparison, they are considered different because the reference is compared, not the content."),(0,o.yg)("pre",null,(0,o.yg)("code",{parentName:"pre",className:"language-jsx"},'const Post = React.memo(({ title, content }) => {\n  console.log("Rendering Post component");\n  return (\n    <div>\n      <h1>{title}</h1>\n      <p>{content}</p>\n    </div>\n  );\n});\n')),(0,o.yg)("p",null,"If the ",(0,o.yg)("inlineCode",{parentName:"p"},"title")," and ",(0,o.yg)("inlineCode",{parentName:"p"},"content")," props are ",(0,o.yg)("strong",{parentName:"p"},"primitives")," (like strings or numbers), the shallow comparison works as expected. But if they are ",(0,o.yg)("strong",{parentName:"p"},"objects")," or ",(0,o.yg)("strong",{parentName:"p"},"arrays"),", even a slight change in the reference (e.g., creating a new object) will trigger a re-render."),(0,o.yg)("h3",{id:"deep-comparison"},"Deep Comparison"),(0,o.yg)("p",null,"A deep comparison goes beyond top-level properties and checks all nested properties. It's a bit heavier since every level of the object or array has to be checked."),(0,o.yg)("p",null,"React doesn't perform deep comparisons by default in ",(0,o.yg)("inlineCode",{parentName:"p"},"React.memo()")," because it can be slow, especially with deeply nested objects or large arrays."),(0,o.yg)("h3",{id:"custom-comparators-for-deep-comparison"},"Custom Comparators for Deep Comparison"),(0,o.yg)("p",null,"If shallow comparison isn\u2019t enough (for example, when passing complex objects as props), we can provide a custom comparator function in ",(0,o.yg)("inlineCode",{parentName:"p"},"React.memo()")," to implement ",(0,o.yg)("strong",{parentName:"p"},"deep comparison"),"."),(0,o.yg)("p",null,"Here\u2019s a custom comparator for deep comparison:"),(0,o.yg)("pre",null,(0,o.yg)("code",{parentName:"pre",className:"language-jsx"},'import React from "react";\nimport { isEqual } from "lodash";\n\nconst Post = ({ post }) => {\n  console.log("Rendering Post component");\n  return (\n    <div>\n      <h1>{post.title}</h1>\n      <p>{post.content}</p>\n    </div>\n  );\n};\n\nconst customComparator = (prevProps, nextProps) => {\n  return isEqual(prevProps.post, nextProps.post); // Deep comparison using lodash\n};\n\nexport default React.memo(Post, customComparator);\n')),(0,o.yg)("p",null,"Here, we\u2019re using ",(0,o.yg)("inlineCode",{parentName:"p"},"lodash"),"'s ",(0,o.yg)("inlineCode",{parentName:"p"},"isEqual()")," function to deep compare the entire ",(0,o.yg)("inlineCode",{parentName:"p"},"post")," object. This helps avoid unnecessary re-renders when only the reference changes, but the data inside remains the same."),(0,o.yg)("h3",{id:"when-to-use-deep-comparison"},"When to Use Deep Comparison"),(0,o.yg)("ul",null,(0,o.yg)("li",{parentName:"ul"},(0,o.yg)("strong",{parentName:"li"},"Complex Data Structures"),": When passing large or deeply nested objects as props, and you don\u2019t want to re-render components unnecessarily."),(0,o.yg)("li",{parentName:"ul"},(0,o.yg)("strong",{parentName:"li"},"Performance Trade-offs"),": Deep comparison might be slower than a shallow comparison, so it\u2019s important to measure and ensure that the performance gain from avoiding re-renders outweighs the cost of deep comparison.")),(0,o.yg)("h3",{id:"best-practices"},"Best Practices"),(0,o.yg)("ul",null,(0,o.yg)("li",{parentName:"ul"},"Use shallow comparison whenever possible to keep performance high."),(0,o.yg)("li",{parentName:"ul"},"Only use deep comparison when you\u2019re sure the props involve deeply nested objects that don\u2019t change often."),(0,o.yg)("li",{parentName:"ul"},"Use libraries like ",(0,o.yg)("inlineCode",{parentName:"li"},"lodash")," or ",(0,o.yg)("inlineCode",{parentName:"li"},"deep-equal")," for effective deep comparisons.")),(0,o.yg)("h2",{id:"summary"},"Summary"),(0,o.yg)("p",null,"In this post, we acknowledged what memoization is and why it is important in React. We learned about the use of ",(0,o.yg)("inlineCode",{parentName:"p"},"React.memo()"),", ",(0,o.yg)("inlineCode",{parentName:"p"},"useMemo")," and ",(0,o.yg)("inlineCode",{parentName:"p"},"useCallback")," APIs for implementing memoization in a React app."),(0,o.yg)("p",null,"By investigating a demo blog post app, we observed in the browser console that ",(0,o.yg)("inlineCode",{parentName:"p"},"React.memo()")," is very useful in preventing unnecessary, frequent re-renders of a component due to ancestor state changes that it does not depend on. A good example involves a component that accepts props whose values change often and/or on demand. With a ",(0,o.yg)("inlineCode",{parentName:"p"},"React.memo")," custom comparator function, we can choose to specify only the props we want to track for triggering a re-render of our component."),(0,o.yg)("p",null,"In the next article, we will turn our attention to the ",(0,o.yg)("inlineCode",{parentName:"p"},"<Blog />")," component and memoize a sorting function with ",(0,o.yg)("inlineCode",{parentName:"p"},"useMemo()")," hook."),(0,o.yg)("h2",{id:"live-example"},"Live Example"),(0,o.yg)(g,{path:"blog-react-memoization-memo",mdxType:"CodeSandboxExample"}))}y.isMDXComponent=!0}}]);