"use strict";(self.webpackChunkdocumentation=self.webpackChunkdocumentation||[]).push([[96204],{58860:(e,t,n)=>{n.d(t,{xA:()=>d,yg:()=>g});var o=n(37953);function a(e,t,n){return t in e?Object.defineProperty(e,t,{value:n,enumerable:!0,configurable:!0,writable:!0}):e[t]=n,e}function s(e,t){var n=Object.keys(e);if(Object.getOwnPropertySymbols){var o=Object.getOwnPropertySymbols(e);t&&(o=o.filter((function(t){return Object.getOwnPropertyDescriptor(e,t).enumerable}))),n.push.apply(n,o)}return n}function i(e){for(var t=1;t<arguments.length;t++){var n=null!=arguments[t]?arguments[t]:{};t%2?s(Object(n),!0).forEach((function(t){a(e,t,n[t])})):Object.getOwnPropertyDescriptors?Object.defineProperties(e,Object.getOwnPropertyDescriptors(n)):s(Object(n)).forEach((function(t){Object.defineProperty(e,t,Object.getOwnPropertyDescriptor(n,t))}))}return e}function r(e,t){if(null==e)return{};var n,o,a=function(e,t){if(null==e)return{};var n,o,a={},s=Object.keys(e);for(o=0;o<s.length;o++)n=s[o],t.indexOf(n)>=0||(a[n]=e[n]);return a}(e,t);if(Object.getOwnPropertySymbols){var s=Object.getOwnPropertySymbols(e);for(o=0;o<s.length;o++)n=s[o],t.indexOf(n)>=0||Object.prototype.propertyIsEnumerable.call(e,n)&&(a[n]=e[n])}return a}var c=o.createContext({}),l=function(e){var t=o.useContext(c),n=t;return e&&(n="function"==typeof e?e(t):i(i({},t),e)),n},d=function(e){var t=l(e.components);return o.createElement(c.Provider,{value:t},e.children)},p="mdxType",u={inlineCode:"code",wrapper:function(e){var t=e.children;return o.createElement(o.Fragment,{},t)}},h=o.forwardRef((function(e,t){var n=e.components,a=e.mdxType,s=e.originalType,c=e.parentName,d=r(e,["components","mdxType","originalType","parentName"]),p=l(n),h=a,g=p["".concat(c,".").concat(h)]||p[h]||u[h]||s;return n?o.createElement(g,i(i({ref:t},d),{},{components:n})):o.createElement(g,i({ref:t},d))}));function g(e,t){var n=arguments,a=t&&t.mdxType;if("string"==typeof e||a){var s=n.length,i=new Array(s);i[0]=h;var r={};for(var c in t)hasOwnProperty.call(t,c)&&(r[c]=t[c]);r.originalType=e,r[p]="string"==typeof e?e:a,i[1]=r;for(var l=2;l<s;l++)i[l]=n[l];return o.createElement.apply(null,i)}return o.createElement.apply(null,n)}h.displayName="MDXCreateElement"},56667:(e,t,n)=>{n.r(t),n.d(t,{assets:()=>d,contentTitle:()=>c,default:()=>g,frontMatter:()=>r,metadata:()=>l,toc:()=>p});n(37953);var o=n(58860);function a(e,t,n){return t in e?Object.defineProperty(e,t,{value:n,enumerable:!0,configurable:!0,writable:!0}):e[t]=n,e}function s(e,t){return t=null!=t?t:{},Object.getOwnPropertyDescriptors?Object.defineProperties(e,Object.getOwnPropertyDescriptors(t)):function(e,t){var n=Object.keys(e);if(Object.getOwnPropertySymbols){var o=Object.getOwnPropertySymbols(e);t&&(o=o.filter((function(t){return Object.getOwnPropertyDescriptor(e,t).enumerable}))),n.push.apply(n,o)}return n}(Object(t)).forEach((function(n){Object.defineProperty(e,n,Object.getOwnPropertyDescriptor(t,n))})),e}function i(e,t){if(null==e)return{};var n,o,a=function(e,t){if(null==e)return{};var n,o,a={},s=Object.keys(e);for(o=0;o<s.length;o++)n=s[o],t.indexOf(n)>=0||(a[n]=e[n]);return a}(e,t);if(Object.getOwnPropertySymbols){var s=Object.getOwnPropertySymbols(e);for(o=0;o<s.length;o++)n=s[o],t.indexOf(n)>=0||Object.prototype.propertyIsEnumerable.call(e,n)&&(a[n]=e[n])}return a}const r={title:"How to set up a WebSocket connection with Node.js and React.js?",description:"Understanding Real-time communication with React and WebSocket",slug:"react-websocket-tutorial-nodejs",authors:"frank_joseph",tags:["react"],hide_table_of_contents:!1,image:"https://refine.ams3.cdn.digitaloceanspaces.com/blog/2023-08-16-react-web-socket/social-2.png"},c=void 0,l={permalink:"/blog/react-websocket-tutorial-nodejs",source:"@site/blog/2024-08-15-react-web-socket.md",title:"How to set up a WebSocket connection with Node.js and React.js?",description:"Understanding Real-time communication with React and WebSocket",date:"2024-08-15T00:00:00.000Z",formattedDate:"August 15, 2024",tags:[{label:"react",permalink:"/blog/tags/react"}],readingTime:18.885,hasTruncateMarker:!1,authors:[{name:"Frank Joseph",title:"Software Developer",imageURL:"/img/generic-profile.png",key:"frank_joseph"}],frontMatter:{title:"How to set up a WebSocket connection with Node.js and React.js?",description:"Understanding Real-time communication with React and WebSocket",slug:"react-websocket-tutorial-nodejs",authors:"frank_joseph",tags:["react"],hide_table_of_contents:!1,image:"https://refine.ams3.cdn.digitaloceanspaces.com/blog/2023-08-16-react-web-socket/social-2.png"},prevItem:{title:"Creating Polished Content with React Markdown",permalink:"/blog/react-markdown"},nextItem:{title:"Bun vs. Node.js",permalink:"/blog/bun-js-vs-node"},relatedPosts:[{title:"Building components with Radix UI",description:"This post explains with examples how the keyof operator is used to define advanced types in TypeScript.",permalink:"/blog/radix-ui",formattedDate:"November 6, 2024",authors:[{name:"Peter Osah",title:"Web Developer",imageURL:"/img/generic-profile.png",key:"peter_osah"}],readingTime:15.085,date:"2024-11-06T00:00:00.000Z"},{title:"Framer Motion examples for React animations",description:"Framer Motion tutorial - Create text and image animations in React apps easily.",permalink:"/blog/framer-motion-react-animations",formattedDate:"September 1, 2022",authors:[{name:"Joel Ezimorah",title:"Software Developer",url:"https://github.com/prince-joel",imageURL:"https://github.com/prince-joel.png",key:"joel_ezimorah"}],readingTime:8.235,date:"2022-09-01T00:00:00.000Z"},{title:"Getting started with Astro Framework",description:"We will learn how to set up Astrojs, create a new project, and basics.",permalink:"/blog/astro-js-guide",formattedDate:"October 22, 2024",authors:[{name:"Chidume Nnamdi",title:"Software Engineer",url:"https://github.com/philipszdavido",imageURL:"https://github.com/philipszdavido.png",key:"chidume_nnamdi"}],readingTime:21.505,date:"2024-10-22T00:00:00.000Z"}],authorPosts:[]},d={authorsImageUrls:[void 0]},p=[{value:"Introduction",id:"introduction",level:2},{value:"Why WebSocket?",id:"why-websocket",level:2},{value:"Unleashing the Power of WebSockets using Node.js and React",id:"unleashing-the-power-of-websockets-using-nodejs-and-react",level:2},{value:"Accessing the Code",id:"accessing-the-code",level:2},{value:"Run the application after Setting up the Environment",id:"run-the-application-after-setting-up-the-environment",level:2},{value:"Understanding the Code**",id:"understanding-the-code",level:2},{value:"Understanding the WebSocket Handshake",id:"understanding-the-websocket-handshake",level:3},{value:"Managing Client Connections",id:"managing-client-connections",level:3},{value:"Establishing the Handshake at the Client Level",id:"establishing-the-handshake-at-the-client-level",level:3},{value:"Real-time Message Transmission",id:"real-time-message-transmission",level:3},{value:"Handling Disconnections",id:"handling-disconnections",level:3},{value:"Security Considerations with WebSockets",id:"security-considerations-with-websockets",level:2},{value:"WSS: WebSocket Secure Connections",id:"wss-websocket-secure-connections",level:3},{value:"Put in Place Authentication and Authorization",id:"put-in-place-authentication-and-authorization",level:3},{value:"Protection from Cross-Site WebSocket Hijacking",id:"protection-from-cross-site-websocket-hijacking",level:3},{value:"Rate Limiting and Message Validation",id:"rate-limiting-and-message-validation",level:3},{value:"Close Connections Gracefully",id:"close-connections-gracefully",level:3},{value:"Bonus: WebSocket Protocols and Subprotocols",id:"bonus-websocket-protocols-and-subprotocols",level:2},{value:"What Is WebSocket Protocols?",id:"what-is-websocket-protocols",level:3},{value:"Subprotocols Understanding",id:"subprotocols-understanding",level:3},{value:"Popular WebSocket Subprotocols",id:"popular-websocket-subprotocols",level:3},{value:"4. Realizing Subprotocols through WebSocket Connection",id:"4-realizing-subprotocols-through-websocket-connection",level:3},{value:"5. Custom Subprotocols",id:"5-custom-subprotocols",level:3}],u={toc:p},h="wrapper";function g(e){var{components:t}=e,n=i(e,["components"]);return(0,o.yg)(h,s(function(e){for(var t=1;t<arguments.length;t++){var n=null!=arguments[t]?arguments[t]:{},o=Object.keys(n);"function"==typeof Object.getOwnPropertySymbols&&(o=o.concat(Object.getOwnPropertySymbols(n).filter((function(e){return Object.getOwnPropertyDescriptor(n,e).enumerable})))),o.forEach((function(t){a(e,t,n[t])}))}return e}({},u,n),{components:t,mdxType:"MDXLayout"}),(0,o.yg)("p",null,(0,o.yg)("strong",{parentName:"p"},"This article was last updated on August 15, 2024, to add sections for WebSocket Protocols and Subprotocols, Security Considerations with WebSockets, and Error Handling and Reconnection Strategies.")),(0,o.yg)("h2",{id:"introduction"},"Introduction"),(0,o.yg)("p",null,"With the advent of Social Media and other internet-enabled communication tools, delivering real-time communication has become increasingly important. Hypertext Transfer Protocol (HTTP) is a communication protocol like WebSocket that follows the Request-Response, one-way communication pattern. It has been used by most developers to implement real-time communication but it falls short when the use case involves instant updates and building a full-duplex bidirectional communication tool. Although HTTP through its various methods such as HTTP Polling, Streaming, and server-sent events (SSE) helped developers implement data transfer, there are restrictions and disadvantages that have paved the way for WebSocket. WebSocket helps developers implement a full-duplex bidirectional communication mechanism and helps developers build a real-time communication system."),(0,o.yg)("p",null,"In this article, we\u2019ll discuss the shortcomings of the HTTP protocol, and explore the concept of real-time communication and how to implement it with the WebSocket protocol while building a basic client communication application."),(0,o.yg)("p",null,"Steps we'll cover:"),(0,o.yg)("ul",null,(0,o.yg)("li",{parentName:"ul"},(0,o.yg)("a",{parentName:"li",href:"#why-websocket"},"Why WebSocket?")),(0,o.yg)("li",{parentName:"ul"},(0,o.yg)("a",{parentName:"li",href:"#unleashing-the-power-of-websockets-using-nodejs-and-react"},"Unleashing the Power of WebSockets using Node.js and React")),(0,o.yg)("li",{parentName:"ul"},(0,o.yg)("a",{parentName:"li",href:"#accessing-the-code"},"Accessing the Code")),(0,o.yg)("li",{parentName:"ul"},(0,o.yg)("a",{parentName:"li",href:"#run-the-application-after-setting-up-the-environment"},"Run the application after Setting up the Environment")),(0,o.yg)("li",{parentName:"ul"},(0,o.yg)("a",{parentName:"li",href:"#understanding-the-code"},"Understanding the Code","*","*")),(0,o.yg)("li",{parentName:"ul"},(0,o.yg)("a",{parentName:"li",href:"#security-considerations-with-websockets"},"Security Considerations with WebSockets")),(0,o.yg)("li",{parentName:"ul"},(0,o.yg)("a",{parentName:"li",href:"#bonus-websocket-protocols-and-subprotocols"},"Bonus: WebSocket Protocols and Subprotocols"))),(0,o.yg)("h2",{id:"why-websocket"},"Why WebSocket?"),(0,o.yg)("p",null,"In creating web applications with a full-duplex (two-way) bidirectional communication functionality, developers must tweak the traditional HTTP protocol to implement data transfer. The HTTP protocol has several methods such as HTTP Polling, HTTP Streaming, and server-sent events that help developers build a real-time application. These methods have several shortcomings where WebSockets has proved superior as we\u2019ll see in the following few sections."),(0,o.yg)("p",null,(0,o.yg)("strong",{parentName:"p"},"HTTP Polling"),"\nThe first attempt to solve the issues that comes with traditional HTTP protocol is by polling the server intervals. The client sends the request to the server at predefined intervals using these functions setInterval or setTimeout. In long polling, the server handles the interval or waiting time. The sum total of the request and response events in the HTTP protocol is referred to as the ",(0,o.yg)("inlineCode",{parentName:"p"},"HTTP Polling lifecycle")," It involves the following steps:"),(0,o.yg)("ul",null,(0,o.yg)("li",{parentName:"ul"},"To communicate with the server, the client sends a request and waits for a response"),(0,o.yg)("li",{parentName:"ul"},"The server sends a response when there is an event, update, or change, or reaches a timeout until then it hangs the client request."),(0,o.yg)("li",{parentName:"ul"},"The server sends a response to the client when there is an update or change"),(0,o.yg)("li",{parentName:"ul"},"This cycle continues as the client sends a new request.")),(0,o.yg)("p",null,"The following are some of the flaws associated with HTTP Polling: Caching, Timeouts, header overhead, and latency. Building a real-time application with WebSocket removes these pitfalls associated with HTTP Polling."),(0,o.yg)("p",null,(0,o.yg)("strong",{parentName:"p"},"HTTP Stream"),"\nIn HTTP Polling, the server closes without sending a response to the client, this is the predominant cause of network latency associated with HTTP Polling. In HTTP Polling, the server closes the request connection channel after responding. This connection channel closure means the client would have to create a new connection whenever there is a new request. HTTP Stream solves this problem. In HTTP Stream, the initial request is left open even after the server has responded to the client\u2019s request with data. Leaving the request channel open indefinitely makes it possible for the server to continually send responses to the client whenever new data is available or there is an update or change. HTTP Stream reduces latency, delivers updates near real-time, and utilizes server resources. The limitation associated with streaming data over HTTP is that it requires the client to initiate a request and establish a connection and latency could be an issue with streaming too."),(0,o.yg)("p",null,(0,o.yg)("a",{parentName:"p",href:"https://developer.mozilla.org/en-US/docs/Web/API/Server-sent_events"},(0,o.yg)("strong",{parentName:"a"},"Server-Sent Event (SSE)")),"\nThe server-sent event protocol provides a unidirectional (Serve-client) communication channel to stream data in real-time or near real-time. The SSE is a standardized HTTP streaming protocol with a built-in browser API."),(0,o.yg)("p",null,"NB: Firefox doesn't support the use of SSE in service workers."),(0,o.yg)("p",null,"SSE is an excellent choice for unidirectional data transfer from server to client. SSE is extremely fitted for use cases where there is no need to send data from the client to the server. For example, SSE is especially useful for handling social media feed updates, and real-time dashboards."),(0,o.yg)("p",null,"So far, we\u2019ve seen the shortcomings associated with the traditional HTTP methods, and how inefficient it is to use them to implement bidirectional real-time communication. WebSocket is a more suitable option for implementing bidirectional data exchange."),(0,o.yg)("p",null,(0,o.yg)("strong",{parentName:"p"},"What is WebSocket"),"\nWebSocket is a data transfer protocol that makes it possible for bidirectional (two-way), real-time, full-duplex, and interactive communication between the browser (client) and the server over a single, long-lived Transmission Control Protocol (TCP) connection. With ",(0,o.yg)("a",{parentName:"p",href:"https://developer.mozilla.org/en-US/docs/Web/API/WebSockets_API"},"WebSocket API"),", the client can send requests to the server and receive event-driven responses without having to poll the server."),(0,o.yg)("p",null,"WebSocket connection follows the order below:"),(0,o.yg)("ul",null,(0,o.yg)("li",{parentName:"ul"},(0,o.yg)("strong",{parentName:"li"},"Request Handshake"),": To establish a connection, the client sends an initial request to the server, this is known as the WebSocket handshake."),(0,o.yg)("li",{parentName:"ul"},(0,o.yg)("strong",{parentName:"li"},"Validate request"),": Upon receiving the request, the server checks its validity and connects if validation is successful."),(0,o.yg)("li",{parentName:"ul"},(0,o.yg)("strong",{parentName:"li"},"Communication"),": Upon successful validation, a WebSocket connection is established, and both the server and client can transfer data to each other.")),(0,o.yg)("p",null,"WebSocket API is supported by most major browsers as shown in this ",(0,o.yg)("a",{parentName:"p",href:"https://developer.mozilla.org/en-US/docs/Web/API/WebSockets_API#browser_compatibility"},"compatibility table"),"."),(0,o.yg)("p",null,(0,o.yg)("strong",{parentName:"p"},"Why Developers should use WebSockets"),"\nDue to the inconsistencies associated with the HTTP methods; it is not advisable to build an application with a bidirectional communication functionality using traditional HTTP methods. WebSockets provide low-latency, bidirectional, real-time communication channels between client and server. While being a lightweight protocol, it is also scalable and supports full-duplex (two-way) communication. WebSockets are supported by most modern browsers."),(0,o.yg)("h2",{id:"unleashing-the-power-of-websockets-using-nodejs-and-react"},"Unleashing the Power of WebSockets using Node.js and React"),(0,o.yg)("p",null,"According to the Web Socket connection order discussed earlier, the WebSocket protocol starts by creating a handshake and then allows communication after confirming the request by sending data. The connection between the client and server must be established through the handshake. Real-time data communication between the client and server is possible when the handshake is complete."),(0,o.yg)("p",null,"We'll demonstrate how to set up a WebSocket connection with Node.js and React.js. To illustrate the capabilities of WebSockets, we'll utilize a collaborative text editing application as an example. Multiple people can collaborate and edit a text at the same time with this application, and any changes made by one person are immediately visible to all other users."),(0,o.yg)("h2",{id:"accessing-the-code"},"Accessing the Code"),(0,o.yg)("p",null,"Before getting into the specifics of WebSockets, it's important to remember that Git Repository has the entire code available. The source code for a prototype collaborative text editing application that will be used as our real-world example to understand web sockets practically is in the root folder(",(0,o.yg)("strong",{parentName:"p"},"WebSockets-Demo-main"),") that can be obtained from the provided URL(",(0,o.yg)("a",{parentName:"p",href:"https://github.com/khabbabpersonal/WebSockets-Demo"},(0,o.yg)("strong",{parentName:"a"},"Collaborative Text Editing Application")),"). To follow along, clone or download the repository."),(0,o.yg)("h2",{id:"run-the-application-after-setting-up-the-environment"},"Run the application after Setting up the Environment"),(0,o.yg)("p",null,"The next step after downloading and unzipping the file is configuring your Environment. Using your favorite code editor, open the unzipped folder. There are two main directories available:"),(0,o.yg)("p",null,(0,o.yg)("strong",{parentName:"p"},"The Server Directory:")," This is the location of the Node.js WebSocket server. It is in charge of managing the text editor's core logic."),(0,o.yg)("p",null,(0,o.yg)("strong",{parentName:"p"},"The Client Directory:")," This includes a React application that communicates with the WebSocket server. It is in charge of the application's real-time features. Through it, the user engages with the application."),(0,o.yg)("p",null,"You need to execute some commands in order to start the text editing application. These commands will launch the server and client and install the required packages. You can open the app in two different browser windows and edit the text simultaneously after the server and client are both up and running. Here, you begin to experience WebSockets' real-time capabilities."),(0,o.yg)("h2",{id:"understanding-the-code"},"Understanding the Code","*","*"),(0,o.yg)("h3",{id:"understanding-the-websocket-handshake"},"Understanding the WebSocket Handshake"),(0,o.yg)("p",null,"The server and client begin a handshake over the WebSocket protocol. At the server level, the HTTP server is turned on, and the WebSocket server is connected using a single port. The WebSocket server is connected to the HTTP port once the HTTP server has been set up. The process of creating a WebSocket connection starts with this, and it serves as the beginning of an exchange between the server and the client, much like a virtual handshake."),(0,o.yg)("pre",null,(0,o.yg)("code",{parentName:"pre",className:"language-tsx",metastring:'title="/server/index.js"',title:'"/server/index.js"'},'// Import required modules\nconst { WebSocket, WebSocketServer } = require("ws");\nconst http = require("http");\nconst uuidv4 = require("uuid").v4;\n\n// Create an HTTP server and a WebSocket server\nconst server = http.createServer();\nconst wsServer = new WebSocketServer({ server });\nconst port = 8000;\n\n// Start the WebSocket server\nserver.listen(port, () => {\n  console.log(`WebSocket server is running on port ${port}`);\n});\n')),(0,o.yg)("h3",{id:"managing-client-connections"},"Managing Client Connections"),(0,o.yg)("p",null,"The management of client connections is essential in any real-time application. Each client is provided with an individual key produced by the 'uuid' package, and all connected clients are tracked as an object in the code. The special key is created, and the connection is saved when a new client connection request is received. This enables the server to manage all connections that are currently active efficiently."),(0,o.yg)("pre",null,(0,o.yg)("code",{parentName:"pre",className:"language-tsx",metastring:'title="/server/index.js"',title:'"/server/index.js"'},'// Maintain active connections and users\nconst clients = {};\nconst users = {};\nlet editorContent = null;\nlet userActivity = [];\n\n// Handle new client connections\nwsServer.on("connection", function handleNewConnection(connection) {\n  const userId = uuidv4();\n  console.log("Received a new connection");\n\n  clients[userId] = connection;\n  console.log(`${userId} connected.`);\n\n  connection.on("message", (message) =>\n    processReceivedMessage(message, userId),\n  );\n  connection.on("close", () => handleClientDisconnection(userId));\n});\n')),(0,o.yg)("p",null,"New client connections are handled by the ",(0,o.yg)("inlineCode",{parentName:"p"},"handleNewConnection")," function as events. When a new client creates a WebSocket connection with the server, it is activated."),(0,o.yg)("p",null,"\xb7 The uuidv4 library is used to create a distinct ",(0,o.yg)("inlineCode",{parentName:"p"},"userId")," whenever a new connection is made."),(0,o.yg)("p",null,"\xb7 The ",(0,o.yg)("inlineCode",{parentName:"p"},"userId")," serves as the key for storing the connection in the ",(0,o.yg)("em",{parentName:"p"},"clients")," object."),(0,o.yg)("p",null,"\xb7 A new connection is signaled by printing a message in the log."),(0,o.yg)("p",null,"Incoming messages from clients are handled by the ",(0,o.yg)("inlineCode",{parentName:"p"},"processReceivedMessage")," function. The response message is broadcast to all connected clients once the message has been parsed, the message type has been established, and actions have been taken based on the message type (such as user activity of joining or editing content)."),(0,o.yg)("pre",null,(0,o.yg)("code",{parentName:"pre",className:"language-tsx",metastring:'title="/server/index.js"',title:'"/server/index.js"'},"// Handle incoming messages from clients\nfunction processReceivedMessage(message, userId) {\n  const dataFromClient = JSON.parse(message.toString());\n  const json = { type: dataFromClient.type };\n\n  if (dataFromClient.type === eventTypes.USER_EVENT) {\n    users[userId] = dataFromClient;\n    userActivity.push(`${dataFromClient.username} joined to collaborate`);\n    json.data = { users, userActivity };\n  } else if (dataFromClient.type === eventTypes.CONTENT_CHANGE) {\n    editorContent = dataFromClient.content;\n    json.data = { editorContent, userActivity };\n  }\n\n  sendMessageToAllClients(json);\n}\n")),(0,o.yg)("p",null,"As you can see, the new connection is successfully received."),(0,o.yg)("div",{className:"centered-image"},(0,o.yg)("img",{style:{alignSelf:"center"},src:"https://refine.ams3.cdn.digitaloceanspaces.com/blog/2023-08-16-react-web-socket/enter-name.png",alt:"react-websocket-nodejs"})),(0,o.yg)("p",null,"When User enter their name and click on Join Document the message is broadcasted to all connected clients that user have joined to collaborate. Please see the below screenshots of application:"),(0,o.yg)("div",{className:"centered-image"},(0,o.yg)("img",{style:{alignSelf:"center"},src:"https://refine.ams3.cdn.digitaloceanspaces.com/blog/2023-08-16-react-web-socket/enter-name-2.png",alt:"react-websocket-nodejs"})),(0,o.yg)("h3",{id:"establishing-the-handshake-at-the-client-level"},"Establishing the Handshake at the Client Level"),(0,o.yg)("p",null,"In the code below, the ",(0,o.yg)("inlineCode",{parentName:"p"},"react-use-websocket")," package is used on the client side to start a WebSocket connection. The ",(0,o.yg)("inlineCode",{parentName:"p"},"useWebSocket")," hook provided by this package allows React functional components to control WebSocket connections. This is the client's way of reaching out for a handshake with the server. From the client's perspective, it's the initial stage of creating a WebSocket connection. It is very easy to understand and use WebSockets when we have a good understanding of the various event types: ",(0,o.yg)("inlineCode",{parentName:"p"},"onopen"),", ",(0,o.yg)("inlineCode",{parentName:"p"},"onclose"),", or ",(0,o.yg)("inlineCode",{parentName:"p"},"onmessage"),"."),(0,o.yg)("pre",null,(0,o.yg)("code",{parentName:"pre",className:"language-tsx",metastring:'title="client/src/App.js"',title:'"client/src/App.js"'},'import React, { useEffect, useState } from "react";\nimport { Navbar, NavbarBrand } from "react-bootstrap";\nimport useWebSocket, { ReadyState } from "react-use-websocket";\nimport { Tooltip as ReactTooltip } from "react-tooltip";\nimport { DefaultEditor } from "react-simple-wysiwyg";\nimport Avatar from "react-avatar";\n\nimport "./App.css";\n\nconst WS_URL = "ws://127.0.0.1:8000";\n\nfunction isUserEvent(message) {\n  const parsedMessage = JSON.parse(message.data);\n  return parsedMessage.type === "userevent";\n}\n\nfunction isDocumentEvent(message) {\n  const parsedMessage = JSON.parse(message.data);\n  return parsedMessage.type === "contentchange";\n}\n\nfunction App() {\n  const [username, setUsername] = useState("");\n  const { sendJsonMessage, readyState } = useWebSocket(WS_URL, {\n    onOpen: () => {\n      console.log("WebSocket connection established.");\n    },\n    share: true,\n    filter: () => false,\n    retryOnError: true,\n    shouldReconnect: () => true,\n  });\n\n  // Rest of the component code\n}\n')),(0,o.yg)("p",null,"Now, when user joins, the web socket connection is established at client level. The above screenshot shows the \u201cWebSocket connection established\u201d in console logs when the connection is opened for client."),(0,o.yg)("div",{className:"centered-image"},(0,o.yg)("img",{style:{alignSelf:"center"},src:"https://refine.ams3.cdn.digitaloceanspaces.com/blog/2023-08-16-react-web-socket/handshake.png",alt:"react-websocket-nodejs"})),(0,o.yg)("h3",{id:"real-time-message-transmission"},"Real-time Message Transmission"),(0,o.yg)("p",null,"The WebSocket connection can transfer messages as it receives them once the client and server have established a connection through the WebSocket handshake event. Users can collaborate and edit text in real-time in the sample React app. The application also keeps track of user actions and content modifications, transmitting these events to every other connected client."),(0,o.yg)("pre",null,(0,o.yg)("code",{parentName:"pre",className:"language-tsx",metastring:'title="client/src/App.js"',title:'"client/src/App.js"'},'function App() {\n  const [username, setUsername] = useState("");\n  const { sendJsonMessage, readyState } = useWebSocket(WS_URL, {\n    onOpen: () => {\n      console.log("WebSocket connection established.");\n    },\n    share: true,\n    filter: () => false,\n    retryOnError: true,\n    shouldReconnect: () => true,\n  });\n\n  useEffect(() => {\n    if (username && readyState === ReadyState.OPEN) {\n      sendJsonMessage({\n        username,\n        type: "userevent",\n      });\n    }\n  }, [username, sendJsonMessage, readyState]);\n\n  return (\n    <>\n      <Navbar className="navbar" color="light" light>\n        <NavbarBrand href="/">Real-time Collaborative Text Editor</NavbarBrand>\n      </Navbar>\n      <div className="container-fluid">\n        {username ? <EditorSection /> : <LoginSection onLogin={setUsername} />}\n      </div>\n    </>\n  );\n}\n')),(0,o.yg)("pre",null,(0,o.yg)("code",{parentName:"pre",className:"language-tsx",metastring:'title="client/src/App.js"',title:'"client/src/App.js"'},'function EditorSection() {\n  return (\n    <div className="main-content">\n      <div className="document-holder">\n        <div className="current-users">\n          <Users />\n        </div>\n        <Document />\n      </div>\n      <div className="history-holder">\n        <History />\n      </div>\n    </div>\n  );\n}\n')),(0,o.yg)("pre",null,(0,o.yg)("code",{parentName:"pre",className:"language-tsx",metastring:'title="client/src/App.js"',title:'"client/src/App.js"'},'function Document() {\n  const { lastJsonMessage, sendJsonMessage } = useWebSocket(WS_URL, {\n    share: true,\n    filter: isDocumentEvent,\n  });\n  let html = lastJsonMessage?.data.editorContent || "";\n\n  function handleHtmlChange(e) {\n    sendJsonMessage({\n      type: "contentchange",\n      content: e.target.value,\n    });\n  }\n\n  return <DefaultEditor value={html} onChange={handleHtmlChange} />;\n}\n')),(0,o.yg)("p",null,"The below screenshot shows that when the client connection is established then users can collaborate and edit text in real-time, each action will be transmitted to every connection client."),(0,o.yg)("div",{className:"centered-image"},(0,o.yg)("img",{style:{alignSelf:"center"},src:"https://refine.ams3.cdn.digitaloceanspaces.com/blog/2023-08-16-react-web-socket/real-time-transmitting.png",alt:"react-websocket-nodejs"})),(0,o.yg)("h3",{id:"handling-disconnections"},"Handling Disconnections"),(0,o.yg)("p",null,"Handling disconnections is just as crucial to any real-time application as managing connections. The WebSocket initiates a ",(0,o.yg)("inlineCode",{parentName:"p"},"close")," event when a user disconnects. According to the code below, when the user closes their browser or refreshes the page, the server is capable of notifying the remaining users about the disconnection of that user."),(0,o.yg)("pre",null,(0,o.yg)("code",{parentName:"pre",className:"language-tsx",metastring:'title="/server/index.js"',title:'"/server/index.js"'},"// Handle disconnection of a client\nfunction handleClientDisconnection(userId) {\n  console.log(`${userId} disconnected.`);\n  const json = { type: eventTypes.USER_EVENT };\n  const username = users[userId]?.username || userId;\n  userActivity.push(`${username} left the editor`);\n  json.data = { users, userActivity };\n  delete clients[userId];\n  delete users[userId];\n  sendMessageToAllClients(json);\n}\n")),(0,o.yg)("p",null,"When user closes the browser window or refreshes the page, application will disconnect client and notify every connected user by broadcasting the message that that user left the editor."),(0,o.yg)("div",{className:"centered-image"},(0,o.yg)("img",{style:{alignSelf:"center"},src:"https://refine.ams3.cdn.digitaloceanspaces.com/blog/2023-08-16-react-web-socket/handling-disconnections.png",alt:"react-websocket-nodejs"})),(0,o.yg)("h2",{id:"security-considerations-with-websockets"},"Security Considerations with WebSockets"),(0,o.yg)("p",null,"I would like to briefly share my thoughts on security considerations while working with WebSockets, since we are currently using it in our project. This is a great technique for real-time communication, and there are a few security considerations that need to be taken care of so that our application is secure."),(0,o.yg)("h3",{id:"wss-websocket-secure-connections"},"WSS: WebSocket Secure Connections"),(0,o.yg)("p",null,"Please be sure to use secure websocket connections (wss://) not just plain websocket connections (ws://). This would be the equivalent of using HTTPS not HTTP. Secure websocket connections actually encrypt the data traveling between the two points and, for this reason, help secure it from being man-in-the-middled to abuse."),(0,o.yg)("pre",null,(0,o.yg)("code",{parentName:"pre",className:"language-tsx"},'const ws = new WebSocket("wss://example.com/socket");\n')),(0,o.yg)("pre",null,(0,o.yg)("code",{parentName:"pre",className:"language-tsx"},'const https = require("https");\nconst WebSocket = require("ws");\nconst server = https.createServer({\n  /* SSL options */\n});\nconst wss = new WebSocket.Server({ server });\n\nserver.listen(8080, () => {\n  console.log("Secure WebSocket server is running on port 8080");\n});\n')),(0,o.yg)("h3",{id:"put-in-place-authentication-and-authorization"},"Put in Place Authentication and Authorization"),(0,o.yg)("p",null,"Unlike HTTP requests, the WebSocket connection is long-lived and continues to stay open as long as needed. It should also be made sure that opening a WebSocket connection can only be done by an authenticated user. This can be achieved by validating tokens\u2014like JWTs\u2014while a handshake is performed. Finally, these with authorization checks are also responsible for making sure that data reached by all users is allowed."),(0,o.yg)("pre",null,(0,o.yg)("code",{parentName:"pre",className:"language-tsx"},'const token = "your_jwt_token";\nconst ws = new WebSocket(`wss://example.com/socket?token=${token}`);\n')),(0,o.yg)("pre",null,(0,o.yg)("code",{parentName:"pre",className:"language-tsx"},'const url = require("url");\nconst jwt = require("jsonwebtoken");\n\nwss.on("connection", (ws, req) => {\n  const queryParams = url.parse(req.url, true).query;\n  const token = queryParams.token;\n\n  try {\n    const decoded = jwt.verify(token, "your_secret_key");\n    ws.user = decoded.user; // Attach user info to WebSocket instance\n    console.log("User authenticated:", ws.user);\n  } catch (err) {\n    ws.close(1008, "Unauthorized"); // Close connection with Unauthorized status\n  }\n});\n')),(0,o.yg)("h3",{id:"protection-from-cross-site-websocket-hijacking"},"Protection from Cross-Site WebSocket Hijacking"),(0,o.yg)("p",null,"In a cross-site WebSocket hijack attack, an attacker manipulates a user's browser into opening a WebSocket connection to a server using the user's credentials. Mitigation involves using the authentication tokens as well as other WebSocket messages by doing validation on the server side."),(0,o.yg)("pre",null,(0,o.yg)("code",{parentName:"pre",className:"language-tsx"},'ws.onmessage = (event) => {\n  const message = JSON.parse(event.data);\n  if (message.token !== validToken) {\n    ws.close(1008, "Unauthorized");\n  } else {\n    // Process message\n  }\n};\n')),(0,o.yg)("pre",null,(0,o.yg)("code",{parentName:"pre",className:"language-tsx"},'ws.on("message", (message) => {\n  const data = JSON.parse(message);\n  try {\n    const decoded = jwt.verify(data.token, "your_secret_key");\n    // Proceed with the message processing\n  } catch (err) {\n    ws.close(1008, "Unauthorized");\n  }\n});\n')),(0,o.yg)("h3",{id:"rate-limiting-and-message-validation"},"Rate Limiting and Message Validation"),(0,o.yg)("p",null,"While it is true that WebSockets allow for real-time data exchange, one should implement rate limiting in order to avoid abuses such as server flooding with messages. In addition, valid content of messages about to be sent can prevent injections and the like."),(0,o.yg)("pre",null,(0,o.yg)("code",{parentName:"pre",className:"language-tsx"},'const rateLimit = require("express-rate-limit");\n\nconst limiter = rateLimit({\n  windowMs: 60 * 1000, // 1 minute\n  max: 100, // Limit each IP to 100 requests per windowMs\n});\n\napp.use("/socket", limiter);\n\nwss.on("connection", (ws) => {\n  ws.on("message", (message) => {\n    try {\n      const data = JSON.parse(message);\n      // Validate the message content\n      if (typeof data !== "object" || !data.action) {\n        throw new Error("Invalid message format");\n      }\n      // Process the message\n    } catch (err) {\n      ws.send(JSON.stringify({ error: "Invalid message" }));\n    }\n  });\n});\n')),(0,o.yg)("h3",{id:"close-connections-gracefully"},"Close Connections Gracefully"),(0,o.yg)("p",null,"This could avert the possibility of resource leakage and reduce the attack surface for attacks in a heavily used application with a large user base. Properly close WebSocket connections: that is, closing should only be done when it is no longer needed."),(0,o.yg)("pre",null,(0,o.yg)("code",{parentName:"pre",className:"language-tsx"},'ws.on("close", () => {\n  console.log("Connection closed");\n  // Clean up resources, e.g., remove user from active users list\n});\n\nprocess.on("SIGINT", () => {\n  wss.clients.forEach((client) => {\n    client.close(1000, "Server shutting down");\n  });\n  server.close(() => {\n    console.log("Server shut down gracefully");\n    process.exit(0);\n  });\n});\n')),(0,o.yg)("h2",{id:"bonus-websocket-protocols-and-subprotocols"},"Bonus: WebSocket Protocols and Subprotocols"),(0,o.yg)("h3",{id:"what-is-websocket-protocols"},"What Is WebSocket Protocols?"),(0,o.yg)("p",null,"WebSocket is full-duplex, single TCP connection-oriented, request-response-wise unsynchronized. On the contrary, it always has a connection open between the client and server, unlike HTTP, in which connections are opened as needed. WebSocket involves continuous communication between the two parties, a feature that can be beneficial for many applications: chat applications, live notifications, or shared tools."),(0,o.yg)("h3",{id:"subprotocols-understanding"},"Subprotocols Understanding"),(0,o.yg)("p",null,"Subprotocols are actually an extension of the WebSocket protocol, describing a certain format or, in more detail, the structure of messaging inside the WebSocket connection. Subprotocols allow the client and server to agree on one particular protocol for their data exchange, which is sometimes quite important to remember so that both parties can understand and process the messages properly."),(0,o.yg)("p",null,"An alternative way to look at subprotocols is to consider them as languages within the WebSocket connection. So, while WebSocket is the medium of communication, the subprotocols are the agreed-upon languages to be spoken between two parties\u2014like English, or Spanish."),(0,o.yg)("h3",{id:"popular-websocket-subprotocols"},"Popular WebSocket Subprotocols"),(0,o.yg)("p",null,"Some common popular sub-protocols that you are likely to come across"),(0,o.yg)("ul",null,(0,o.yg)("li",{parentName:"ul"},(0,o.yg)("p",{parentName:"li"},(0,o.yg)("strong",{parentName:"p"},"STOMP (Simple Text Oriented Messaging Protocol):")," This is mainly applied to messaging applications. It provides a simple, text-based protocol for messages that can be easily understood and quickly implemented.")),(0,o.yg)("li",{parentName:"ul"},(0,o.yg)("p",{parentName:"li"},(0,o.yg)("strong",{parentName:"p"},"MQTT (Message Queuing Telemetry Transport):")," A lightweight messaging protocol, one of the several applied in low-bandwidth, high-latency networks. It is, therefore, in essence, the most commonly used protocol in IoT applications.")),(0,o.yg)("li",{parentName:"ul"},(0,o.yg)("p",{parentName:"li"},(0,o.yg)("strong",{parentName:"p"},"WAMP (Web Application Messaging Protocol):")," This is a protocol that supports RPC (remote procedure call) and Publish/Subscribe communication patterns in a routed way. It provides a good fit for applications with more structured messaging patterns."))),(0,o.yg)("h3",{id:"4-realizing-subprotocols-through-websocket-connection"},"4. Realizing Subprotocols through WebSocket Connection"),(0,o.yg)("p",null,"During the creation of a WebSocket connection, a subprotocol to be used is specified for both the client and server. This sets things up so that both the client and server know how to format and interpret the messages in the exchange of information."),(0,o.yg)("p",null,(0,o.yg)("strong",{parentName:"p"},"Client-Side Example:")),(0,o.yg)("pre",null,(0,o.yg)("code",{parentName:"pre",className:"language-javascript"},'// Specify the desired subprotocol during connection\nconst ws = new WebSocket("wss://example.com/socket", ["mqtt"]);\n\nws.onopen = () => {\n  console.log("WebSocket connection established with MQTT subprotocol.");\n};\n\nws.onmessage = (message) => {\n  // Handle incoming messages according to the MQTT protocol\n  console.log("Received message:", message.data);\n};\n')),(0,o.yg)("p",null,(0,o.yg)("strong",{parentName:"p"},"Server Side Example (Node.js with ws library):")),(0,o.yg)("p",null,"In the example above, there is an agreement between the client and the server to use the subprotocol of MQTT to the effect that the transmitted messages will be properly formatted and understood at either end."),(0,o.yg)("pre",null,(0,o.yg)("code",{parentName:"pre",className:"language-javascript"},'const WebSocket = require("ws");\n\nconst wss = new WebSocket.Server({ port: 8080 });\n\nwss.on("connection", (ws, req) => {\n  const subprotocol = ws.protocol;\n\n  console.log(`Client connected using subprotocol: ${subprotocol}`);\n\n  ws.on("message", (message) => {\n    // Process message according to the selected subprotocol\n    console.log("Received:", message);\n  });\n\n  ws.send("Welcome to the WebSocket server!");\n});\n')),(0,o.yg)("h3",{id:"5-custom-subprotocols"},"5. Custom Subprotocols"),(0,o.yg)("p",null,"You will sometimes have to define your own subprotocol with fixed ideas for your particular needs. This makes it necessary for you to implement certain custom message format, meaning that both the client and server should be appropriately used."),(0,o.yg)("pre",null,(0,o.yg)("code",{parentName:"pre",className:"language-tsx"},'// Custom subprotocol: \'myCustomProtocol\'\n// Messages could be JSON objects with a specific structure\n\nconst ws = new WebSocket("wss://example.com/socket", ["myCustomProtocol"]);\n\nws.onmessage = (message) => {\n  const data = JSON.parse(message.data);\n  if (data.type === "greeting") {\n    console.log("Received greeting:", data.content);\n  }\n};\n')),(0,o.yg)("p",null,"You would then parse incoming messages on the server side using this custom structure to make sure that the application logic interprets them correctly. ### 6. Select the Correct Sub Protocol Choose sub-protocols that would be appropriate to satisfy your application-specific requirements."),(0,o.yg)("p",null,"For example:"),(0,o.yg)("ul",null,(0,o.yg)("li",{parentName:"ul"},(0,o.yg)("strong",{parentName:"li"},"STOMP")," is good for messaging apps where a lightweight, readable protocol is needed."),(0,o.yg)("li",{parentName:"ul"},(0,o.yg)("strong",{parentName:"li"},"MQTT")," is applicable to constrained IoT devices with limited bandwidth."),(0,o.yg)("li",{parentName:"ul"},(0,o.yg)("strong",{parentName:"li"},"WAMP"),": Can go fine together with applications which are based on structured RPC or Pub/Sub patterns.")),(0,o.yg)("p",null,"##\xa0Conclusion\nFull-duplex bidirectional real-time communication is an important aspect of modern web development. WebSockets provides the relevant and most efficient means to achieve real-time communication. In this article, we explored the concept of WebSockets, its benefits, why it is superior to other traditional HTTP methods, and why developers should adopt WebSockets. Finally, we illustrated how to integrate WebSockets into React and Node.js applications."))}g.isMDXComponent=!0}}]);