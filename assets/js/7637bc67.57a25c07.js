"use strict";(self.webpackChunkdocumentation=self.webpackChunkdocumentation||[]).push([[12114],{58860:(e,t,n)=>{n.d(t,{xA:()=>c,yg:()=>h});var i=n(37953);function a(e,t,n){return t in e?Object.defineProperty(e,t,{value:n,enumerable:!0,configurable:!0,writable:!0}):e[t]=n,e}function r(e,t){var n=Object.keys(e);if(Object.getOwnPropertySymbols){var i=Object.getOwnPropertySymbols(e);t&&(i=i.filter((function(t){return Object.getOwnPropertyDescriptor(e,t).enumerable}))),n.push.apply(n,i)}return n}function o(e){for(var t=1;t<arguments.length;t++){var n=null!=arguments[t]?arguments[t]:{};t%2?r(Object(n),!0).forEach((function(t){a(e,t,n[t])})):Object.getOwnPropertyDescriptors?Object.defineProperties(e,Object.getOwnPropertyDescriptors(n)):r(Object(n)).forEach((function(t){Object.defineProperty(e,t,Object.getOwnPropertyDescriptor(n,t))}))}return e}function p(e,t){if(null==e)return{};var n,i,a=function(e,t){if(null==e)return{};var n,i,a={},r=Object.keys(e);for(i=0;i<r.length;i++)n=r[i],t.indexOf(n)>=0||(a[n]=e[n]);return a}(e,t);if(Object.getOwnPropertySymbols){var r=Object.getOwnPropertySymbols(e);for(i=0;i<r.length;i++)n=r[i],t.indexOf(n)>=0||Object.prototype.propertyIsEnumerable.call(e,n)&&(a[n]=e[n])}return a}var s=i.createContext({}),l=function(e){var t=i.useContext(s),n=t;return e&&(n="function"==typeof e?e(t):o(o({},t),e)),n},c=function(e){var t=l(e.components);return i.createElement(s.Provider,{value:t},e.children)},y="mdxType",d={inlineCode:"code",wrapper:function(e){var t=e.children;return i.createElement(i.Fragment,{},t)}},m=i.forwardRef((function(e,t){var n=e.components,a=e.mdxType,r=e.originalType,s=e.parentName,c=p(e,["components","mdxType","originalType","parentName"]),y=l(n),m=a,h=y["".concat(s,".").concat(m)]||y[m]||d[m]||r;return n?i.createElement(h,o(o({ref:t},c),{},{components:n})):i.createElement(h,o({ref:t},c))}));function h(e,t){var n=arguments,a=t&&t.mdxType;if("string"==typeof e||a){var r=n.length,o=new Array(r);o[0]=m;var p={};for(var s in t)hasOwnProperty.call(t,s)&&(p[s]=t[s]);p.originalType=e,p[y]="string"==typeof e?e:a,o[1]=p;for(var l=2;l<r;l++)o[l]=n[l];return i.createElement.apply(null,o)}return i.createElement.apply(null,n)}m.displayName="MDXCreateElement"},22105:(e,t,n)=>{n.r(t),n.d(t,{assets:()=>c,contentTitle:()=>s,default:()=>h,frontMatter:()=>p,metadata:()=>l,toc:()=>y});n(37953);var i=n(58860);function a(e,t,n){return t in e?Object.defineProperty(e,t,{value:n,enumerable:!0,configurable:!0,writable:!0}):e[t]=n,e}function r(e,t){return t=null!=t?t:{},Object.getOwnPropertyDescriptors?Object.defineProperties(e,Object.getOwnPropertyDescriptors(t)):function(e,t){var n=Object.keys(e);if(Object.getOwnPropertySymbols){var i=Object.getOwnPropertySymbols(e);t&&(i=i.filter((function(t){return Object.getOwnPropertyDescriptor(e,t).enumerable}))),n.push.apply(n,i)}return n}(Object(t)).forEach((function(n){Object.defineProperty(e,n,Object.getOwnPropertyDescriptor(t,n))})),e}function o(e,t){if(null==e)return{};var n,i,a=function(e,t){if(null==e)return{};var n,i,a={},r=Object.keys(e);for(i=0;i<r.length;i++)n=r[i],t.indexOf(n)>=0||(a[n]=e[n]);return a}(e,t);if(Object.getOwnPropertySymbols){var r=Object.getOwnPropertySymbols(e);for(i=0;i<r.length;i++)n=r[i],t.indexOf(n)>=0||Object.prototype.propertyIsEnumerable.call(e,n)&&(a[n]=e[n])}return a}const p={title:"Dictionaries in TypeScript -  How to Ensure Type Safety",description:"This post is provides a guide on how to ensure type safety to dictionaries with TypeScript.",slug:"typescript-dictionary",authors:"abdullah_numan",tags:["typescript"],image:"https://refine.ams3.cdn.digitaloceanspaces.com/blog/2024-05-07-ts-dictionary/social.png",hide_table_of_contents:!1},s=void 0,l={permalink:"/blog/typescript-dictionary",source:"@site/blog/2024-11-11-ts-dictionary.md",title:"Dictionaries in TypeScript -  How to Ensure Type Safety",description:"This post is provides a guide on how to ensure type safety to dictionaries with TypeScript.",date:"2024-11-11T00:00:00.000Z",formattedDate:"November 11, 2024",tags:[{label:"typescript",permalink:"/blog/tags/typescript"}],readingTime:24.605,hasTruncateMarker:!1,authors:[{name:"Abdullah Numan",title:"Fullstack Developer",url:"https://github.com/anewman15/",imageURL:"https://github.com/anewman15.png",key:"abdullah_numan"}],frontMatter:{title:"Dictionaries in TypeScript -  How to Ensure Type Safety",description:"This post is provides a guide on how to ensure type safety to dictionaries with TypeScript.",slug:"typescript-dictionary",authors:"abdullah_numan",tags:["typescript"],image:"https://refine.ams3.cdn.digitaloceanspaces.com/blog/2024-05-07-ts-dictionary/social.png",hide_table_of_contents:!1},prevItem:{title:"Top 6 Free Online Code Editors and IDEs with Pros and Cons",permalink:"/blog/6-best-online-code-editors-comparison"},nextItem:{title:"How to Use Nodemon to Automatically Restart Node.js Applications",permalink:"/blog/nodemon"},relatedPosts:[{title:"TypeScript Mapped Types in Depth",description:"This post provides an in-depth guide on how to derive mapped types in TypeScript.",permalink:"/blog/typescript-mapped-types",formattedDate:"February 29, 2024",authors:[{name:"Abdullah Numan",title:"Fullstack Developer",url:"https://github.com/anewman15/",imageURL:"https://github.com/anewman15.png",key:"abdullah_numan"}],readingTime:11.19,date:"2024-02-29T00:00:00.000Z"},{title:"A Guide for Next.js with TypeScript",description:"We will explain the entire process of how to use Next.js in TypeScript",permalink:"/blog/next-js-with-typescript",formattedDate:"June 10, 2024",authors:[{name:"Michael Hungbo",title:"Software Developer",url:"https://github.com/Mich45",imageURL:"https://github.com/Mich45.png",key:"michael"}],readingTime:11.765,date:"2024-06-10T00:00:00.000Z"},{title:"How to use TypeScript Partial Type?",description:"We'll explain the TypeScript Partial utility type with examples",permalink:"/blog/typescript-partial-utility-type",formattedDate:"December 18, 2024",authors:[{name:"Abdullah Numan",title:"Fullstack Developer",url:"https://github.com/anewman15/",imageURL:"https://github.com/anewman15.png",key:"abdullah_numan"}],readingTime:5.25,date:"2024-12-18T00:00:00.000Z"}],authorPosts:[{title:"TypeScript keyof with Examples",description:"This post explains with examples how the keyof operator is used to define advanced types in TypeScript.",permalink:"/blog/typescript-keyof",formattedDate:"April 1, 2024",authors:[{name:"Abdullah Numan",title:"Fullstack Developer",url:"https://github.com/anewman15/",imageURL:"https://github.com/anewman15.png",key:"abdullah_numan"}],readingTime:10.1,date:"2024-04-01T00:00:00.000Z"},{title:"React Memo Guide with Examples",description:"Improve app performance with React.memo().",permalink:"/blog/react-memo-guide",formattedDate:"September 19, 2024",authors:[{name:"Abdullah Numan",title:"Fullstack Developer",url:"https://github.com/anewman15/",imageURL:"https://github.com/anewman15.png",key:"abdullah_numan"}],readingTime:18.645,date:"2024-09-19T00:00:00.000Z"},{title:"TypeScript Mapped Types in Depth",description:"This post provides an in-depth guide on how to derive mapped types in TypeScript.",permalink:"/blog/typescript-mapped-types",formattedDate:"February 29, 2024",authors:[{name:"Abdullah Numan",title:"Fullstack Developer",url:"https://github.com/anewman15/",imageURL:"https://github.com/anewman15.png",key:"abdullah_numan"}],readingTime:11.19,date:"2024-02-29T00:00:00.000Z"}]},c={authorsImageUrls:[void 0]},y=[{value:"Introduction",id:"introduction",level:2},{value:"Prerequisites",id:"prerequisites",level:2},{value:"TypeScript Setup",id:"typescript-setup",level:3},{value:"What is TS Dictionary ?",id:"what-is-ts-dictionary-",level:2},{value:"How Dictionaries are Implemented in JavaScript",id:"how-dictionaries-are-implemented-in-javascript",level:3},{value:"JavaScript Dictionaries with <code>Object</code> Literals",id:"javascript-dictionaries-with-object-literals",level:4},{value:"JavaScript Dictionaries with <code>Object</code> Prototype",id:"javascript-dictionaries-with-object-prototype",level:4},{value:"Dictionaries in TypeScript",id:"dictionaries-in-typescript",level:2},{value:"Why Dictionary Type Safety is Needed in TypeScript",id:"why-dictionary-type-safety-is-needed-in-typescript",level:3},{value:"Dictionaries in TypeScript: How to Apply Type Safety",id:"dictionaries-in-typescript-how-to-apply-type-safety",level:2},{value:"TypeSafe Dictionaries in TypeScript: Object Examples",id:"typesafe-dictionaries-in-typescript-object-examples",level:3},{value:"TypeScript Dictionaries with Object Index Signatures",id:"typescript-dictionaries-with-object-index-signatures",level:4},{value:"Reusable TypeScript Dictionaries with Generic Mapped Types",id:"reusable-typescript-dictionaries-with-generic-mapped-types",level:4},{value:"Type Safe Dictionaries in TypeScript: A <code>Record&lt;&gt;</code> Example",id:"type-safe-dictionaries-in-typescript-a-record-example",level:3},{value:"Iterating Over TypeScript Dictionaries",id:"iterating-over-typescript-dictionaries",level:2},{value:"Iterating Over TypeScript Object Dictionaries with <code>for...in</code> Loop",id:"iterating-over-typescript-object-dictionaries-with-forin-loop",level:3},{value:"Iterating Over TypeScript Dictionaries with <code>for...of</code> Loop",id:"iterating-over-typescript-dictionaries-with-forof-loop",level:3},{value:"Iterating Over TypeScript Dictionaries with Array Methods",id:"iterating-over-typescript-dictionaries-with-array-methods",level:3},{value:"How to Solve TypeScript Mapped Type Keys Problem: Type Assertion with <code>as</code>",id:"how-to-solve-typescript-mapped-type-keys-problem-type-assertion-with-as",level:4},{value:"Type Narrowing for Key Lookups",id:"type-narrowing-for-key-lookups",level:2},{value:"TypeScript Dictionaries with the <code>Map</code> Prototype",id:"typescript-dictionaries-with-the-map-prototype",level:2},{value:"Closed Set Dictionaries with TypeScript <code>Map</code>",id:"closed-set-dictionaries-with-typescript-map",level:3},{value:"Open Ended Dictionaries with TypeScript <code>Map</code>",id:"open-ended-dictionaries-with-typescript-map",level:3},{value:"Advanced Mapped Types to Dynamically Create Dictionaries",id:"advanced-mapped-types-to-dynamically-create-dictionaries",level:2},{value:"Dictionary Validation with Custom Types",id:"dictionary-validation-with-custom-types",level:2},{value:"Summary",id:"summary",level:2}],d={toc:y},m="wrapper";function h(e){var{components:t}=e,n=o(e,["components"]);return(0,i.yg)(m,r(function(e){for(var t=1;t<arguments.length;t++){var n=null!=arguments[t]?arguments[t]:{},i=Object.keys(n);"function"==typeof Object.getOwnPropertySymbols&&(i=i.concat(Object.getOwnPropertySymbols(n).filter((function(e){return Object.getOwnPropertyDescriptor(n,e).enumerable})))),i.forEach((function(t){a(e,t,n[t])}))}return e}({},d,n),{components:t,mdxType:"MDXLayout"}),(0,i.yg)("p",null,(0,i.yg)("strong",{parentName:"p"},"This article was last updated on November 11, 2024 to include advanced techniques for TypeScript dictionary validation and best practices for ensuring type safety in dynamic and complex data structures.")),(0,i.yg)("h2",{id:"introduction"},"Introduction"),(0,i.yg)("p",null,"Dictionaries are one of the crucial data structures in programming. Dictionaries or maps are useful for describing key-value paired objects in an application. They can be implemented using ",(0,i.yg)("inlineCode",{parentName:"p"},"Object")," and ",(0,i.yg)("inlineCode",{parentName:"p"},"Map")," instances in JavaScript. In TypeScript, dictionaries are also implemented as a ",(0,i.yg)("inlineCode",{parentName:"p"},"Record<>")," with related types for its keys and values."),(0,i.yg)("p",null,"TypeScript necessitates proper type annotation to a dictionary's keys and values. So, in this post, we explore how type safe dictionaries in TypeScript are implemented with necessary type definitions, annotations and specificity."),(0,i.yg)("p",null,"We first make sense of what dictionaries are and go through a couple of examples which illustrate that dictionaries are collections of entries with key-value pairs which adhere to a specific structure describable by their types. Through these examples, we observe how dictionaries are implemented in JavaScript with ",(0,i.yg)("inlineCode",{parentName:"p"},"Object")," instances."),(0,i.yg)("p",null,"We then relate how dictionaries in TypeScript demand proper type definition and annotation in order to achieve type safety and specificity and see how to apply proper types for dictionary keys and entries. We elaborate with examples how to implement open ended TypeScript dictionaries with index signatures and closed set dictionaries with TypeScript generic mapped types."),(0,i.yg)("p",null,"Towards the later half, we cover type safe approaches to iterating over TS ",(0,i.yg)("inlineCode",{parentName:"p"},"Object")," based dictionaries with ",(0,i.yg)("inlineCode",{parentName:"p"},"for...in")," and ",(0,i.yg)("inlineCode",{parentName:"p"},"for...of")," loops. We consider dictionary data extracted with ",(0,i.yg)("inlineCode",{parentName:"p"},"Object.keys()"),", ",(0,i.yg)("inlineCode",{parentName:"p"},"Object.values()")," and ",(0,i.yg)("inlineCode",{parentName:"p"},"Object.entries"),", and traversing them using ",(0,i.yg)("inlineCode",{parentName:"p"},"Array")," iterators like ",(0,i.yg)("inlineCode",{parentName:"p"},"Array.prototype.map()")," as an example. We also encounter a TypeScript ",(0,i.yg)("inlineCode",{parentName:"p"},"7503")," type incompatibility error while iterating over dictionary keys returned by ",(0,i.yg)("inlineCode",{parentName:"p"},"Object.keys()")," with a ",(0,i.yg)("inlineCode",{parentName:"p"},"for...in")," loop, and address how to solve it with the type assertion ",(0,i.yg)("inlineCode",{parentName:"p"},"as")," operator."),(0,i.yg)("p",null,"Towards the end, we explore examples of implementing the same dictionary (",(0,i.yg)("inlineCode",{parentName:"p"},"fictionalDictators"),") features with the TypeScript ",(0,i.yg)("inlineCode",{parentName:"p"},"Record<>")," utility and TS ",(0,i.yg)("inlineCode",{parentName:"p"},"Map")," instances."),(0,i.yg)("p",null,"Steps we'll cover in this post:"),(0,i.yg)("ul",null,(0,i.yg)("li",{parentName:"ul"},(0,i.yg)("a",{parentName:"li",href:"#what-is-ts-dictionary"},"what is TS Dictionary")),(0,i.yg)("li",{parentName:"ul"},(0,i.yg)("a",{parentName:"li",href:"#dictionaries-in-typescript"},"Dictionaries in TypeScript")),(0,i.yg)("li",{parentName:"ul"},(0,i.yg)("a",{parentName:"li",href:"#iterating-over-typescript-dictionaries"},"Iterating Over TypeScript Dictionaries")),(0,i.yg)("li",{parentName:"ul"},(0,i.yg)("a",{parentName:"li",href:"#type-narrowing-for-key-lookups"},"Type Narrowing for Key Lookups")),(0,i.yg)("li",{parentName:"ul"},(0,i.yg)("a",{parentName:"li",href:"#typescript-dictionaries-with-the-map-prototype"},"TypeScript Dictionaries with the ",(0,i.yg)("inlineCode",{parentName:"a"},"Map")," Prototype")),(0,i.yg)("li",{parentName:"ul"},(0,i.yg)("a",{parentName:"li",href:"#advanced-mapped-types-to-dynamically-create-dictionaries"},"Advanced Mapped Types to Dynamically Create Dictionaries"))),(0,i.yg)("h2",{id:"prerequisites"},"Prerequisites"),(0,i.yg)("p",null,"In order to properly follow this post and test out the examples, you need to have a JavaScript engine. The discussions in this post cover intermediate-to-advanced topics in TypeScript. We expect you come with enough knowledge about at the basics of TypeScript utility types and mapped types. It'll be useful if you have worked significantly with the JavaScript ",(0,i.yg)("a",{parentName:"p",href:"https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Object"},(0,i.yg)("inlineCode",{parentName:"a"},"Object"))," and ",(0,i.yg)("a",{parentName:"p",href:"https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Map"},(0,i.yg)("inlineCode",{parentName:"a"},"Map"))," APIs as well."),(0,i.yg)("h3",{id:"typescript-setup"},"TypeScript Setup"),(0,i.yg)("p",null,"Your JavaScript engine has to have TypeScript installed. It could be ",(0,i.yg)("a",{parentName:"p",href:"https://nodejs.org/en/download"},"Node.js")," in your local machine with TypeScript supported or you could use the ",(0,i.yg)("a",{parentName:"p",href:"https://www.typescriptlang.org/play/"},"TypeScript Playground"),"."),(0,i.yg)("h2",{id:"what-is-ts-dictionary-"},"What is TS Dictionary ?"),(0,i.yg)("p",null,"A dictionary is a data structure which contains entries with unique keys that describe its content. Each key typically represents and maps to a value of known or generalizable type."),(0,i.yg)("p",null,"Most programming languages implement a dictionary in the form of an object with properties that are expressed with a key and its value. A trivial example of dictionary in JavaScript looks like this:"),(0,i.yg)("pre",null,(0,i.yg)("code",{parentName:"pre",className:"language-tsx"},'const dictators = {\n  ah_aladeen: "Admiral Haffaz Aladeen",\n  bg_brother: "Big Brother",\n  cr_snow: "Coriolanus Snow",\n  es_palpatine: "Emperor Sheev Palpatine",\n};\n')),(0,i.yg)("p",null,'The term "dictionary" belongs mainly to Python. It is synonymous with the hash or hash map data structure in Ruby and hash tables in Java. A dictionary is also often referred to as a map.'),(0,i.yg)("h3",{id:"how-dictionaries-are-implemented-in-javascript"},"How Dictionaries are Implemented in JavaScript"),(0,i.yg)("p",null,"JavaScript has a legacy of implementing dictionaries with the help of basic objects -- which are instances of the ",(0,i.yg)("inlineCode",{parentName:"p"},"Object")," prototype. ES2015 brings a dedicated JavaScript ",(0,i.yg)("inlineCode",{parentName:"p"},"Map")," prototype which helps implement dictionaries in JavaScript using key-value tuples in a multidimensional ",(0,i.yg)("inlineCode",{parentName:"p"},"Array")," instance."),(0,i.yg)("p",null,"In this section, we briefly look at how object based dictionaries are implemented in JavaScript."),(0,i.yg)("h4",{id:"javascript-dictionaries-with-object-literals"},"JavaScript Dictionaries with ",(0,i.yg)("inlineCode",{parentName:"h4"},"Object")," Literals"),(0,i.yg)("p",null,"In the above ",(0,i.yg)("inlineCode",{parentName:"p"},"dictators")," example, we are using a JavaScript object literal to define a list of dictators. The property keys describe a dictator's lowercase name / initials. We have the values of each key as ",(0,i.yg)("inlineCode",{parentName:"p"},"string")," literals. Dictionaries are what they are called because all their values are describable by some type, such as a ",(0,i.yg)("inlineCode",{parentName:"p"},"string"),". In other words, the values of a dictionary are always some consistently structured object."),(0,i.yg)("p",null,"For example, the ",(0,i.yg)("inlineCode",{parentName:"p"},"dictators")," dictionary above could also have entries with consistently shaped ",(0,i.yg)("inlineCode",{parentName:"p"},"Object")," values, like this:"),(0,i.yg)("pre",null,(0,i.yg)("code",{parentName:"pre",className:"language-tsx"},'const dictators = {\n  ah_aladeen: {\n    name: "Admiral Haffaz Aladeen",\n    dominion: "North African Republic of Wadiya",\n  },\n  bg_brother: {\n    name: "Big Brother",\n    dominion: "Oceania",\n  },\n  cr_snow: {\n    name: "Coriolanus Snow",\n    dominion: "The Capitol of Anem",\n  },\n  es_palpatine: {\n    name: "Emperor Sheev Palpatine",\n    dominion: "Star Wars Galaxy, First Order",\n  },\n};\n')),(0,i.yg)("p",null,"This precisely means that in a dictionary, the items are composed in a well defined shape - rather than assuming random shapes from inconsistent property names and values."),(0,i.yg)("h4",{id:"javascript-dictionaries-with-object-prototype"},"JavaScript Dictionaries with ",(0,i.yg)("inlineCode",{parentName:"h4"},"Object")," Prototype"),(0,i.yg)("p",null,"In JavaScript, we can create a dictionary using the ",(0,i.yg)("inlineCode",{parentName:"p"},"Object")," constructor and then add items:"),(0,i.yg)("pre",null,(0,i.yg)("code",{parentName:"pre",className:"language-tsx"},'const dictators = new Object();\n\ndictators["ah_aladeen"] = "Admiral Haffaz Aladeen";\ndictators.bg_brother = "Big Brother";\nconsole.log(dictators); // Object { ah_aladeen: "Admiral Haffaz Aladeen", bg_brother: "Big Brother" }\n')),(0,i.yg)("p",null,"A different approach to creating dictionaries from a prototype is using the ",(0,i.yg)("inlineCode",{parentName:"p"},"Object.create()")," method:"),(0,i.yg)("pre",null,(0,i.yg)("code",{parentName:"pre",className:"language-tsx"},'const dictators_dictionary = { title: "The Ultimate Dictionary of Dictators" };\n\nconst dictators = Object.create(dictators_dictionary);\n\ndictators["ah_aladeen"] = "Admiral Haffaz Aladeen";\ndictators.bg_brother = "Big Brother";\n\nconsole.log(dictators); // Object { ah_aladeen: "Admiral Haffaz Aladeen", bg_brother: "Big Brother" }\nconsole.log(dictators.title); // "The Ultimate Dictionary of Dictators"\n')),(0,i.yg)("p",null,"Dictionaries created from a prototype give access to inherited properties. You can see this in the ",(0,i.yg)("inlineCode",{parentName:"p"},"title")," field of the above ",(0,i.yg)("inlineCode",{parentName:"p"},"dictators")," object, which is derived from the ",(0,i.yg)("inlineCode",{parentName:"p"},"dictators_dictionary")," prototype."),(0,i.yg)("admonition",{type:"tip"},(0,i.yg)("p",{parentName:"admonition"},"Overall, it is important that a JavaScript object based dictionary maintains consistent structure in its item values.")),(0,i.yg)("h2",{id:"dictionaries-in-typescript"},"Dictionaries in TypeScript"),(0,i.yg)("p",null,"In TypeScript, the structure of a dictionary is described by respective types for its keys and values. Type annotation of dictionary entries becomes mandatory in TypeScript in order to achieve type safety and precise type specificity. Otherwise, we are subject to TypeScript compiler errors and brittle code that is dangerous for maintainability and scalability."),(0,i.yg)("h3",{id:"why-dictionary-type-safety-is-needed-in-typescript"},"Why Dictionary Type Safety is Needed in TypeScript"),(0,i.yg)("p",null,"Since TypeScript applies a structural typing system, randomly shaped objects pose a challenge while implementing dictionaries in TypeScript. Structurally inconsistent values of dictionary key and values throw type errors in TypeScript."),(0,i.yg)("p",null,"One common example of dictionary type errors, as discussed later in a ",(0,i.yg)("a",{parentName:"p",href:"#how-to-solve-typescript-mapped-type-keys-problem-type-assertion-with-as"},"later section"),", is while iterating over a dictionary via its keys extracted in an array with ",(0,i.yg)("inlineCode",{parentName:"p"},"Object.keys()"),"."),(0,i.yg)("p",null,"Also, TypeScript's structural typing complements the consistency of structure sought in dictionary entries. So, it is essential that we annotate well-defined types to dictionary keys and values in TypeScript."),(0,i.yg)("h2",{id:"dictionaries-in-typescript-how-to-apply-type-safety"},"Dictionaries in TypeScript: How to Apply Type Safety"),(0,i.yg)("p",null,"Implementing type-safe dictionaries in TypeScript involves annotating types to both the keys and the values of the items. Additionally, we can also apply type specificity of dictionary keys and values."),(0,i.yg)("p",null,"While some dictionaries may have less constrained types -- for example, as implemented with index signature -- others can achieve accurate specificity by imposing type constraints with union of keys, the ",(0,i.yg)("inlineCode",{parentName:"p"},"in")," narrowing operator and the ",(0,i.yg)("inlineCode",{parentName:"p"},"as")," type assertion operator."),(0,i.yg)("h3",{id:"typesafe-dictionaries-in-typescript-object-examples"},"TypeSafe Dictionaries in TypeScript: Object Examples"),(0,i.yg)("p",null,"In this section, we cover some of the common examples of applying type safety to ",(0,i.yg)("inlineCode",{parentName:"p"},"Object")," based dictionaries in TypeScript."),(0,i.yg)("h4",{id:"typescript-dictionaries-with-object-index-signatures"},"TypeScript Dictionaries with Object Index Signatures"),(0,i.yg)("p",null,"We can implement a open ended dictionary in TypeScript with index signatures. For example, the first ",(0,i.yg)("inlineCode",{parentName:"p"},"dictators")," dictionary with a ",(0,i.yg)("inlineCode",{parentName:"p"},"string")," value we considered in this post can be annotated as below:"),(0,i.yg)("pre",null,(0,i.yg)("code",{parentName:"pre",className:"language-ts"},'type TDictators = {\n  [dict_key: string]: string;\n};\n\nconst dictators: TDictators = {\n  ah_aladeen: "Admiral Haffaz Aladeen",\n  bg_brother: "Big Brother",\n  cr_snow: "Coriolanus Snow",\n  es_palpatine: "Emperor Sheev Palpatine",\n};\n\nconsole.log(dictators.ah_aladeen); // "Admiral Haffaz Aladeen"\n')),(0,i.yg)("p",null,"Here, we first defined a ",(0,i.yg)("inlineCode",{parentName:"p"},"TDictators")," type with index signature syntax and then annotated the ",(0,i.yg)("inlineCode",{parentName:"p"},"dictators")," object with ",(0,i.yg)("inlineCode",{parentName:"p"},"TDictators"),"."),(0,i.yg)("p",null,"Notice, we have to annotate both the key and value of the dictionary items. Notice also that this dictionary is a perpetually extendable one. That's because, with the index signature type above, we have annotated the keys to be ",(0,i.yg)("strong",{parentName:"p"},(0,i.yg)("em",{parentName:"strong"},"any"))," ",(0,i.yg)("inlineCode",{parentName:"p"},"string"),". And we want the value to be ",(0,i.yg)("inlineCode",{parentName:"p"},"string")," as well."),(0,i.yg)("p",null,"The value of a TypeScript dictionary entry can be any valid type, in order to reflect a consistent structure demanded by dictionary entries. For example, it can be an object of the following shape:"),(0,i.yg)("pre",null,(0,i.yg)("code",{parentName:"pre",className:"language-ts"},"type TDictatorInfo = {\n  name: string;\n  dominion: string;\n};\n")),(0,i.yg)("p",null,"And this allows us to express the ",(0,i.yg)("inlineCode",{parentName:"p"},"dictators")," dictionary values with an object that conforms to this shape:"),(0,i.yg)("pre",null,(0,i.yg)("code",{parentName:"pre",className:"language-ts"},'type TDictatorInfo = {\n  name: string;\n  dominion: string;\n};\n\ntype TDictators = {\n  [dict_key: string]: TDictatorInfo;\n};\n\nconst dictators: TDictators = {\n  ah_aladeen: {\n    name: "Admiral Haffaz Aladeen",\n    dominion: "North African Republic of Wadiya",\n  },\n  bg_brother: {\n    name: "Big Brother",\n    dominion: "Oceania",\n  },\n  cr_snow: {\n    name: "Coriolanus Snow",\n    dominion: "The Capitol of Anem",\n  },\n  es_palpatine: {\n    name: "Emperor Sheev Palpatine",\n    dominion: "Star Wars Galaxy, First Order",\n  },\n};\n\ndictators["sl_snoke"] = {\n  name: "Supreme Leader Snoke",\n  dominion: "Star Wars Galaxy, First Order",\n};\n')),(0,i.yg)("p",null,"Notice, with the above definition / annotation changes, the ",(0,i.yg)("inlineCode",{parentName:"p"},"dictators")," dictionary remains open ended since keys can still be any ",(0,i.yg)("inlineCode",{parentName:"p"},"string"),". So, we are able to keep adding entries, as we are doing with the ",(0,i.yg)("inlineCode",{parentName:"p"},'dictators["sl_snoke"] =')," assignment."),(0,i.yg)("p",null,"However, if we try to add a value inconsistent with ",(0,i.yg)("inlineCode",{parentName:"p"},"TDictatorInfo"),", we get TypeScript errors:"),(0,i.yg)("pre",null,(0,i.yg)("code",{parentName:"pre",className:"language-ts"},'dictators["sl_kylo"] = "Supreme Leader Kylo Ern"; // Type \'string\' is not assignable to type \'TDictatorInfo\'.(2322)\ndictators["sl_kylo"] = {\n  name: "Supreme Leader Kylo Ern",\n  nick_name: "Ben Solo",\n}; // Object literal may only specify known properties, and \'nick_name\' does not exist in type \'TDictatorInfo\'.(2353)\n')),(0,i.yg)("p",null,"Here, when we try to assign a ",(0,i.yg)("inlineCode",{parentName:"p"},"string")," value to the item, TypeScript throws ",(0,i.yg)("inlineCode",{parentName:"p"},"2322")," error. And when we add an inconsistent property with unknown / missing type, we get a ",(0,i.yg)("inlineCode",{parentName:"p"},"2353")," error."),(0,i.yg)("p",null,"So, as we can already see, proper type annotation of dictionaries proves useful for the stability of the codebase."),(0,i.yg)("admonition",{type:"tip"},(0,i.yg)("p",{parentName:"admonition"},"Take note that TS dictionaries with index signatures are open ended and extendable, as we can add as many items to the dictionary as we want.")),(0,i.yg)("h4",{id:"reusable-typescript-dictionaries-with-generic-mapped-types"},"Reusable TypeScript Dictionaries with Generic Mapped Types"),(0,i.yg)("p",null,"We can limit the keys of a dictionary with union of keys. In such cases, we need to derive a generic mapped type to describe the dictionary by narrowing down a list of keys with TypeScript's ",(0,i.yg)("inlineCode",{parentName:"p"},"in")," operator. For example:"),(0,i.yg)("pre",null,(0,i.yg)("code",{parentName:"pre",className:"language-ts"},"type TDictionary<Keys extends string | number | symbol, Value> = {\n  [dict_key in Keys]: Value;\n};\n")),(0,i.yg)("p",null,"The ",(0,i.yg)("inlineCode",{parentName:"p"},"TDictionary")," type now is a generic type that accepts ",(0,i.yg)("inlineCode",{parentName:"p"},"Keys")," and ",(0,i.yg)("inlineCode",{parentName:"p"},"Value")," as type parameters. ",(0,i.yg)("inlineCode",{parentName:"p"},"TDictionary")," is also a mapped type that limits its keys to the members of ",(0,i.yg)("inlineCode",{parentName:"p"},"Keys")," union type. ",(0,i.yg)("inlineCode",{parentName:"p"},"Keys")," is a union type because it is being looped over by the ",(0,i.yg)("inlineCode",{parentName:"p"},"in")," operator. And we want ",(0,i.yg)("inlineCode",{parentName:"p"},"Keys")," to be only among ",(0,i.yg)("inlineCode",{parentName:"p"},"string"),", ",(0,i.yg)("inlineCode",{parentName:"p"},"number")," and ",(0,i.yg)("inlineCode",{parentName:"p"},"symbol")," primitive types. So, we are applying type specificity on several levels to consolidate type safety besides code reusability."),(0,i.yg)("p",null,"Now we can use this type to constrain the dictionary entries to a certain set of keys:"),(0,i.yg)("pre",null,(0,i.yg)("code",{parentName:"pre",className:"language-ts"},'type TDictionary<Keys extends string | number | symbol, Value> = {\n  [dict_key in Keys]: Value;\n};\n\ntype TFictionalDictatorKeys =\n  | "ah_aladeen"\n  | "bg_brother"\n  | "cr_snow"\n  | "es_palpatine";\n\ntype TDictatorInfo = {\n  name: string;\n  dominion: string;\n};\n\ntype TFictionalDictators = TDictionary<TFictionalDictatorKeys, TDictatorInfo>;\n\nconst fictionalDictators: Partial<TFictionalDictators> = new Object();\n\nfictionalDictators["ah_aladeen"] = {\n  name: "Admiral Haffaz Aladeen",\n  dominion: "North African Republic of Wadiya",\n}; // Does okay. No error.\n\nfictionalDictators["sl_snoke"] = {\n  name: "Supreme Leader Snoke",\n  dominion: "Star Wars Galaxy, First Order",\n}; // Throws error: Property \'sl_snoke\' does not exist on type \'Partial<TFictionalDictators>\'.(7053)\n')),(0,i.yg)("p",null,"Here, we limit the keys of the ",(0,i.yg)("inlineCode",{parentName:"p"},"TFictionalDictators")," type with the ",(0,i.yg)("inlineCode",{parentName:"p"},"TFictionalDictatorKeys")," union type and set the type for the value to ",(0,i.yg)("inlineCode",{parentName:"p"},"TDictatorInfo")," type. We are also partializing the type for ",(0,i.yg)("inlineCode",{parentName:"p"},"fictionalDictators")," dictionary object with the ",(0,i.yg)("inlineCode",{parentName:"p"},"Partial<>")," transformation utility. Partializing allows us to instantiate ",(0,i.yg)("inlineCode",{parentName:"p"},"fictionalDictators")," without initializing any property -- as with no object passed to ",(0,i.yg)("inlineCode",{parentName:"p"},"new Object()"),"."),(0,i.yg)("p",null,"Notice, an entry with acceptable key (",(0,i.yg)("inlineCode",{parentName:"p"},'"ah_aladeen"'),") encounters no complain. However, when we try to add a non-member key (",(0,i.yg)("inlineCode",{parentName:"p"},'"sl_snoke"'),"), TypeScript throws ",(0,i.yg)("inlineCode",{parentName:"p"},"7053")," error."),(0,i.yg)("p",null,"Since ",(0,i.yg)("inlineCode",{parentName:"p"},"TDictionary<>")," is now a generic type, we can reuse it for a dictionary with ",(0,i.yg)("inlineCode",{parentName:"p"},"Value"),"s that are ",(0,i.yg)("inlineCode",{parentName:"p"},"string"),":"),(0,i.yg)("pre",null,(0,i.yg)("code",{parentName:"pre",className:"language-ts"},'type TFictionalDictators = TDictionary<TFictionalDictatorKeys, string>;\n\nconst fictionalDictators: Partial<TFictionalDictators> = new Object();\n\nfictionalDictators["ah_aladeen"] = "Admiral Haffaz Aladeen";\nconsole.log(fictionalDictators); // Object { ah_aladeen: "Admiral Haffaz Aladeen" }\n')),(0,i.yg)("h3",{id:"type-safe-dictionaries-in-typescript-a-record-example"},"Type Safe Dictionaries in TypeScript: A ",(0,i.yg)("inlineCode",{parentName:"h3"},"Record<>")," Example"),(0,i.yg)("p",null,"The reusable dictionary ",(0,i.yg)("inlineCode",{parentName:"p"},"TDictionary<>")," type that we have defined implements the features of TypeScript's ",(0,i.yg)("inlineCode",{parentName:"p"},"Record<>")," utility type. Similar to our implementation in ",(0,i.yg)("inlineCode",{parentName:"p"},"TDictionary<Keys, Value>"),", ",(0,i.yg)("inlineCode",{parentName:"p"},"Record<>")," is a generic type that accepts the keys and value types as type parameters to map a set of keys to a value that represents a data entity or record."),(0,i.yg)("admonition",{type:"tip"},(0,i.yg)("p",{parentName:"admonition"},"Although TypeScript ",(0,i.yg)("inlineCode",{parentName:"p"},"Record<>")," is often used to represent and manipulate database record types, we can use it to annotate TS ",(0,i.yg)("inlineCode",{parentName:"p"},"Object")," based dictionaries as well.")),(0,i.yg)("p",null,"Below is the similar annotation of the ",(0,i.yg)("inlineCode",{parentName:"p"},"fictionalDictators")," dictionary with TypeScript's ",(0,i.yg)("inlineCode",{parentName:"p"},"Record<>")," utility:"),(0,i.yg)("pre",null,(0,i.yg)("code",{parentName:"pre",className:"language-ts"},'type TFictionalDictatorKeys =\n  | "ah_aladeen"\n  | "bg_brother"\n  | "cr_snow"\n  | "es_palpatine";\n\ntype TDictatorInfo = {\n  name: string;\n  dominion: string;\n};\n\ntype TFictionalDictators = Record<TFictionalDictatorKeys, TDictatorInfo>;\n\nconst fictionalDictators: Partial<TFictionalDictators> = {};\n\nfictionalDictators["ah_aladeen"] = {\n  name: "Admiral Haffaz Aladeen",\n  dominion: "North African Republic of Wadiya",\n}; // Does okay. No error.\n\nfictionalDictators["sl_snoke"] = {\n  name: "Supreme Leader Snoke",\n  dominion: "Star Wars Galaxy, First Order",\n}; // Same 7053 error due to union member constraint\n')),(0,i.yg)("h2",{id:"iterating-over-typescript-dictionaries"},"Iterating Over TypeScript Dictionaries"),(0,i.yg)("p",null,"Type safety and type specificity of TypeScript dictionaries prove important and offer convenience while iterating over a dictionary. This is particularly because individual keys or values or entries have to be consistently typed for the iteration operations."),(0,i.yg)("p",null,"Most often, as in the examples we have explored so far, the types of the keys and values need to be in the form of predefined, and reusable type definitions so that all can be used as a suite accompanies with the main dictionary type:"),(0,i.yg)("pre",null,(0,i.yg)("code",{parentName:"pre",className:"language-ts"},'type TDictionary<Keys extends string | number | symbol, Value> = {\n  [dict_key in Keys]: Value;\n};\n\ntype TFictionalDictatorKeys =\n  | "ah_aladeen"\n  | "bg_brother"\n  | "cr_snow"\n  | "es_palpatine";\n\ntype TDictatorInfo = {\n  name: string;\n  dominion: string;\n};\n\ntype TFictionalDictators = TDictionary<TFictionalDictatorKeys, TDictatorInfo>;\n\nconst fictionalDictators: Partial<TFictionalDictators> = {};\n')),(0,i.yg)("p",null,"There are various use cases and hence various ways where a dictionary is iterated over. Most legacy code involve iterating over a dictionary with the keys extracted in an array with ",(0,i.yg)("inlineCode",{parentName:"p"},"Object.keys()")," method. Similar extraction of dictionary entries with ",(0,i.yg)("inlineCode",{parentName:"p"},"Object.entries()")," and only values with ",(0,i.yg)("inlineCode",{parentName:"p"},"Object.values()")," are also often used."),(0,i.yg)("p",null,"For iteration, we can use the ",(0,i.yg)("inlineCode",{parentName:"p"},"for...in")," loop directly on the dictionary object itself or the ",(0,i.yg)("inlineCode",{parentName:"p"},"for...of")," loop on the extracted arrays. We can also use regular JS iterators like ",(0,i.yg)("inlineCode",{parentName:"p"},"Array.prototype.map()"),", ",(0,i.yg)("inlineCode",{parentName:"p"},"Array.prototype.forEach()"),", ",(0,i.yg)("inlineCode",{parentName:"p"},"Array.prototype.reduce()")," and the likes to match our use cases."),(0,i.yg)("p",null,"In the sections that follow, we discuss with examples the type safety aspects of some of these iteration APIs."),(0,i.yg)("p",null,"For these examples, we use the following types and ",(0,i.yg)("inlineCode",{parentName:"p"},"fictionalDictators")," dictionary object:"),(0,i.yg)("details",null,(0,i.yg)("summary",null,"Show example dictionary object and types"),(0,i.yg)("pre",null,(0,i.yg)("code",{parentName:"pre",className:"language-ts"},'type TDictionary<Keys extends string | number | symbol, Value> = {\n  [dict_key in Keys]: Value;\n};\n\ntype TFictionalDictatorKeys =\n  | "ah_aladeen"\n  | "bg_brother"\n  | "cr_snow"\n  | "es_palpatine";\n\ntype TDictatorInfo = {\n  name: string;\n  dominion: string;\n};\n\ntype TFictionalDictators = TDictionary<TFictionalDictatorKeys, TDictatorInfo>;\n\nconst fictionalDictators: TFictionalDictators = {\n  ah_aladeen: {\n    name: "Admiral Haffaz Aladeen",\n    dominion: "North African Republic of Wadiya",\n  },\n  bg_brother: {\n    name: "Big Brother",\n    dominion: "Oceania",\n  },\n  cr_snow: {\n    name: "Coriolanus Snow",\n    dominion: "The Capitol of Anem",\n  },\n  es_palpatine: {\n    name: "Emperor Sheev Palpatine",\n    dominion: "Star Wars Galaxy, First Order",\n  },\n};\n'))),(0,i.yg)("h3",{id:"iterating-over-typescript-object-dictionaries-with-forin-loop"},"Iterating Over TypeScript Object Dictionaries with ",(0,i.yg)("inlineCode",{parentName:"h3"},"for...in")," Loop"),(0,i.yg)("p",null,"We have a ",(0,i.yg)("inlineCode",{parentName:"p"},"fictionalDictators")," object and we can iterate over it directly with the ",(0,i.yg)("inlineCode",{parentName:"p"},"for...in")," loop. The ",(0,i.yg)("inlineCode",{parentName:"p"},"for...in")," loop gives access to the keys of the dictionary with which we can attempt to access the entries."),(0,i.yg)("p",null,"For example, when we want to store the fictional dictator names in an array:"),(0,i.yg)("pre",null,(0,i.yg)("code",{parentName:"pre",className:"language-ts"},"const fictionalDictatorNames = [];\n\nfor (const key in fictionalDictators) {\n  fictionalDictatorNames.push(fictionalDictators[key]?.name); // Gives 7053 error\n}\n\nconsole.log(fictionalDictatorNames);\n")),(0,i.yg)("p",null,"With the above code, we try to populate the ",(0,i.yg)("inlineCode",{parentName:"p"},"fictionalDictatorNames")," array with the names of the dictators from the ",(0,i.yg)("inlineCode",{parentName:"p"},"fictionalDicatiors")," dictionary."),(0,i.yg)("p",null,"However, we encounter this big error:"),(0,i.yg)("pre",null,(0,i.yg)("code",{parentName:"pre",className:"language-ts"},"Element implicitly has an 'any' type because expression of type 'string' can't be used to index type 'TFictionalDictators'.\nNo index signature with a parameter of type 'string' was found on type 'TFictionalDictators'.(7053)\n")),(0,i.yg)("p",null,"We'll come to what it stands for and where it originates from in a later section when we encounter it again with ",(0,i.yg)("inlineCode",{parentName:"p"},"Object.keys()"),", but we can fix this with type assertion using the TypeScript ",(0,i.yg)("inlineCode",{parentName:"p"},"as")," operator:"),(0,i.yg)("pre",null,(0,i.yg)("code",{parentName:"pre",className:"language-ts"},'const fictionalDictatorNames = [];\n\nfor (const key in fictionalDictators) {\n  fictionalDictatorNames.push(\n    // highlight-next-line\n    fictionalDictators[key as TFictionalDictatorKeys]?.name,\n  );\n}\n\nconsole.log(fictionalDictatorNames); // ["Admiral Haffaz Aladeen", "Big Brother", "Coriolanus Snow", "Emperor Sheev Palpatine"]\n')),(0,i.yg)("p",null,"And this time, we get the desired array of dictator names without error."),(0,i.yg)("h3",{id:"iterating-over-typescript-dictionaries-with-forof-loop"},"Iterating Over TypeScript Dictionaries with ",(0,i.yg)("inlineCode",{parentName:"h3"},"for...of")," Loop"),(0,i.yg)("p",null,"The ",(0,i.yg)("inlineCode",{parentName:"p"},"for...of")," loop can be used to iterate over array of keys, values and key-value tuples."),(0,i.yg)("p",null,"For example, we can get the same ",(0,i.yg)("inlineCode",{parentName:"p"},"fictionalDictatorNames")," array in the previous example by extracting the keys first in a separate array with ",(0,i.yg)("inlineCode",{parentName:"p"},"Object.keys()"),". And then by iterating over the array with ",(0,i.yg)("inlineCode",{parentName:"p"},"for...of")," loop to populate ",(0,i.yg)("inlineCode",{parentName:"p"},"fictionalDictatorNames"),":"),(0,i.yg)("pre",null,(0,i.yg)("code",{parentName:"pre",className:"language-ts"},'const dictatorKeysArray = Object.keys(fictionalDictators);\nconst fictionalDictatorNames = [];\n\n// highlight-start\nfor (const key of dictatorKeysArray) {\n  fictionalDictatorNames.push(\n    fictionalDictators[key as TFictionalDictatorKeys]?.name,\n  );\n}\n// highlight-end\n\nconsole.log(fictionalDictatorNames); // ["Admiral Haffaz Aladeen", "Big Brother", "Coriolanus Snow", "Emperor Sheev Palpatine"]\n')),(0,i.yg)("p",null,"Notice this time too, we need to apply type assertion with the ",(0,i.yg)("inlineCode",{parentName:"p"},"as")," operator. Otherwise, we get the same ",(0,i.yg)("inlineCode",{parentName:"p"},"7053")," error."),(0,i.yg)("p",null,"Let's cover a couple of more examples of using the ",(0,i.yg)("inlineCode",{parentName:"p"},"for...of")," loop. In the code snippet below, we iterate over the dictionary values and also the key-value entries themselves:"),(0,i.yg)("pre",null,(0,i.yg)("code",{parentName:"pre",className:"language-ts"},'const dictatorsInfoArray = Object.values(fictionalDictators);\nconst fictionalDictatorNames = [];\n\nfor (const value of dictatorsInfoArray) {\n  fictionalDictatorNames.push(value?.name);\n}\nconsole.log(fictionalDictatorNames); // ["Admiral Haffaz Aladeen", "Big Brother", "Coriolanus Snow", "Emperor Sheev Palpatine"]\n\nconst dictatorItemsArray = Object.entries(fictionalDictators);\nconst fictionalDictatorList = [];\n\nfor (const entry of dictatorItemsArray) {\n  fictionalDictatorList.push(entry[1]);\n}\n\nconsole.log(fictionalDictatorList);\n')),(0,i.yg)("p",null,"In the first part that involves the values extracted with ",(0,i.yg)("inlineCode",{parentName:"p"},"Object.values()"),", we iterated over the ",(0,i.yg)("inlineCode",{parentName:"p"},"dictatorsInfoArray")," array and used each ",(0,i.yg)("inlineCode",{parentName:"p"},"value")," to populate the ",(0,i.yg)("inlineCode",{parentName:"p"},"fictionalDictatorNames")," like before, but this time without utilizing the keys."),(0,i.yg)("p",null,"In the second part, we extracted the dictionary entries with ",(0,i.yg)("inlineCode",{parentName:"p"},"Object.entries()")," which gives an array of key-value tuples. We then iterate over the array and populate the ",(0,i.yg)("inlineCode",{parentName:"p"},"fictionalDictatorList")," array with the dictionary entry values."),(0,i.yg)("p",null,"Notice, in both instances, we didn't need to apply any type assertion like we had to with ",(0,i.yg)("inlineCode",{parentName:"p"},"Object.keys()"),". The respective types for the values and entries are assigned by TypeScript's intelligent type inference."),(0,i.yg)("p",null,"The ",(0,i.yg)("inlineCode",{parentName:"p"},"fictionalDictatorList")," ends up being an array of ",(0,i.yg)("inlineCode",{parentName:"p"},"TDictatorInfo")," objects."),(0,i.yg)("details",null,(0,i.yg)("summary",null,"Show `fictionalDictatorList` array"),(0,i.yg)("pre",null,(0,i.yg)("code",{parentName:"pre",className:"language-ts"},'[\n  {\n    name: "Admiral Haffaz Aladeen",\n    dominion: "North African Republic of Wadiya",\n  },\n  {\n    name: "Big Brother",\n    dominion: "Oceania",\n  },\n  {\n    name: "Coriolanus Snow",\n    dominion: "The Capitol of Anem",\n  },\n  {\n    name: "Emperor Sheev Palpatine",\n    dominion: "Star Wars Galaxy, First Order",\n  },\n];\n'))),(0,i.yg)("p",null,"The original ",(0,i.yg)("inlineCode",{parentName:"p"},"dictatorItemsArray")," entries generated by ",(0,i.yg)("inlineCode",{parentName:"p"},"Object.entries(fictionalDictators)")," is an array of dictionary key-value tuples."),(0,i.yg)("details",null,(0,i.yg)("summary",null,"Show `dictatorItemsArray`"),(0,i.yg)("pre",null,(0,i.yg)("code",{parentName:"pre",className:"language-ts"},'[\n  [\n    "ah_aladeen",\n    {\n      name: "Admiral Haffaz Aladeen",\n      dominion: "North African Republic of Wadiya",\n    },\n  ],\n  [\n    "bg_brother",\n    {\n      name: "Big Brother",\n      dominion: "Oceania",\n    },\n  ],\n  [\n    "cr_snow",\n    {\n      name: "Coriolanus Snow",\n      dominion: "The Capitol of Anem",\n    },\n  ],\n  [\n    "es_palpatine",\n    {\n      name: "Emperor Sheev Palpatine",\n      dominion: "Star Wars Galaxy, First Order",\n    },\n  ],\n];\n'))),(0,i.yg)("p",null,"The inferred type of this object has a shape similar to the ",(0,i.yg)("inlineCode",{parentName:"p"},"Map")," prototype and it looks as below:"),(0,i.yg)("pre",null,(0,i.yg)("code",{parentName:"pre",className:"language-ts"},"type TDictatorItemsArray: [string, TDictatorInfo][]\n")),(0,i.yg)("p",null,"We cover type-safe TypeScript ",(0,i.yg)("inlineCode",{parentName:"p"},"Map")," based dictionaries in ",(0,i.yg)("a",{parentName:"p",href:"#typescript-dictionaries-with-js-map-prototype"},"this later section"),"."),(0,i.yg)("h3",{id:"iterating-over-typescript-dictionaries-with-array-methods"},"Iterating Over TypeScript Dictionaries with Array Methods"),(0,i.yg)("p",null,"It is common to use ",(0,i.yg)("inlineCode",{parentName:"p"},"Array")," iterators such as ",(0,i.yg)("inlineCode",{parentName:"p"},"Array.prototype.map()"),", ",(0,i.yg)("inlineCode",{parentName:"p"},"Array.prototype.reduce()"),", ",(0,i.yg)("inlineCode",{parentName:"p"},"Array.prototype.forEach()")," to traverse through arrays generated by ",(0,i.yg)("inlineCode",{parentName:"p"},"Object.keys()"),", ",(0,i.yg)("inlineCode",{parentName:"p"},"Object.values()")," and ",(0,i.yg)("inlineCode",{parentName:"p"},"Object.entries()"),". These iterators operate in similar ways with ",(0,i.yg)("inlineCode",{parentName:"p"},"O(n)")," complexity, so we'll just cover an example of ",(0,i.yg)("inlineCode",{parentName:"p"},"Array.prototype.map()"),"."),(0,i.yg)("p",null,"For instance, we want to map ",(0,i.yg)("inlineCode",{parentName:"p"},"fictionalDictators")," to only its dominions based on the keys extracted with ",(0,i.yg)("inlineCode",{parentName:"p"},"Object.keys()"),":"),(0,i.yg)("pre",null,(0,i.yg)("code",{parentName:"pre",className:"language-ts"},"const dictatorKeysArray = Object.keys(fictionalDictators);\nconst fictionalDictatorships = dictatorKeysArray?.map(\n  (key) => fictionalDictators[key]?.dominion,\n);\nconsole.log(fictionalDictatorships);\n")),(0,i.yg)("p",null,"Here also, we run into the same ",(0,i.yg)("inlineCode",{parentName:"p"},"7053")," error we encountered before with object keys:"),(0,i.yg)("pre",null,(0,i.yg)("code",{parentName:"pre",className:"language-ts"},"Element implicitly has an 'any' type because expression of type 'string' can't be used to index type 'TFictionalDictators'.\nNo index signature with a parameter of type 'string' was found on type 'TFictionalDictators'.(7053)\n")),(0,i.yg)("h4",{id:"how-to-solve-typescript-mapped-type-keys-problem-type-assertion-with-as"},"How to Solve TypeScript Mapped Type Keys Problem: Type Assertion with ",(0,i.yg)("inlineCode",{parentName:"h4"},"as")),(0,i.yg)("p",null,"Basically, the ",(0,i.yg)("inlineCode",{parentName:"p"},"7503")," error happens when we use the keys to iterate over a dictionary when it is an object represented by a TypeScript mapped type. Apparently, the error above points to incompatibility of the ",(0,i.yg)("inlineCode",{parentName:"p"},"string")," type of the items in the array extracted by ",(0,i.yg)("inlineCode",{parentName:"p"},"Object.keys()")," to the union keys, ",(0,i.yg)("inlineCode",{parentName:"p"},"TFictionalDictatorKeys"),", in the ",(0,i.yg)("inlineCode",{parentName:"p"},"TDictionary")," mapped type."),(0,i.yg)("p",null,"Even if we try to annotate the keys directly with ",(0,i.yg)("inlineCode",{parentName:"p"},"string[]")," or ",(0,i.yg)("inlineCode",{parentName:"p"},"TFictionalDictatorKeys")," they are still incompatible. In other words, these remain invalid:"),(0,i.yg)("pre",null,(0,i.yg)("code",{parentName:"pre",className:"language-ts"},"const dictatorKeysArray: string[] = Object.keys(fictionalDictators); // Gives same 7503 error\n\n// OR\nconst dictatorKeysArray: TFictionalDictatorKeys =\n  Object.keys(fictionalDictators); // Gives 2322 error\n")),(0,i.yg)("p",null,"Therefore, we have to assert the ",(0,i.yg)("inlineCode",{parentName:"p"},"key")," to ",(0,i.yg)("inlineCode",{parentName:"p"},"TFictionalDictatorKeys")," with the help of the ",(0,i.yg)("inlineCode",{parentName:"p"},"as")," type assertion operator:"),(0,i.yg)("pre",null,(0,i.yg)("code",{parentName:"pre",className:"language-ts"},'const dictatorKeysArray = Object.keys(fictionalDictators);\nconst fictionalDictatorships = dictatorKeysArray?.map(\n  // highlight-next-line\n  (key) => fictionalDictators[key as TFictionalDictatorKeys]?.dominion,\n);\nconsole.log(fictionalDictatorships); // ["North African Republic of Wadiya", "Oceania", "The Capitol of Anem", "Star Wars Galaxy, First Order"]\n')),(0,i.yg)("h2",{id:"type-narrowing-for-key-lookups"},"Type Narrowing for Key Lookups"),(0,i.yg)("p",null,"While dealing with dictionaries or maps in TypeScript, it becomes compulsory to handle type safety with respect to the keys. The most common scenario is digging down to the possible kinds of types for those keys so that they might prevent any sort of key lookup error. Such narrowing of types will help us ensure that we access the keys only from those sets that are known to be valid, making processes more predictable and with fewer runtime errors."),(0,i.yg)("p",null,"With dynamic keys on a dictionary, TypeScript often doesn\u2019t know if the key will exist on the dictionary. We can work around this by applying a type guard or conditional check to tell TypeScript what type we are expecting at certain points in the code, making our accessed dictionary much safer and avoiding TypeScript errors."),(0,i.yg)("p",null,"For example, consider a dictionary describing fictional characters, where each key of the dictionary is a character alias and each value provides information about the character. Here\u2019s how we can access dictionary entries safely by narrowing down the type of the key:"),(0,i.yg)("pre",null,(0,i.yg)("code",{parentName:"pre",className:"language-tsx"},'type CharacterInfo = {\n  name: string;\n  universe: string;\n};\n\ntype Characters = {\n  [key: string]: CharacterInfo;\n};\n\nconst characters: Characters = {\n  aladeen: { name: "Admiral Aladeen", universe: "Wadiya" },\n  vader: { name: "Darth Vader", universe: "Star Wars" },\n};\n\n// Type narrowing example\nfunction getCharacterInfo(characterAlias: string) {\n  if (characterAlias in characters) {\n    return characters[characterAlias];\n  }\n  return null; // Alias not found\n}\n')),(0,i.yg)("p",null,"In this example:"),(0,i.yg)("ul",null,(0,i.yg)("li",{parentName:"ul"},"We check with the in operator whether the key characterAlias exists in the dictionary characters."),(0,i.yg)("li",{parentName:"ul"},"TypeScript narrows the type of characterAlias to keys that exist within the characters dictionary, avoiding \u201ckey not found\u201d errors.")),(0,i.yg)("p",null,"Type narrowing here ensures we access only valid entries in our dictionaries, particularly useful in larger projects pulling data from dynamic sources. This stops any unexpected errors in lookup and keeps TypeScript happy, making our code much safer to maintain over time."),(0,i.yg)("h2",{id:"typescript-dictionaries-with-the-map-prototype"},"TypeScript Dictionaries with the ",(0,i.yg)("inlineCode",{parentName:"h2"},"Map")," Prototype"),(0,i.yg)("p",null,"TypeScript dictionaries can also be implemented with the ES2015 ",(0,i.yg)("inlineCode",{parentName:"p"},"Map")," prototype. The ES2015 ",(0,i.yg)("inlineCode",{parentName:"p"},"Map")," data structure is an array of key-value tuples. TypeScript offers native support for ",(0,i.yg)("inlineCode",{parentName:"p"},"Map")," data structure as a generic that accepts types for the keys and entry values as type parameters."),(0,i.yg)("h3",{id:"closed-set-dictionaries-with-typescript-map"},"Closed Set Dictionaries with TypeScript ",(0,i.yg)("inlineCode",{parentName:"h3"},"Map")),(0,i.yg)("p",null,"We can express TypeScript dictionaries with ",(0,i.yg)("inlineCode",{parentName:"p"},"new Map<Keys, Value>"),", as we did with the custom generic types such as ",(0,i.yg)("inlineCode",{parentName:"p"},"TDictionary<>")," and the ",(0,i.yg)("inlineCode",{parentName:"p"},"Record<>")," utility."),(0,i.yg)("p",null,"For example, we can re-write the ",(0,i.yg)("inlineCode",{parentName:"p"},"fictionaDictators")," dictionary with the ",(0,i.yg)("inlineCode",{parentName:"p"},"TFictionalDictatorKeys")," keyset using a ",(0,i.yg)("inlineCode",{parentName:"p"},"Map"),":"),(0,i.yg)("pre",null,(0,i.yg)("code",{parentName:"pre",className:"language-ts"},'type TDictionary<Keys extends string | number | symbol, Value> = {\n  [dict_key in Keys]: Value;\n};\n\ntype TFictionalDictatorKeys =\n  | "ah_aladeen"\n  | "bg_brother"\n  | "cr_snow"\n  | "es_palpatine";\n\ntype TDictatorInfo = {\n  name: string;\n  dominion: string;\n};\n\ntype TFictionalDictators = Map<TFictionalDictatorKeys, TDictatorInfo>;\n\nconst fictionalDictators: TFictionalDictators = new Map([\n  [\n    "ah_aladeen",\n    {\n      name: "Admiral Haffaz Aladeen",\n      dominion: "North African Republic of Wadiya",\n    },\n  ],\n  [\n    "bg_brother",\n    {\n      name: "Big Brother",\n      dominion: "Oceania",\n    },\n  ],\n]);\n\nfictionalDictators.set("cr_snow", {\n  name: "Coriolanus Snow",\n  dominion: "The Capitol of Anem",\n}); // Works okay. No error\n\nconsole.log(fictionalDictators); // Map(3)\n\nfictionalDictators.set("sl_snoke", {\n  name: "Supreme Leader Snoke",\n  dominion: "Star Wars Galaxy, First Order",\n}); // Argument of type \'"sl_snoke"\' is not assignable to parameter of type \'TFictionalDictatorKeys\'.(2345)\n')),(0,i.yg)("p",null,"You can notice, this time, we are using the TypeScript type supported ",(0,i.yg)("inlineCode",{parentName:"p"},"Map")," class. And we can use it with the same type parameters for ",(0,i.yg)("inlineCode",{parentName:"p"},"Keys")," and ",(0,i.yg)("inlineCode",{parentName:"p"},"Value"),"s as we did before with the ",(0,i.yg)("inlineCode",{parentName:"p"},"Object")," examples."),(0,i.yg)("p",null,"Notice that we are now passing a array of tuples to the ",(0,i.yg)("inlineCode",{parentName:"p"},"new Map")," initializer. This is similar to the array of tuples we get from ",(0,i.yg)("inlineCode",{parentName:"p"},"Object.entries()")," in the ",(0,i.yg)("inlineCode",{parentName:"p"},"TDictionary<>")," example with ",(0,i.yg)("inlineCode",{parentName:"p"},"Object")," instance. Take note also that we are not able to enter invalid keys (",(0,i.yg)("inlineCode",{parentName:"p"},'"sl_snoke"'),") when we limit them to a union with ",(0,i.yg)("inlineCode",{parentName:"p"},"TFictionalDictatorKeys"),"."),(0,i.yg)("h3",{id:"open-ended-dictionaries-with-typescript-map"},"Open Ended Dictionaries with TypeScript ",(0,i.yg)("inlineCode",{parentName:"h3"},"Map")),(0,i.yg)("p",null,"When we want the ",(0,i.yg)("inlineCode",{parentName:"p"},"Map")," based dictionary to be extendable, we can just make the keys to be more generous ",(0,i.yg)("inlineCode",{parentName:"p"},"string"),"s:"),(0,i.yg)("pre",null,(0,i.yg)("code",{parentName:"pre",className:"language-ts"},'// highlight-next-line\ntype TFictionalDictators = Map<string, TDictatorInfo>;\n\nconst fictionalDictators: TFictionalDictators = new Map();\n\nfictionalDictators.set("cr_snow", {\n  name: "Coriolanus Snow",\n  dominion: "The Capitol of Anem",\n});\n\nfictionalDictators.set("sl_kyloren", {\n  name: "Supreme Leader Kylo Ern",\n  dominion: "Star Wars Galaxy, First Order",\n});\n\nconsole.log(fictionalDictators); // Map(2)\n')),(0,i.yg)("h2",{id:"advanced-mapped-types-to-dynamically-create-dictionaries"},"Advanced Mapped Types to Dynamically Create Dictionaries"),(0,i.yg)("p",null,"I wanted to share some tips on handling dynamic dictionaries in TypeScript using advanced mapped types. This technique is especially helpful when we have complex dictionaries where each key needs a specific structure but the overall data type should stay consistent."),(0,i.yg)("p",null,"Let\u2019s say we have an object representing different departments in a company, where each department has a team, and each team member has attributes like name, role, and years of experience."),(0,i.yg)("pre",null,(0,i.yg)("code",{parentName:"pre",className:"language-tsx"},'type TeamMember = {\n  name: string;\n  role: string;\n  experience: number;\n};\n\ntype Departments = "engineering" | "marketing" | "sales";\n\ntype DepartmentDictionary = {\n  [K in Departments]: TeamMember[];\n};\n\nconst companyDepartments: DepartmentDictionary = {\n  engineering: [\n    { name: "Alice", role: "Developer", experience: 5 },\n    { name: "Bob", role: "DevOps Engineer", experience: 3 },\n  ],\n  marketing: [{ name: "Carol", role: "Marketing Specialist", experience: 4 }],\n  sales: [{ name: "Dave", role: "Sales Lead", experience: 6 }],\n};\n')),(0,i.yg)("ul",null,(0,i.yg)("li",{parentName:"ul"},"Defining Departments: This type sets a list of allowed department names."),(0,i.yg)("li",{parentName:"ul"},"DepartmentDictionary with Mapped Type: We use a mapped type to specify that each department (e.g., engineering, marketing) contains a list of TeamMember objects."),(0,i.yg)("li",{parentName:"ul"},"Consistent Data Structure: This approach keeps our data structured, ensuring each entry follows the same format.")),(0,i.yg)("p",null,"Advanced mapped types help us lock down the structure of dynamic dictionaries, preventing unexpected issues. By restricting keys and types in this way, we leverage TypeScript\u2019s strong type-checking, which keeps things predictable and minimizes errors."),(0,i.yg)("h2",{id:"dictionary-validation-with-custom-types"},"Dictionary Validation with Custom Types"),(0,i.yg)("p",null,"Here is a quick breakdown on how to validate dictionaries in TypeScript using custom types. This will be super helpful in keeping our dictionaries consistent and catching mistakes early, especially with complex data."),(0,i.yg)("p",null,"Imagine we have a settings dictionary for an app, where each setting needs a specific type. Using custom types, we can specify a structure that ensures each setting has the expected type."),(0,i.yg)("pre",null,(0,i.yg)("code",{parentName:"pre",className:"language-tsx"},'type SettingType = "boolean" | "string" | "number";\n\ntype AppSetting<T extends SettingType> = T extends "boolean"\n  ? boolean\n  : T extends "string"\n  ? string\n  : number;\n\ntype AppSettings = {\n  [key: string]: AppSetting<SettingType>;\n};\n\nconst settings: AppSettings = {\n  darkMode: true, // boolean type\n  theme: "light", // string type\n  timeout: 30, // number type\n};\n')),(0,i.yg)("p",null,"What\u2019s Going On Here?"),(0,i.yg)("ul",null,(0,i.yg)("li",{parentName:"ul"},"SettingType defines the allowed types."),(0,i.yg)("li",{parentName:"ul"},"AppSetting is a conditional type that maps each setting type to its correct JavaScript type."),(0,i.yg)("li",{parentName:"ul"},"AppSettings is our dictionary type, where each key must match an appropriate SettingType.")),(0,i.yg)("p",null,"When using custom types like this, TypeScript will catch mismatched types if someone tries to assign the wrong type to a setting."),(0,i.yg)("h2",{id:"summary"},"Summary"),(0,i.yg)("p",null,"In this post, we covered in significant depth how to implement properly defined and annotated dictionaries in TypeScript. We illustrated common approaches of applying type safety to TypeScript dictionaries defined with ",(0,i.yg)("inlineCode",{parentName:"p"},"Object")," and ",(0,i.yg)("inlineCode",{parentName:"p"},"Map")," APIs, the ",(0,i.yg)("inlineCode",{parentName:"p"},"Record<>")," utility type, the ",(0,i.yg)("inlineCode",{parentName:"p"},"for...in")," and ",(0,i.yg)("inlineCode",{parentName:"p"},"for...of")," loops as well as the ",(0,i.yg)("inlineCode",{parentName:"p"},"Array.prototype.map()")," method."),(0,i.yg)("p",null,"We stressed that dictionaries are composed of key-value pairs that are described by respective types in TypeScript. We acknowledged how proper type definition and annotation in ",(0,i.yg)("inlineCode",{parentName:"p"},"Object")," based dictionaries lead to consistent and type safe code that offer convenient type inference later during iteration. As part of the examples, we implemented the same ",(0,i.yg)("inlineCode",{parentName:"p"},"fictionalDictators")," dictionary in three different ways: first with a custom typed ",(0,i.yg)("inlineCode",{parentName:"p"},"TDictionary<>")," utility, then using the TypeScript ",(0,i.yg)("inlineCode",{parentName:"p"},"Record<>")," utility type and finally with the TypeScript type supported ",(0,i.yg)("inlineCode",{parentName:"p"},"Map<>")," instance."),(0,i.yg)("p",null,"While exploring the examples, we encountered a type incompaitbility problem (TS ",(0,i.yg)("inlineCode",{parentName:"p"},"7503")," error) of dictionary keys implemented with a TypeScript mapped type. And we learned how to resolve it by type assertion with the ",(0,i.yg)("inlineCode",{parentName:"p"},"as")," operator."))}h.isMDXComponent=!0}}]);