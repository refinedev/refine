"use strict";(self.webpackChunkdocumentation=self.webpackChunkdocumentation||[]).push([[16902],{58860:(e,n,t)=>{t.d(n,{xA:()=>p,yg:()=>g});var a=t(37953);function o(e,n,t){return n in e?Object.defineProperty(e,n,{value:t,enumerable:!0,configurable:!0,writable:!0}):e[n]=t,e}function s(e,n){var t=Object.keys(e);if(Object.getOwnPropertySymbols){var a=Object.getOwnPropertySymbols(e);n&&(a=a.filter((function(n){return Object.getOwnPropertyDescriptor(e,n).enumerable}))),t.push.apply(t,a)}return t}function i(e){for(var n=1;n<arguments.length;n++){var t=null!=arguments[n]?arguments[n]:{};n%2?s(Object(t),!0).forEach((function(n){o(e,n,t[n])})):Object.getOwnPropertyDescriptors?Object.defineProperties(e,Object.getOwnPropertyDescriptors(t)):s(Object(t)).forEach((function(n){Object.defineProperty(e,n,Object.getOwnPropertyDescriptor(t,n))}))}return e}function r(e,n){if(null==e)return{};var t,a,o=function(e,n){if(null==e)return{};var t,a,o={},s=Object.keys(e);for(a=0;a<s.length;a++)t=s[a],n.indexOf(t)>=0||(o[t]=e[t]);return o}(e,n);if(Object.getOwnPropertySymbols){var s=Object.getOwnPropertySymbols(e);for(a=0;a<s.length;a++)t=s[a],n.indexOf(t)>=0||Object.prototype.propertyIsEnumerable.call(e,t)&&(o[t]=e[t])}return o}var l=a.createContext({}),c=function(e){var n=a.useContext(l),t=n;return e&&(t="function"==typeof e?e(n):i(i({},n),e)),t},p=function(e){var n=c(e.components);return a.createElement(l.Provider,{value:n},e.children)},u="mdxType",m={inlineCode:"code",wrapper:function(e){var n=e.children;return a.createElement(a.Fragment,{},n)}},d=a.forwardRef((function(e,n){var t=e.components,o=e.mdxType,s=e.originalType,l=e.parentName,p=r(e,["components","mdxType","originalType","parentName"]),u=c(t),d=o,g=u["".concat(l,".").concat(d)]||u[d]||m[d]||s;return t?a.createElement(g,i(i({ref:n},p),{},{components:t})):a.createElement(g,i({ref:n},p))}));function g(e,n){var t=arguments,o=n&&n.mdxType;if("string"==typeof e||o){var s=t.length,i=new Array(s);i[0]=d;var r={};for(var l in n)hasOwnProperty.call(n,l)&&(r[l]=n[l]);r.originalType=e,r[u]="string"==typeof e?e:o,i[1]=r;for(var c=2;c<s;c++)i[c]=t[c];return a.createElement.apply(null,i)}return a.createElement.apply(null,t)}d.displayName="MDXCreateElement"},45381:(e,n,t)=>{t.r(n),t.d(n,{assets:()=>p,contentTitle:()=>l,default:()=>y,frontMatter:()=>r,metadata:()=>c,toc:()=>u});t(37953);var a=t(58860);function o(e,n,t){return n in e?Object.defineProperty(e,n,{value:t,enumerable:!0,configurable:!0,writable:!0}):e[n]=t,e}function s(e,n){return n=null!=n?n:{},Object.getOwnPropertyDescriptors?Object.defineProperties(e,Object.getOwnPropertyDescriptors(n)):function(e,n){var t=Object.keys(e);if(Object.getOwnPropertySymbols){var a=Object.getOwnPropertySymbols(e);n&&(a=a.filter((function(n){return Object.getOwnPropertyDescriptor(e,n).enumerable}))),t.push.apply(t,a)}return t}(Object(n)).forEach((function(t){Object.defineProperty(e,t,Object.getOwnPropertyDescriptor(n,t))})),e}function i(e,n){if(null==e)return{};var t,a,o=function(e,n){if(null==e)return{};var t,a,o={},s=Object.keys(e);for(a=0;a<s.length;a++)t=s[a],n.indexOf(t)>=0||(o[t]=e[t]);return o}(e,n);if(Object.getOwnPropertySymbols){var s=Object.getOwnPropertySymbols(e);for(a=0;a<s.length;a++)t=s[a],n.indexOf(t)>=0||Object.prototype.propertyIsEnumerable.call(e,t)&&(o[t]=e[t])}return o}const r={title:"Memoization in React - How useCallback Works",description:"Improve app performance with React useCallback() hook.",slug:"react-usecallback-guide",authors:"abdullah_numan",tags:["react"],image:"https://refine.ams3.cdn.digitaloceanspaces.com/blog/2022-09-20-react-use-callback/social-2.png",hide_table_of_contents:!1},l=void 0,c={permalink:"/blog/react-usecallback-guide",source:"@site/blog/2024-09-26-react-use-callback.md",title:"Memoization in React - How useCallback Works",description:"Improve app performance with React useCallback() hook.",date:"2024-09-26T00:00:00.000Z",formattedDate:"September 26, 2024",tags:[{label:"react",permalink:"/blog/tags/react"}],readingTime:12.895,hasTruncateMarker:!1,authors:[{name:"Abdullah Numan",title:"Fullstack Developer",url:"https://github.com/anewman15/",imageURL:"https://github.com/anewman15.png",key:"abdullah_numan"}],frontMatter:{title:"Memoization in React - How useCallback Works",description:"Improve app performance with React useCallback() hook.",slug:"react-usecallback-guide",authors:"abdullah_numan",tags:["react"],image:"https://refine.ams3.cdn.digitaloceanspaces.com/blog/2022-09-20-react-use-callback/social-2.png",hide_table_of_contents:!1},prevItem:{title:"An Intro to Server Components in React",permalink:"/blog/react-server-components"},nextItem:{title:"gRPC vs REST - A Brief Comparison",permalink:"/blog/grpc-vs-rest"},relatedPosts:[{title:"How to implement a date picker in React",description:"We\u2019ll show you how to implement a date picker using the \u2018react-datepicker\u2019 library and how to customize the functionality for your use case.",permalink:"/blog/react-date-picker",formattedDate:"November 12, 2024",authors:[{name:"Irakli Tchigladze",title:"Web Developer",imageURL:"/img/generic-profile.png",key:"irakli_tchigladze"}],readingTime:24.175,date:"2024-11-12T00:00:00.000Z"},{title:"React useEffect Cleanup Function",description:"Understanding the cleanup function of the useEffect hook in React. Learn how to clean up side effects in React components to prevent memory leaks and improve performance.",permalink:"/blog/useeffect-cleanup",formattedDate:"March 22, 2024",authors:[{name:"Peter Osah",title:"Web Developer",imageURL:"/img/generic-profile.png",key:"peter_osah"}],readingTime:5.865,date:"2024-03-22T00:00:00.000Z"},{title:"Material UI button in React",description:"A complete guide on using Material UI button in a React app",permalink:"/blog/mui-button-in-react",formattedDate:"December 10, 2024",authors:[{name:"Doro Onome",title:"Software Developer",url:"https://github.com/Nomzy-kush",imageURL:"https://github.com/Nomzy-kush.png",key:"doro_onome"}],readingTime:11.355,date:"2024-12-10T00:00:00.000Z"}],authorPosts:[{title:"Setting Up the Invoicer App",description:"We start with setting up the Invoicer app by choosing Ant Design as a UI framework and Strapi as a dataprovider",permalink:"/blog/refine-react-invoice-generator-2",formattedDate:"April 11, 2023",authors:[{name:"Abdullah Numan",title:"Fullstack Developer",url:"https://github.com/anewman15/",imageURL:"https://github.com/anewman15.png",key:"abdullah_numan"}],readingTime:19.145,date:"2023-04-11T00:00:00.000Z"},{title:"TypeScript keyof with Examples",description:"This post explains with examples how the keyof operator is used to define advanced types in TypeScript.",permalink:"/blog/typescript-keyof",formattedDate:"April 1, 2024",authors:[{name:"Abdullah Numan",title:"Fullstack Developer",url:"https://github.com/anewman15/",imageURL:"https://github.com/anewman15.png",key:"abdullah_numan"}],readingTime:10.1,date:"2024-04-01T00:00:00.000Z"},{title:"Creating an Admin Dashboard with Refine",description:"We'll be building a admin backend app for the Pixels client app.",permalink:"/blog/refine-pixels-5",formattedDate:"February 18, 2023",authors:[{name:"Abdullah Numan",title:"Fullstack Developer",url:"https://github.com/anewman15/",imageURL:"https://github.com/anewman15.png",key:"abdullah_numan"}],readingTime:18.84,date:"2023-02-18T00:00:00.000Z"}]},p={authorsImageUrls:[void 0]},u=[{value:"Introduction",id:"introduction",level:2},{value:"What is React <code>useCallback</code> ?",id:"what-is-react-usecallback-",level:2},{value:"Why Use React <code>useCallback</code> Hook?",id:"why-use-react-usecallback-hook",level:3},{value:"Memoize Functions with React <code>useCallback</code>: Ensuring A Callback&#39;s Referential Equality",id:"memoize-functions-with-react-usecallback-ensuring-a-callbacks-referential-equality",level:2},{value:"Project Content Overview",id:"project-content-overview",level:3},{value:"Code Investigation",id:"code-investigation",level:3},{value:"Referential Inequality of Callbacks: Observing Unnecessary Re-renders",id:"referential-inequality-of-callbacks-observing-unnecessary-re-renders",level:3},{value:"Memoizing an Event Listener with <code>useCallback()</code>",id:"memoizing-an-event-listener-with-usecallback",level:3},{value:"React <code>useCallback</code> with Dependencies",id:"react-usecallback-with-dependencies",level:3},{value:"useCallback vs useMemo",id:"usecallback-vs-usememo",level:2},{value:"<strong>useCallback</strong>",id:"usecallback",level:4},{value:"<strong>useMemo</strong>",id:"usememo",level:4},{value:"<strong>Key Differences</strong>",id:"key-differences",level:4},{value:"<strong>When to Use useCallback</strong>",id:"when-to-use-usecallback",level:4},{value:"<strong>When to Use useMemo</strong>",id:"when-to-use-usememo",level:4},{value:"<strong>Analogy</strong>",id:"analogy",level:4},{value:"<strong>Practical Example</strong>",id:"practical-example",level:4},{value:"When to Use React <code>useCallback</code>",id:"when-to-use-react-usecallback",level:2},{value:"Other Cases",id:"other-cases",level:3},{value:"When Not to Use React&#39;s <code>useCallback</code> Hook",id:"when-not-to-use-reacts-usecallback-hook",level:2},{value:"Bonus:useCallback with Other Hooks",id:"bonususecallback-with-other-hooks",level:2},{value:"<strong>useCallback and useEffect</strong>",id:"usecallback-and-useeffect",level:4},{value:"<strong>useCallback and useMemo</strong>",id:"usecallback-and-usememo",level:4},{value:"<strong>useCallback and useContext</strong>",id:"usecallback-and-usecontext",level:4},{value:"<strong>useCallback and Custom Hooks</strong>",id:"usecallback-and-custom-hooks",level:4},{value:"Summary",id:"summary",level:2},{value:"Example",id:"example",level:2}],m=(d="CodeSandboxExample",function(e){return console.warn("Component "+d+" was not imported, exported, or provided by MDXProvider as global scope"),(0,a.yg)("div",e)});var d;const g={toc:u},h="wrapper";function y(e){var{components:n}=e,t=i(e,["components"]);return(0,a.yg)(h,s(function(e){for(var n=1;n<arguments.length;n++){var t=null!=arguments[n]?arguments[n]:{},a=Object.keys(t);"function"==typeof Object.getOwnPropertySymbols&&(a=a.concat(Object.getOwnPropertySymbols(t).filter((function(e){return Object.getOwnPropertyDescriptor(t,e).enumerable})))),a.forEach((function(n){o(e,n,t[n])}))}return e}({},g,t),{components:n,mdxType:"MDXLayout"}),(0,a.yg)("p",null,(0,a.yg)("strong",{parentName:"p"},(0,a.yg)("em",{parentName:"strong"},"This article was last updated on January 25, 2024 to include comparisons between useCallback and useMeme and how to use useCallback with other hooks."))),(0,a.yg)("h2",{id:"introduction"},"Introduction"),(0,a.yg)("p",null,"This post is about using the React ",(0,a.yg)("inlineCode",{parentName:"p"},"useCallback()")," hook. We demonstrate the use of ",(0,a.yg)("inlineCode",{parentName:"p"},"useCallback")," in a React component and examine how it impacts performance in a demo app."),(0,a.yg)("p",null,"This is the third and final part of the ",(0,a.yg)("a",{parentName:"p",href:"https://refine.dev/blog/react-memo-guide/"},"React Memoization Series")," hosted on ",(0,a.yg)("a",{parentName:"p",href:"https://refine.dev/blog/"},"Refine.dev blog"),"."),(0,a.yg)("p",null,"The preceding two parts are:"),(0,a.yg)("ol",null,(0,a.yg)("li",{parentName:"ol"},(0,a.yg)("a",{parentName:"li",href:"https://refine.dev/blog/react-memo-guide/"},"React Memo Guide with Examples")),(0,a.yg)("li",{parentName:"ol"},(0,a.yg)("a",{parentName:"li",href:"https://refine.dev/blog/react-usememo/"},"React useMemo Hook Guide With Examples"))),(0,a.yg)("p",null,"In this post, we explore how to use React ",(0,a.yg)("inlineCode",{parentName:"p"},"useCallback")," in order to memoize a function passed from a parent to a child component. We follow up by making changes to the demo blog app in ",(0,a.yg)("a",{parentName:"p",href:"https://refine.dev/blog/react-usememo/"},"Part II")," and try to understand how function memoization using ",(0,a.yg)("inlineCode",{parentName:"p"},"useCallback")," gives performance gains to a React app."),(0,a.yg)("p",null,"Steps we'll cover:"),(0,a.yg)("ul",null,(0,a.yg)("li",{parentName:"ul"},(0,a.yg)("a",{parentName:"li",href:"#introduction"},"Introduction")),(0,a.yg)("li",{parentName:"ul"},(0,a.yg)("a",{parentName:"li",href:"#what-is-react-usecallback-"},"What is React ",(0,a.yg)("inlineCode",{parentName:"a"},"useCallback")," ?")),(0,a.yg)("li",{parentName:"ul"},(0,a.yg)("a",{parentName:"li",href:"#usecallback-vs-usememo"},"useCallback vs useMemo")),(0,a.yg)("li",{parentName:"ul"},(0,a.yg)("a",{parentName:"li",href:"#when-to-use-react-usecallback"},"When to Use React ",(0,a.yg)("inlineCode",{parentName:"a"},"useCallback"))),(0,a.yg)("li",{parentName:"ul"},(0,a.yg)("a",{parentName:"li",href:"#when-not-to-use-reacts-usecallback-hook"},"When Not to Use React's ",(0,a.yg)("inlineCode",{parentName:"a"},"useCallback")," Hook")),(0,a.yg)("li",{parentName:"ul"},(0,a.yg)("a",{parentName:"li",href:"#bonususecallback-with-other-hooks"},"Bonus:useCallback with Other Hooks")),(0,a.yg)("li",{parentName:"ul"},(0,a.yg)("a",{parentName:"li",href:"#example"},"Example"))),(0,a.yg)("h2",{id:"what-is-react-usecallback-"},"What is React ",(0,a.yg)("inlineCode",{parentName:"h2"},"useCallback")," ?"),(0,a.yg)("p",null,"React ",(0,a.yg)("inlineCode",{parentName:"p"},"useCallback()")," is a hook that memoizes a function definition and ensures its referential integrity between re-renders of a React component. It works by accepting the function as an argument, memoizing it, and then returning the memoized function. The memoized function then can be passed down to child components and invoked from therein."),(0,a.yg)("p",null,"Memoization of a function definition with ",(0,a.yg)("inlineCode",{parentName:"p"},"useCallback")," helps optimize a React component by preventing unnecessary re-renderings originating from a change in the function's object identity."),(0,a.yg)("h3",{id:"why-use-react-usecallback-hook"},"Why Use React ",(0,a.yg)("inlineCode",{parentName:"h3"},"useCallback")," Hook?"),(0,a.yg)("p",null,"In React, callback functions like event handlers inside a component create new individual function objects at every re-render of the component. This behavior breaks referential equality of callbacks passed to and invoked inside a child component."),(0,a.yg)("p",null,"For example, in a case where a callback is passed from a parent component to a child as a prop, by default, the child receives a new copy of the callback at every render of the parent. This leads to an additional re-render in the child component just because of the change in the accepted function object's identity. Such unnecessary re-renders add to the app's cost. So, callback functions in React should be memoized in a way that they maintain referential integrity across re-renders of a parent component."),(0,a.yg)("p",null,"Memoizing a callback in React with ",(0,a.yg)("inlineCode",{parentName:"p"},"useCallback()")," helps ensure the function's referential integrity and prevent these re-renders. ",(0,a.yg)("inlineCode",{parentName:"p"},"useCallback()")," works by storing the function object itself. So, every time the parent re-renders, the same callback object is passed to the child and the child's re-render is prevented."),(0,a.yg)("h2",{id:"memoize-functions-with-react-usecallback-ensuring-a-callbacks-referential-equality"},"Memoize Functions with React ",(0,a.yg)("inlineCode",{parentName:"h2"},"useCallback"),": Ensuring A Callback's Referential Equality"),(0,a.yg)("p",null,"In the sections ahead, inside the demo blog app, we first examine the way a callback, ",(0,a.yg)("inlineCode",{parentName:"p"},"deletePost"),", passed to a child component (",(0,a.yg)("inlineCode",{parentName:"p"},"<UserPostsList />"),") by default triggers unnecessary re-renders. We then implement memoization of the callback function with the ",(0,a.yg)("inlineCode",{parentName:"p"},"useCallback")," hook and observe how it prevents these re-renders."),(0,a.yg)("p",null,"Prior to that, let's first get familiar with the code we are dealing with."),(0,a.yg)("h3",{id:"project-content-overview"},"Project Content Overview"),(0,a.yg)("p",null,"The demo app is the same one we have been using in the ",(0,a.yg)("a",{parentName:"p",href:"https://refine.dev/blog/react-memo-guide/"},"React Memoization Series"),". It is based on the idea of a list of posts on a blog."),(0,a.yg)("p",null,"We recommend you follow along from Part I and II. This way, you should already have the app cloned, opened in a code editor, installed, and up and running in a browser."),(0,a.yg)("p",null,"There are several components involving a user seeing the latest posts and a list of the user's posts. Allow yourself some time to understand the components individually, their relationships and their state changes. You should especially be familiar with what's going on in the ",(0,a.yg)("inlineCode",{parentName:"p"},"<UserPostsIndex />"),", ",(0,a.yg)("inlineCode",{parentName:"p"},"<UserPostsList />")," and ",(0,a.yg)("inlineCode",{parentName:"p"},"<UserPosts />")," components before we make the changes to with ",(0,a.yg)("inlineCode",{parentName:"p"},"useCallback"),"."),(0,a.yg)("p",null,(0,a.yg)("a",{parentName:"p",href:"#live-stackblitz-example"},"The example app live code")),(0,a.yg)("p",null,"The discussion of this article is focused on optimizing performance by memoizing callback functions that are passed as a prop from a parent component to a child. We are going to use the ",(0,a.yg)("inlineCode",{parentName:"p"},"useCallback()")," hook for this."),(0,a.yg)("h3",{id:"code-investigation"},"Code Investigation"),(0,a.yg)("p",null,"As we're already familiar with the ",(0,a.yg)("inlineCode",{parentName:"p"},"<App />")," and ",(0,a.yg)("inlineCode",{parentName:"p"},"<Blog />")," components from Part I and II, in this post, we'll start with the",(0,a.yg)("inlineCode",{parentName:"p"},"<UserPostsIndex />")," component. It looks like this:"),(0,a.yg)("pre",null,(0,a.yg)("code",{parentName:"pre",className:"language-tsx",metastring:'title="components/UserPostIndex.jsx"',title:'"components/UserPostIndex.jsx"'},'import React, { useEffect, useState } from "react";\nimport fetchUserPosts from "../fetch/fetchUserPosts";\nimport UserPostsList from "./UserPostsList";\n\nconst UserPostsIndex = ({ signedIn }) => {\n  const [userPosts, setUserPosts] = useState([]);\n\n  const deletePost = (e) => {\n    const { postId } = e.currentTarget.dataset;\n    const remainingPosts = userPosts.filter(\n      (post) => post.id !== parseInt(postId),\n    );\n    setUserPosts(remainingPosts);\n  };\n\n  useEffect(() => {\n    const posts = fetchUserPosts();\n    setUserPosts(posts);\n  }, []);\n\n  return (\n    <div className="box my-1 p-2">\n      <div className="m-1 py-1">\n        <h2 className="heading-md">Your Posts</h2>\n        <p className="m-1 p-1">{signedIn ? `Signed in` : `Signed out `}</p>\n        {userPosts && (\n          <div className="px-1">\n            {<UserPostsList userPosts={userPosts} deletePost={deletePost} />}\n          </div>\n        )}\n      </div>\n    </div>\n  );\n};\n\nexport default React.memo(UserPostsIndex);\n')),(0,a.yg)("p",null,"As you can see, ",(0,a.yg)("inlineCode",{parentName:"p"},"<UserPostsIndex />")," receives ",(0,a.yg)("inlineCode",{parentName:"p"},"signedIn")," as a prop from ",(0,a.yg)("inlineCode",{parentName:"p"},"<Blog />"),". It then fetches the user's posts and sets ",(0,a.yg)("inlineCode",{parentName:"p"},"userPosts")," when the component mounts."),(0,a.yg)("p",null,"In the JSX, a ",(0,a.yg)("inlineCode",{parentName:"p"},"<UserPostsList />")," component is rendered with ",(0,a.yg)("inlineCode",{parentName:"p"},"deletePost")," function passed to it, along with ",(0,a.yg)("inlineCode",{parentName:"p"},"userPosts"),"."),(0,a.yg)("p",null,"The ",(0,a.yg)("inlineCode",{parentName:"p"},"<UserPostsList>")," component looks like this:"),(0,a.yg)("pre",null,(0,a.yg)("code",{parentName:"pre",className:"language-tsx",metastring:'title="components/UserPostList.jsx"',title:'"components/UserPostList.jsx"'},'import React from "react";\nimport UserPost from "./UserPost";\n\nconst UserPostsList = ({ userPosts, deletePost }) => {\n  console.log("Rendering UserPostsList component");\n\n  return (\n    <div className="px-1">\n      {userPosts.map((post) => (\n        <div key={post.id} className="box my-1 flex-row">\n          <UserPost post={post} />\n          <button\n            className="btn btn-danger"\n            data-post-id={post.id}\n            onClick={deletePost}\n          >\n            Delete\n          </button>\n        </div>\n      ))}\n    </div>\n  );\n};\n\nexport default React.memo(UserPostsList);\n')),(0,a.yg)("p",null,"Here, we are receiving the ",(0,a.yg)("inlineCode",{parentName:"p"},"userPosts")," array and the ",(0,a.yg)("inlineCode",{parentName:"p"},"deletePost")," callback. In the JSX, we map a ",(0,a.yg)("inlineCode",{parentName:"p"},"<UserPost />")," to each post in ",(0,a.yg)("inlineCode",{parentName:"p"},"userPosts")," array and invoke ",(0,a.yg)("inlineCode",{parentName:"p"},"deletePost()")," to remove a post from the list."),(0,a.yg)("p",null,(0,a.yg)("inlineCode",{parentName:"p"},"<UserPost />")," is a presentational component where we display the title as a link. It looks like this:"),(0,a.yg)("pre",null,(0,a.yg)("code",{parentName:"pre",className:"language-jsx"},'import React from "react";\n\nconst UserPost = ({ post }) => {\n  // console.log(\'Rendering UserPost component\')\n\n  return (\n    <div className="flex-row-left my-1">\n      <a href={`#${post.title}`} className="">\n        <h4 id={post.title} className="font-sm px-2 font-bold">\n          {post.title}\n        </h4>\n      </a>\n    </div>\n  );\n};\n\nexport default UserPost;\n')),(0,a.yg)("h3",{id:"referential-inequality-of-callbacks-observing-unnecessary-re-renders"},"Referential Inequality of Callbacks: Observing Unnecessary Re-renders"),(0,a.yg)("p",null,"As you can already tell, ",(0,a.yg)("inlineCode",{parentName:"p"},"deletePost")," is a callback function expected cause re-renders of ",(0,a.yg)("inlineCode",{parentName:"p"},"<UserPostsList />"),". In order to observe them, let's add the following to ",(0,a.yg)("inlineCode",{parentName:"p"},"<UserPostsIndex />"),":"),(0,a.yg)("pre",null,(0,a.yg)("code",{parentName:"pre",className:"language-tsx",metastring:'title="components/UserPostIndex.jsx"',title:'"components/UserPostIndex.jsx"'},'console.log("Rendering UserPostsIndex component");\n')),(0,a.yg)("p",null,"And this one to ",(0,a.yg)("inlineCode",{parentName:"p"},"<UserPostsList />"),":"),(0,a.yg)("pre",null,(0,a.yg)("code",{parentName:"pre",className:"language-tsx",metastring:'title="components/UserPostList.jsx"',title:'"components/UserPostList.jsx"'},'console.log("Rendering UserPostsList component");\n')),(0,a.yg)("p",null,"If we check our console now, we can see the logs showing the initial rendering of these components."),(0,a.yg)("p",null,"Then if we click the ",(0,a.yg)("inlineCode",{parentName:"p"},"SignOut")," button on the navbar, we see batches of renders originating from ",(0,a.yg)("inlineCode",{parentName:"p"},"<UserPostsIndex />"),", ",(0,a.yg)("inlineCode",{parentName:"p"},"<UserPostsList />")," and ",(0,a.yg)("inlineCode",{parentName:"p"},"<UserPost />"),":"),(0,a.yg)("div",{class:"img-container","align-items":"center"},(0,a.yg)("img",{style:{alignSelf:"center",width:"400px"},src:"https://refine.ams3.cdn.digitaloceanspaces.com/blog/2022-09-20-react-use-callback/usecallback1.png",alt:"usecallback1"})),(0,a.yg)("p",null,"It is possible to account for the re-render of ",(0,a.yg)("inlineCode",{parentName:"p"},"<UserPostsIndex />")," because the value of the ",(0,a.yg)("inlineCode",{parentName:"p"},"signedIn")," prop changed when we clicked ",(0,a.yg)("inlineCode",{parentName:"p"},"Sign Out"),"."),(0,a.yg)("p",null,"However, re-rendering of ",(0,a.yg)("inlineCode",{parentName:"p"},"<UserPostsList />")," at first does not make sense because we expect it to re-render when only ",(0,a.yg)("inlineCode",{parentName:"p"},"userPosts")," change. And ",(0,a.yg)("inlineCode",{parentName:"p"},"userPosts")," does not change with the change in the value of ",(0,a.yg)("inlineCode",{parentName:"p"},"signedIn"),". And since nothing else is notably changing."),(0,a.yg)("p",null,"Also, we already memoized ",(0,a.yg)("inlineCode",{parentName:"p"},"<UserPostsList />")," with ",(0,a.yg)("inlineCode",{parentName:"p"},"React.memo()")," to prevent its re-renders due to changes in any of its ancestors' state."),(0,a.yg)("p",null,"But curious, if ",(0,a.yg)("inlineCode",{parentName:"p"},"deletePost")," changes ?"),(0,a.yg)("p",null,"Well, it does. It changes due to ",(0,a.yg)("strong",{parentName:"p"},"referential inequality")," because at every re-render of ",(0,a.yg)("inlineCode",{parentName:"p"},"<UserPostsIndex />"),", a new ",(0,a.yg)("inlineCode",{parentName:"p"},"deletePost")," function object is spun into runtime. This change in object identity triggers a re-render in ",(0,a.yg)("inlineCode",{parentName:"p"},"<UserPostsList />"),". The way it is happening above is, when we change ",(0,a.yg)("inlineCode",{parentName:"p"},"signedIn"),", ",(0,a.yg)("inlineCode",{parentName:"p"},"<UserPostsIndex />")," re-renders, creates and passes in a new version of ",(0,a.yg)("inlineCode",{parentName:"p"},"deletePost")," and causes ",(0,a.yg)("inlineCode",{parentName:"p"},"<UserPostsList />")," to re-render."),(0,a.yg)("h3",{id:"memoizing-an-event-listener-with-usecallback"},"Memoizing an Event Listener with ",(0,a.yg)("inlineCode",{parentName:"h3"},"useCallback()")),(0,a.yg)("p",null,"Now, memoizing ",(0,a.yg)("inlineCode",{parentName:"p"},"deletePost")," would deliver the same function object at every re-render of ",(0,a.yg)("inlineCode",{parentName:"p"},"<UserPostsIndex />"),". So, let's memoize it with ",(0,a.yg)("inlineCode",{parentName:"p"},"useCallback()")," by making the following changes in ",(0,a.yg)("inlineCode",{parentName:"p"},"<UserPostsIndex />"),":"),(0,a.yg)("pre",null,(0,a.yg)("code",{parentName:"pre",className:"language-tsx",metastring:'title="components/UserPostsIndex.jsx"',title:'"components/UserPostsIndex.jsx"'},'  // highlight-next-line\nimport React, { useCallback, useEffect, useState } from "react";\n\nconst UserPostsIndex = ({ signedIn }) => {\n\n// highlight-next-line\n  const deletePost = useCallback(e => {\n    const { postId } = e.currentTarget.dataset;\n    const remainingPosts = userPosts.filter(post => post.id !== parseInt(postId));\n    setUserPosts(remainingPosts);\n    // highlight-next-line\n  }, [userPosts]);\n\n  ...\n\n};\n\nexport default React.memo(UserPostsIndex);\n')),(0,a.yg)("p",null,"Now, if we click the ",(0,a.yg)("inlineCode",{parentName:"p"},"Sign Out")," button a few times, we'll see in the console that ",(0,a.yg)("inlineCode",{parentName:"p"},"<UserPostsIndex />")," is re-rendered, but ",(0,a.yg)("inlineCode",{parentName:"p"},"<UserPostsList />")," and ",(0,a.yg)("inlineCode",{parentName:"p"},"<UserPost />")," are not:"),(0,a.yg)("div",{class:"img-container","align-items":"center"},(0,a.yg)("img",{style:{alignSelf:"center",width:"400px"},src:"https://refine.ams3.cdn.digitaloceanspaces.com/blog/2022-09-20-react-use-callback/usecallback2.png",alt:"usecallback2"})),(0,a.yg)("br",null),(0,a.yg)("p",null,"This is because ",(0,a.yg)("inlineCode",{parentName:"p"},"useCallback()")," caches and produces the same copy of ",(0,a.yg)("inlineCode",{parentName:"p"},"deletePost")," at every render of ",(0,a.yg)("inlineCode",{parentName:"p"},"<UserPostsIndex />"),". So referential integrity of ",(0,a.yg)("inlineCode",{parentName:"p"},"deletePost")," is maintained and it prevents unnecessary re-renderings of ",(0,a.yg)("inlineCode",{parentName:"p"},"<UserPostsList />"),", contributing to performance optimization of the component."),(0,a.yg)("h3",{id:"react-usecallback-with-dependencies"},"React ",(0,a.yg)("inlineCode",{parentName:"h3"},"useCallback")," with Dependencies"),(0,a.yg)("p",null,"Notice we are passing a dependency in the array passed as the second argument of ",(0,a.yg)("inlineCode",{parentName:"p"},"useCallback"),". With ",(0,a.yg)("inlineCode",{parentName:"p"},"userPosts")," as a dependency, we want a change in ",(0,a.yg)("inlineCode",{parentName:"p"},"userPosts")," to trigger a renewal of the function memo. So, every time the value of ",(0,a.yg)("inlineCode",{parentName:"p"},"userPosts")," changes, a new ",(0,a.yg)("inlineCode",{parentName:"p"},"deletePost")," function object will be created in ",(0,a.yg)("inlineCode",{parentName:"p"},"<UserPostsIndex />")," and ",(0,a.yg)("inlineCode",{parentName:"p"},"<UserPostsList />")," will be re-rendered."),(0,a.yg)("h2",{id:"usecallback-vs-usememo"},"useCallback vs useMemo"),(0,a.yg)("p",null,"Many devs, including myself from time to time, get confused as to when to use which."),(0,a.yg)("p",null,"Understanding the difference between ",(0,a.yg)("inlineCode",{parentName:"p"},"useCallback")," and ",(0,a.yg)("inlineCode",{parentName:"p"},"useMemo")," goes a long way in optimizing React applications. What follows is a simple comparison that should make their purposes clear and when each should be used."),(0,a.yg)("h4",{id:"usecallback"},(0,a.yg)("strong",{parentName:"h4"},"useCallback")),(0,a.yg)("p",null,(0,a.yg)("inlineCode",{parentName:"p"},"useCallback")," memoizes a function definition so that it doesn't get recreated on every render unless its dependencies change."),(0,a.yg)("p",null,"Comes in handy when you want to pass some callback functions to a child component wrapped with ",(0,a.yg)("inlineCode",{parentName:"p"},"React.memo")," to avoid unnecessary re-renders."),(0,a.yg)("pre",null,(0,a.yg)("code",{parentName:"pre",className:"language-jsx"},"let handleClick = useCallback(() => {\n  // Function logic here\n}, [dependencies]);\n")),(0,a.yg)("p",null,"In the example, ",(0,a.yg)("inlineCode",{parentName:"p"},"handleClick")," will have the same reference on every render unless dependencies change."),(0,a.yg)("h4",{id:"usememo"},(0,a.yg)("strong",{parentName:"h4"},"useMemo")),(0,a.yg)("p",null,(0,a.yg)("inlineCode",{parentName:"p"},"useMemo")," memoizes the result of a function call, caching the value that would be returned.\nPerfect for expensive calculations that you don't want to recompute on every render unless certain dependencies change."),(0,a.yg)("pre",null,(0,a.yg)("code",{parentName:"pre",className:"language-jsx"},"const computedValue = useMemo(() => {\n  return expensiveCalculation(data);\n}, [data]);\n")),(0,a.yg)("p",null,"Here, ",(0,a.yg)("inlineCode",{parentName:"p"},"computedValue")," would only be re-evaluated when ",(0,a.yg)("inlineCode",{parentName:"p"},"data")," changes."),(0,a.yg)("h4",{id:"key-differences"},(0,a.yg)("strong",{parentName:"h4"},"Key Differences")),(0,a.yg)("ul",null,(0,a.yg)("li",{parentName:"ul"},(0,a.yg)("strong",{parentName:"li"},"What They Return"),":",(0,a.yg)("ul",{parentName:"li"},(0,a.yg)("li",{parentName:"ul"},(0,a.yg)("inlineCode",{parentName:"li"},"useCallback")," returns a memoized ",(0,a.yg)("strong",{parentName:"li"},"function"),"."),(0,a.yg)("li",{parentName:"ul"},(0,a.yg)("inlineCode",{parentName:"li"},"useMemo")," returns a memoized ",(0,a.yg)("strong",{parentName:"li"},"value"),"."))),(0,a.yg)("li",{parentName:"ul"},(0,a.yg)("strong",{parentName:"li"},"Main Usefulness"),":",(0,a.yg)("ul",{parentName:"li"},(0,a.yg)("li",{parentName:"ul"},(0,a.yg)("inlineCode",{parentName:"li"},"useCallback")," prevents unnecessary re-creations of functions."),(0,a.yg)("li",{parentName:"ul"},(0,a.yg)("inlineCode",{parentName:"li"},"useMemo")," avoids recalculating a value when it is not necessary.")))),(0,a.yg)("h4",{id:"when-to-use-usecallback"},(0,a.yg)("strong",{parentName:"h4"},"When to Use useCallback")),(0,a.yg)("ul",null,(0,a.yg)("li",{parentName:"ul"},(0,a.yg)("strong",{parentName:"li"},"Preventing Re-renders of Children"),": When implementing the ",(0,a.yg)("inlineCode",{parentName:"li"},"useCallback")," hook with a function passed as a prop to a child that is optimized by ",(0,a.yg)("inlineCode",{parentName:"li"},"React.memo"),", it ensures the reference of that function does not get recreated unnecessarily."),(0,a.yg)("li",{parentName:"ul"},(0,a.yg)("strong",{parentName:"li"},"Event Handlers"),": If functions are created on every render\u2014event handlers, for example\u2014you can keep its reference by using ",(0,a.yg)("inlineCode",{parentName:"li"},"useCallback"),".")),(0,a.yg)("h4",{id:"when-to-use-usememo"},(0,a.yg)("strong",{parentName:"h4"},"When to Use useMemo")),(0,a.yg)("ul",null,(0,a.yg)("li",{parentName:"ul"},(0,a.yg)("strong",{parentName:"li"},"Expensive Computations"),": When you have a function that performs a heavy computation, and you want to avoid it running on each render."),(0,a.yg)("li",{parentName:"ul"},(0,a.yg)("strong",{parentName:"li"},"Derived Data"),": Computed result based on props or state which should not re-run unless the dependencies change.")),(0,a.yg)("h4",{id:"analogy"},(0,a.yg)("strong",{parentName:"h4"},"Analogy")),(0,a.yg)("ul",null,(0,a.yg)("li",{parentName:"ul"},"Think of ",(0,a.yg)("inlineCode",{parentName:"li"},"useCallback")," as memoizing the ",(0,a.yg)("strong",{parentName:"li"},"function itself"),", whereas ",(0,a.yg)("inlineCode",{parentName:"li"},"useMemo")," memoizes the ",(0,a.yg)("strong",{parentName:"li"},"result of the function"),".")),(0,a.yg)("h4",{id:"practical-example"},(0,a.yg)("strong",{parentName:"h4"},"Practical Example")),(0,a.yg)("p",null,"For instance, consider the following filtering list scenario:"),(0,a.yg)("ul",null,(0,a.yg)("li",{parentName:"ul"},(0,a.yg)("p",{parentName:"li"},(0,a.yg)("strong",{parentName:"p"},"Using useMemo"),":"),(0,a.yg)("pre",{parentName:"li"},(0,a.yg)("code",{parentName:"pre",className:"language-jsx"},"const filteredItems = useMemo(() => {\n  return items.filter((item) => item.active);\n}, [items]);\n\nreturn <ItemList items={filteredItems} />;\n")),(0,a.yg)("p",{parentName:"li"},"Here, ",(0,a.yg)("inlineCode",{parentName:"p"},"filteredItems")," is re-evaluated only when ",(0,a.yg)("inlineCode",{parentName:"p"},"items")," change.")),(0,a.yg)("li",{parentName:"ul"},(0,a.yg)("p",{parentName:"li"},(0,a.yg)("strong",{parentName:"p"},"With useCallback"),":"),(0,a.yg)("pre",{parentName:"li"},(0,a.yg)("code",{parentName:"pre",className:"language-jsx"},"const getFilteredItems = useCallback(() => {\n  return items.filter((item) => item.active);\n}, [items]);\n\nreturn <ItemList getItems={getFilteredItems} />;\n")),(0,a.yg)("p",{parentName:"li"},"In this case, ",(0,a.yg)("inlineCode",{parentName:"p"},"getFilteredItems")," doesn't change its function reference if ",(0,a.yg)("inlineCode",{parentName:"p"},"items")," haven't changed."))),(0,a.yg)("h2",{id:"when-to-use-react-usecallback"},"When to Use React ",(0,a.yg)("inlineCode",{parentName:"h2"},"useCallback")),(0,a.yg)("p",null,"React ",(0,a.yg)("inlineCode",{parentName:"p"},"useCallback")," hook is intended to memoize a callback function by maintaining its referential integrity. It should not be confused with ",(0,a.yg)("inlineCode",{parentName:"p"},"useMemo")," which is used to cache the value of a function.",(0,a.yg)("inlineCode",{parentName:"p"},"useCallback")," is commonly used for memoizing functions between re-renders."),(0,a.yg)("h3",{id:"other-cases"},"Other Cases"),(0,a.yg)("p",null,"React ",(0,a.yg)("inlineCode",{parentName:"p"},"useCallback()")," is also used to cache callbacks in debouncing, as well as preventing firing of events typically in ",(0,a.yg)("inlineCode",{parentName:"p"},"useEffect()")," hooks."),(0,a.yg)("h2",{id:"when-not-to-use-reacts-usecallback-hook"},"When Not to Use React's ",(0,a.yg)("inlineCode",{parentName:"h2"},"useCallback")," Hook"),(0,a.yg)("p",null,"We should not use the ",(0,a.yg)("inlineCode",{parentName:"p"},"useCallback")," hook for memoizing the value of a function. We should also avoid overusing ",(0,a.yg)("inlineCode",{parentName:"p"},"useCallback")," since the hook itself contributes to the component's cost. It is recommended to use the ",(0,a.yg)("inlineCode",{parentName:"p"},"useCallback")," hook only in cases referential equality of the function is important."),(0,a.yg)("h2",{id:"bonususecallback-with-other-hooks"},"Bonus:useCallback with Other Hooks"),(0,a.yg)("p",null,"I thought it would be worth adding a section to our article about how ",(0,a.yg)("inlineCode",{parentName:"p"},"useCallback")," can be used with other React Hooks."),(0,a.yg)("p",null,"Knowing how ",(0,a.yg)("inlineCode",{parentName:"p"},"useCallback")," works with other React Hooks will make it easier to write good-performing, efficient components. Following are ways that we can combine ",(0,a.yg)("inlineCode",{parentName:"p"},"useCallback")," with other Hooks."),(0,a.yg)("h4",{id:"usecallback-and-useeffect"},(0,a.yg)("strong",{parentName:"h4"},"useCallback and useEffect")),(0,a.yg)("p",null,"When we use ",(0,a.yg)("inlineCode",{parentName:"p"},"useEffect"),", we need to include functions in the dependency array as well. If this function changes at each render, that also will make the ",(0,a.yg)("inlineCode",{parentName:"p"},"useEffect")," run unnecessarily. This is where we wrap up the function with ",(0,a.yg)("inlineCode",{parentName:"p"},"useCallback"),"."),(0,a.yg)("pre",null,(0,a.yg)("code",{parentName:"pre",className:"language-jsx"},'import React, { useState, useEffect, useCallback } from "react";\n\nfunction SearchComponent() {\n  const [query, setQuery] = useState("");\n\n  const fetchResults = useCallback(() => {\n    // Fetch data based on query\n  }, [query]);\n\n  useEffect(() => {\n    fetchResults();\n  }, [fetchResults]);\n\n  return <input value={query} onChange={(e) => setQuery(e.target.value)} />;\n}\n')),(0,a.yg)("p",null,"Above, in the example, ",(0,a.yg)("inlineCode",{parentName:"p"},"fetchResults")," is memoized with ",(0,a.yg)("inlineCode",{parentName:"p"},"useCallback"),", which means that it only changes when ",(0,a.yg)("inlineCode",{parentName:"p"},"query")," changes, so ",(0,a.yg)("inlineCode",{parentName:"p"},"useEffect")," does not run on every render."),(0,a.yg)("h4",{id:"usecallback-and-usememo"},(0,a.yg)("strong",{parentName:"h4"},"useCallback and useMemo")),(0,a.yg)("p",null,"While ",(0,a.yg)("inlineCode",{parentName:"p"},"useCallback")," memoizes functions, ",(0,a.yg)("inlineCode",{parentName:"p"},"useMemo")," memoizes values. Sometimes, we may want to use both to optimize our components."),(0,a.yg)("pre",null,(0,a.yg)("code",{parentName:"pre",className:"language-jsx"},"const memoizedValue = useMemo(() => computeExpensiveValue(a, b), [a, b]);\n\nconst handleClick = useCallback(() => {\n  doSomethingWith(memoizedValue);\n}, [memoizedValue]);\n")),(0,a.yg)("p",null,"Here, we memoize an expensive computation using ",(0,a.yg)("inlineCode",{parentName:"p"},"useMemo"),", then take that value and memoize a function that uses it with ",(0,a.yg)("inlineCode",{parentName:"p"},"useCallback"),"."),(0,a.yg)("h4",{id:"usecallback-and-usecontext"},(0,a.yg)("strong",{parentName:"h4"},"useCallback and useContext")),(0,a.yg)("p",null,"With context, passing down functions may cause re-renders when the function reference changes. Using ",(0,a.yg)("inlineCode",{parentName:"p"},"useCallback")," allows us to prevent unnecessary updates in context consumers."),(0,a.yg)("pre",null,(0,a.yg)("code",{parentName:"pre",className:"language-jsx"},"const MyContext = React.createContext();\n\nfunction MyProvider({ children }) {\n  const [state, setState] = useState(0);\n\n  const increment = useCallback(() => {\n    setState((prev) => prev + 1);\n  }, []);\n\n  return (\n    <MyContext.Provider value={{ state, increment }}>\n      {children}\n    </MyContext.Provider>\n  );\n}\n\nfunction ChildComponent() {\n  const { state, increment } = useContext(MyContext);\n  // ChildComponent won't re-render unless state or increment changes\n}\n")),(0,a.yg)("p",null,"By memoizing ",(0,a.yg)("inlineCode",{parentName:"p"},"increment"),", we make sure that the context value isn't changed when it doesn't need to be, thereby optimizing the components consuming the context."),(0,a.yg)("h4",{id:"usecallback-and-custom-hooks"},(0,a.yg)("strong",{parentName:"h4"},"useCallback and Custom Hooks")),(0,a.yg)("p",null,"When writing custom Hooks, we can always use ",(0,a.yg)("inlineCode",{parentName:"p"},"useCallback")," to memoize functions returned by the hook so that consuming components get stable function references."),(0,a.yg)("pre",null,(0,a.yg)("code",{parentName:"pre",className:"language-jsx"},'function useWindowWidth() {\n  const [width, setWidth] = useState(window.innerWidth);\n\n  const handleResize = useCallback(() => {\n    setWidth(window.innerWidth);\n  }, []);\n\n  useEffect(() => {\n    window.addEventListener("resize", handleResize);\n    return () => window.removeEventListener("resize", handleResize);\n  }, [handleResize]);\n\n  return width;\n}\n')),(0,a.yg)("p",null,"In this custom hook, we memoize ",(0,a.yg)("inlineCode",{parentName:"p"},"handleResize")," with ",(0,a.yg)("inlineCode",{parentName:"p"},"useCallback"),", so that the event listener isn't set anew after every render."),(0,a.yg)("h2",{id:"summary"},"Summary"),(0,a.yg)("p",null,"In this post, we demonstrated how to leverage the React ",(0,a.yg)("inlineCode",{parentName:"p"},"useCallback")," hook in preventing unnecessary re-renderings originating from a callback function's referential inequality."),(0,a.yg)("p",null,"We first observed from the browser's console how a callback passed to a child component triggers useless re-renders due to change in the function's object identity. We then learned how to prevent them by implementing the callback's memoization with React's ",(0,a.yg)("inlineCode",{parentName:"p"},"useCallback()")," hook which helps us produce the same function object at every re-render of the parent."),(0,a.yg)("h2",{id:"example"},"Example"),(0,a.yg)(m,{path:"blog-react-memoization-memo",mdxType:"CodeSandboxExample"}))}y.isMDXComponent=!0}}]);